!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("pixi.js")):"function"==typeof define&&define.amd?define("PIXI3D",["pixi.js"],n):"object"==typeof exports?exports.PIXI3D=n(require("pixi.js")):e.PIXI3D=n(e.PIXI)}(window,(function(e){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=42)}([function(n,t){n.exports=e},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(24),s=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.transform=new a.Transform3D,n}return o(n,e),Object.defineProperty(n.prototype,"position",{get:function(){return this.transform.position},set:function(e){this.transform.position.copyFrom(e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"scale",{get:function(){return this.transform.scale},set:function(e){this.transform.scale.copyFrom(e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"rotationQuaternion",{get:function(){return this.transform.rotationQuaternion},set:function(e){this.transform.rotationQuaternion.copyFrom(e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"z",{get:function(){return this.transform.position.z},set:function(e){this.transform.position.z=e},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"localTransform",{get:function(){return this.transform.localTransform},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"worldTransform",{get:function(){return this.transform.worldTransform},enumerable:!0,configurable:!0}),n}(i.Container);n.Container3D=s},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(1),s=t(5),u=t(26),l=t(27),f=t(12),c=new Float32Array(16),d=new Float32Array(4),_=function(e){function n(t){var r=e.call(this)||this;return r.renderer=t,r._id=0,r._fieldOfView=60,r._near=.1,r._far=1e3,r.renderer.on("prerender",(function(){r._aspect||r._id++,r.parent||r.transform.updateTransform()})),n.main||(n.main=r),r.transform.position.z=5,r.transform.rotationQuaternion.setEulerAngles(0,180,0),r}return o(n,e),Object.defineProperty(n.prototype,"id",{get:function(){return this.transform._worldID+this._id},enumerable:!0,configurable:!0}),n.prototype.screenToWorld=function(e,n,t,r){void 0===r&&(r=new f.ObservablePoint3D((function(){}),void 0));var o=this.far;this.far=t;var i=s.Mat4.invert(this.viewProjection,c);if(null!==i){var a=u.Vec4.set(e/this.renderer.width*2-1,-1*(n/this.renderer.height*2-1),1,1,d);this.far=o;var l=u.Vec4.transformMat4(a,i,d);l[3]=1/l[3];for(var _=0;_<3;_++)l[_]*=l[3];return r.set(l[0],l[1],l[2])}},n.prototype.worldToScreen=function(e,n,t,r){void 0===r&&(r=new i.Point);var o=u.Vec4.set(e,n,t,1,d),a=u.Vec4.transformMat4(u.Vec4.transformMat4(o,this.view,d),this.projection,d);if(0!==a[3])for(var s=0;s<3;s++)a[s]/=a[3];var l=this.renderer,f=l.width,c=l.height;return r.set((a[0]+1)/2*f,c-(a[1]+1)/2*c)},Object.defineProperty(n.prototype,"aspect",{get:function(){return this._aspect},set:function(e){this._aspect!==e&&(this._aspect=e,this._id++)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"fieldOfView",{get:function(){return this._fieldOfView},set:function(e){this._fieldOfView!==e&&(this._fieldOfView=e,this._id++)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"near",{get:function(){return this._near},set:function(e){this._near!==e&&(this._near=e,this._id++)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"far",{get:function(){return this._far},set:function(e){this._far!==e&&(this._far=e,this._id++)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"projection",{get:function(){var e=this;return this._projection||(this._projection=new l.MatrixComponent(this,16,(function(n){s.Mat4.perspective(e._fieldOfView*i.DEG_TO_RAD,e._aspect||e.renderer.width/e.renderer.height,e._near,e._far,n)}))),this._projection.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"view",{get:function(){var e=this;return this._view||(this._view=new l.MatrixComponent(this,16,(function(n){s.Mat4.lookAt(e.worldTransform.position,e.worldTransform.target,e.worldTransform.up,n)}))),this._view.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"viewProjection",{get:function(){var e=this;return this._viewProjection||(this._viewProjection=new l.MatrixComponent(this,16,(function(n){s.Mat4.multiply(e.projection,e.view,n)}))),this._viewProjection.array},enumerable:!0,configurable:!0}),n}(a.Container3D);n.Camera=_,i.Renderer.registerPlugin("camera",_)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.state=Object.assign(new i.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0}),n.drawMode=i.DRAW_MODES.TRIANGLES,n}return o(n,e),Object.defineProperty(n.prototype,"name",{get:function(){return"mesh-shader"},enumerable:!0,configurable:!0}),n.prototype.createShaderGeometry=function(e){var n=new i.Geometry;return e.indices&&(1===e.indices.buffer.BYTES_PER_ELEMENT?n.addIndex(new i.Buffer(new Uint16Array(e.indices.buffer))):n.addIndex(new i.Buffer(e.indices.buffer))),e.positions&&n.addAttribute("a_Position",new i.Buffer(e.positions.buffer),3,!1,e.positions.componentType,e.positions.stride),e.uvs&&e.uvs[0]&&n.addAttribute("a_UV1",new i.Buffer(e.uvs[0].buffer),2,!1,e.uvs[0].componentType,e.uvs[0].stride),e.normals&&n.addAttribute("a_Normal",new i.Buffer(e.normals.buffer),3,!1,e.normals.componentType,e.normals.stride),e.tangents&&n.addAttribute("a_Tangent",new i.Buffer(e.tangents.buffer),4,!1,e.tangents.componentType,e.tangents.stride),n},n.prototype.render=function(e,n,t,r){e.geometry.hasShaderGeometry(this)||e.geometry.addShaderGeometry(this);var o=e.geometry.getShaderGeometry(this);n.shader.bind(this,!1),n.state.set(t||this.state),n.geometry.bind(o,this),n.geometry.draw(r||this.drawMode)},n}(i.Shader);n.MeshShader=a},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.set=function(e,n,t,r,o){return o[0]=e,o[1]=n,o[2]=t,o[3]=r,o},e.normalize=function(e,n){var t=e[0],r=e[1],o=e[2],i=e[3],a=t*t+r*r+o*o+i*i;return a>0&&(a=1/Math.sqrt(a)),n[0]=t*a,n[1]=r*a,n[2]=o*a,n[3]=i*a,n},e.slerp=function(e,n,t,r){var o,i,a,s,u=e[0],l=e[1],f=e[2],c=e[3],d=n[0],_=n[1],p=n[2],h=n[3],m=u*d+l*_+f*p+c*h;return m<0&&(m=-m,d=-d,_=-_,p=-p,h=-h),1-m>1e-6?(o=Math.acos(m),i=Math.sin(o),a=Math.sin((1-t)*o)/i,s=Math.sin(t*o)/i):(a=1-t,s=t),r[0]=a*u+s*d,r[1]=a*l+s*_,r[2]=a*f+s*p,r[3]=a*c+s*h,r},e.fromEuler=function(e,n,t,r){var o=.5*Math.PI/180;e*=o,n*=o,t*=o;var i=Math.sin(e),a=Math.cos(e),s=Math.sin(n),u=Math.cos(n),l=Math.sin(t),f=Math.cos(t);return r[0]=i*u*f-a*s*l,r[1]=a*s*f+i*u*l,r[2]=a*u*l-i*s*f,r[3]=a*u*f+i*s*l,r},e.conjugate=function(e,n){return n[0]=-e[0],n[1]=-e[1],n[2]=-e[2],n[3]=e[3],n}}(n.Quat||(n.Quat={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){function n(e,n){var t=e[0],r=e[1],o=e[2],i=e[4],a=e[5],s=e[6],u=e[8],l=e[9],f=e[10];return n[0]=Math.hypot(t,r,o),n[1]=Math.hypot(i,a,s),n[2]=Math.hypot(u,l,f),n}function t(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}e.getTranslation=function(e,n){return n[0]=e[12],n[1]=e[13],n[2]=e[14],n},e.getScaling=n,e.getRotation=function(e,t){var r=n(e,new Float32Array(3)),o=1/r[0],i=1/r[1],a=1/r[2],s=e[0]*o,u=e[1]*i,l=e[2]*a,f=e[4]*o,c=e[5]*i,d=e[6]*a,_=e[8]*o,p=e[9]*i,h=e[10]*a,m=s+c+h,g=0;return m>0?(g=2*Math.sqrt(m+1),t[3]=.25*g,t[0]=(d-p)/g,t[1]=(_-l)/g,t[2]=(u-f)/g):s>c&&s>h?(g=2*Math.sqrt(1+s-c-h),t[3]=(d-p)/g,t[0]=.25*g,t[1]=(u+f)/g,t[2]=(_+l)/g):c>h?(g=2*Math.sqrt(1+c-s-h),t[3]=(_-l)/g,t[0]=(u+f)/g,t[1]=.25*g,t[2]=(d+p)/g):(g=2*Math.sqrt(1+h-s-c),t[3]=(u-f)/g,t[0]=(_+l)/g,t[1]=(d+p)/g,t[2]=.25*g),t},e.copy=function(e,n){return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15],n},e.fromRotationTranslationScale=function(e,n,t,r){var o=e[0],i=e[1],a=e[2],s=e[3],u=o+o,l=i+i,f=a+a,c=o*u,d=o*l,_=o*f,p=i*l,h=i*f,m=a*f,g=s*u,v=s*l,S=s*f,y=t[0],T=t[1],b=t[2];return r[0]=(1-(p+m))*y,r[1]=(d+S)*y,r[2]=(_-v)*y,r[3]=0,r[4]=(d-S)*T,r[5]=(1-(c+m))*T,r[6]=(h+g)*T,r[7]=0,r[8]=(_+v)*b,r[9]=(h-g)*b,r[10]=(1-(c+p))*b,r[11]=0,r[12]=n[0],r[13]=n[1],r[14]=n[2],r[15]=1,r},e.multiply=function(e,n,t){var r=e[0],o=e[1],i=e[2],a=e[3],s=e[4],u=e[5],l=e[6],f=e[7],c=e[8],d=e[9],_=e[10],p=e[11],h=e[12],m=e[13],g=e[14],v=e[15],S=n[0],y=n[1],T=n[2],b=n[3];return t[0]=S*r+y*s+T*c+b*h,t[1]=S*o+y*u+T*d+b*m,t[2]=S*i+y*l+T*_+b*g,t[3]=S*a+y*f+T*p+b*v,S=n[4],y=n[5],T=n[6],b=n[7],t[4]=S*r+y*s+T*c+b*h,t[5]=S*o+y*u+T*d+b*m,t[6]=S*i+y*l+T*_+b*g,t[7]=S*a+y*f+T*p+b*v,S=n[8],y=n[9],T=n[10],b=n[11],t[8]=S*r+y*s+T*c+b*h,t[9]=S*o+y*u+T*d+b*m,t[10]=S*i+y*l+T*_+b*g,t[11]=S*a+y*f+T*p+b*v,S=n[12],y=n[13],T=n[14],b=n[15],t[12]=S*r+y*s+T*c+b*h,t[13]=S*o+y*u+T*d+b*m,t[14]=S*i+y*l+T*_+b*g,t[15]=S*a+y*f+T*p+b*v,t},e.lookAt=function(e,n,r,o){var i,a,s,u,l,f,c,d,_,p,h=e[0],m=e[1],g=e[2],v=r[0],S=r[1],y=r[2],T=n[0],b=n[1],A=n[2];return Math.abs(h-T)<1e-6&&Math.abs(m-b)<1e-6&&Math.abs(g-A)<1e-6?t(o):(c=h-T,d=m-b,_=g-A,i=S*(_*=p=1/Math.hypot(c,d,_))-y*(d*=p),a=y*(c*=p)-v*_,s=v*d-S*c,(p=Math.hypot(i,a,s))?(i*=p=1/p,a*=p,s*=p):(i=0,a=0,s=0),u=d*s-_*a,l=_*i-c*s,f=c*a-d*i,(p=Math.hypot(u,l,f))?(u*=p=1/p,l*=p,f*=p):(u=0,l=0,f=0),o[0]=i,o[1]=u,o[2]=c,o[3]=0,o[4]=a,o[5]=l,o[6]=d,o[7]=0,o[8]=s,o[9]=f,o[10]=_,o[11]=0,o[12]=-(i*h+a*m+s*g),o[13]=-(u*h+l*m+f*g),o[14]=-(c*h+d*m+_*g),o[15]=1,o)},e.identity=t,e.perspective=function(e,n,t,r,o){var i,a=1/Math.tan(e/2);return o[0]=a/n,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=a,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[11]=-1,o[12]=0,o[13]=0,o[15]=0,null!=r&&r!==1/0?(i=1/(t-r),o[10]=(r+t)*i,o[14]=2*r*t*i):(o[10]=-1,o[14]=-2*t),o},e.ortho=function(e,n,t,r,o,i,a){var s=1/(e-n),u=1/(t-r),l=1/(o-i);return a[0]=-2*s,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=-2*u,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=2*l,a[11]=0,a[12]=(e+n)*s,a[13]=(r+t)*u,a[14]=(i+o)*l,a[15]=1,a},e.invert=function(e,n){var t=e[0],r=e[1],o=e[2],i=e[3],a=e[4],s=e[5],u=e[6],l=e[7],f=e[8],c=e[9],d=e[10],_=e[11],p=e[12],h=e[13],m=e[14],g=e[15],v=t*s-r*a,S=t*u-o*a,y=t*l-i*a,T=r*u-o*s,b=r*l-i*s,A=o*l-i*u,M=f*h-c*p,E=f*m-d*p,x=f*g-_*p,O=c*m-d*h,w=c*g-_*h,P=d*g-_*m,R=v*P-S*w+y*O+T*x-b*E+A*M;return R?(R=1/R,n[0]=(s*P-u*w+l*O)*R,n[1]=(o*w-r*P-i*O)*R,n[2]=(h*A-m*b+g*T)*R,n[3]=(d*b-c*A-_*T)*R,n[4]=(u*x-a*P-l*E)*R,n[5]=(t*P-o*x+i*E)*R,n[6]=(m*y-p*A-g*S)*R,n[7]=(f*A-d*y+_*S)*R,n[8]=(a*w-s*x+l*M)*R,n[9]=(r*x-t*w-i*M)*R,n[10]=(p*b-h*y+g*v)*R,n[11]=(c*y-f*b-_*v)*R,n[12]=(s*E-a*O-u*M)*R,n[13]=(t*O-r*E+o*M)*R,n[14]=(h*S-p*T-m*v)*R,n[15]=(f*T-c*S+d*v)*R,n):null},e.transpose=function(e,n){if(n===e){var t=e[1],r=e[2],o=e[3],i=e[6],a=e[7],s=e[11];n[1]=e[4],n[2]=e[8],n[3]=e[12],n[4]=t,n[6]=e[9],n[7]=e[13],n[8]=r,n[9]=i,n[11]=e[14],n[12]=o,n[13]=a,n[14]=s}else n[0]=e[0],n[1]=e[4],n[2]=e[8],n[3]=e[12],n[4]=e[1],n[5]=e[5],n[6]=e[9],n[7]=e[13],n[8]=e[2],n[9]=e[6],n[10]=e[10],n[11]=e[14],n[12]=e[3],n[13]=e[7],n[14]=e[11],n[15]=e[15];return n},e.fromScaling=function(e,n){return n[0]=e[0],n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=e[1],n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=e[2],n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},e.fromTranslation=function(e,n){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n}}(n.Mat4||(n.Mat4={}))},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(45),a=t(46),s=t(13),u=t(1),l=t(64),f=function(e){function n(n,t){var r=e.call(this)||this;if(r.geometry=n,r.material=t,r.pluginName="pipeline",r.renderPasses=["material"],!n)throw new Error("PIXI3D: Geometry is required when creating a mesh.");return r}return o(n,e),n.prototype.destroy=function(){this.geometry.destroy(),this.material&&this.material.destroy(),e.prototype.destroy.call(this)},n.prototype._render=function(e){e.batch.setObjectRenderer(e.plugins[this.pluginName]),e.plugins[this.pluginName].render(this)},n.createQuad=function(e){return void 0===e&&(e=new s.StandardMaterial),new n(l.QuadGeometry.create(),e)},n.createCube=function(e){return void 0===e&&(e=new s.StandardMaterial),new n(a.CubeGeometry.create(),e)},n.createPlane=function(e){return void 0===e&&(e=new s.StandardMaterial),new n(i.PlaneGeometry.create(),e)},n}(u.Container3D);n.Mesh3D=f},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(){this._shaderGeometry={}}return e.prototype.getShaderGeometry=function(e){return this._shaderGeometry[e.name]},e.prototype.addShaderGeometry=function(e){this._shaderGeometry[e.name]=e.createShaderGeometry(this)},e.prototype.hasShaderGeometry=function(e){return!!this._shaderGeometry[e.name]},e.prototype.destroy=function(){for(var e in this._shaderGeometry)this._shaderGeometry[e].destroy();this._shaderGeometry={}},e}();n.MeshGeometry3D=r},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.spot="spot",e.directional="directional",e.point="point"}(n.LightType||(n.LightType={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){var n,t,r,o,i;e.getMaxVertexUniformVectors=function(e){if(void 0!==n)return n;var t=e.gl;return n=t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)},e.isFloatTextureSupported=function(e){if(2===e.context.webGLVersion)return!0;if(void 0!==t)return t;var n=e.gl;if(n.getExtension("OES_texture_float"))return!0;var r=n.createTexture();return n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,8,8,0,n.RGBA,n.FLOAT,null),t=n.getError()===n.NO_ERROR,n.deleteTexture(r),t},e.isHalfFloatFramebufferSupported=function(e){if(2===e.context.webGLVersion)return!0;if(void 0!==r)return r;var n=e.gl,t=n.getExtension("OES_texture_half_float");if(!t)return!1;var o=n.createTexture();n.bindTexture(n.TEXTURE_2D,o),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,8,8,0,n.RGBA,t.HALF_FLOAT_OES,null);var i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i);var a=n.COLOR_ATTACHMENT0;return n.framebufferTexture2D(n.FRAMEBUFFER,a,n.TEXTURE_2D,o,0),r=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE},e.isFloatFramebufferSupported=function(e){if(2===e.context.webGLVersion)return!0;if(void 0!==o)return o;var n=e.gl;if(!n.getExtension("OES_texture_float"))return!1;var t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,8,8,0,n.RGBA,n.FLOAT,null);var r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r);var i=n.COLOR_ATTACHMENT0;return n.framebufferTexture2D(n.FRAMEBUFFER,i,n.TEXTURE_2D,t,0),o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE},e.supportsFloatLinear=function(e){if(void 0!==i)return i;var n=e.gl;return i=null!==n.getExtension("OES_texture_float_linear")},e.isShaderTextureLodSupported=function(e){return 2===e.context.webGLVersion||null!==e.gl.getExtension("EXT_shader_texture_lod")}}(n.Platform||(n.Platform={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,n){this._position=0,this._frame=0,this._input=e,this._interpolation=n}return Object.defineProperty(e.prototype,"position",{get:function(){return this._position},set:function(e){this.setPosition(e)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"duration",{get:function(){return this._input[this._input.length-1]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"frame",{get:function(){return this._frame},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"length",{get:function(){return this._input.length},enumerable:!0,configurable:!0}),e.prototype.setPosition=function(e){this._position=e,this._frame=this.calculateFrame(this._position),this.updateTarget(this._interpolation.interpolate(this._frame,this.calculateFramePosition(this._frame,this._position)))},e.prototype.update=function(e){this.position+=e},e.prototype.calculateFramePosition=function(e,n){return e===this._input.length-1?1:(n-this._input[e])/(this._input[e+1]-this._input[e])},e.prototype.calculateFrame=function(e){if(e<this._input[0])return 0;for(var n=0;n<this._input.length-1;n++)if(e>=this._input[n]&&e<this._input[n+1])return n;return this._input.length-1},e.from=function(e,n,t,r,f){if("translation"===r)return new l.glTFTranslation(f.transform,e,o.glTFInterpolation.from(t,e,n,3));if("scale"===r)return new a.glTFScale(f.transform,e,o.glTFInterpolation.from(t,e,n,3));if("rotation"===r)return"LINEAR"===t?new u.glTFRotation(f.transform,e,new i.glTFSphericalLinear(n)):new u.glTFRotation(f.transform,e,o.glTFInterpolation.from(t,e,n,4));if("weights"===r){var c=f.children[0].morphWeights;if(!c)return;return new s.glTFWeights(c,e,o.glTFInterpolation.from(t,e,n,c.length))}throw new Error('PIXI3D: Unknown channel path "'+r+'"')},e}();n.glTFChannel=r;var o=t(11),i=t(69),a=t(70),s=t(71),u=t(72),l=t(73)},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(){}return e.from=function(e,n,t,r){switch(e){case"LINEAR":return new o.glTFLinear(t,r);case"CUBICSPLINE":return new i.glTFCubicSpline(n,t,r);case"STEP":return new a.glTFStep(t,r)}throw new Error('PIXI3D: Unknown interpolation type "'+e+'"')},e}();n.glTFInterpolation=r;var o=t(66),i=t(67),a=t(68)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r,o,i){void 0===r&&(r=0),void 0===o&&(o=0),void 0===i&&(i=0);var a=e.call(this,n,t,r,o)||this;return a.cb=n,a.scope=t,a._z=i,a}return o(n,e),Object.defineProperty(n.prototype,"z",{get:function(){return this._z},set:function(e){this._z!==e&&(this._z=e,this.cb.call(this.scope))},enumerable:!0,configurable:!0}),n.prototype.clone=function(e,t){return new n(e||this.cb,t||this.scope,this.x,this.y,this._z)},n.prototype.copyFrom=function(t){return e.prototype.copyFrom.call(this,t),t instanceof n&&(this.z=t.z),this},n.prototype.copyTo=function(e){return e instanceof n&&e.set(this.x,this.y,this.z),e},n.prototype.equals=function(t){return t instanceof n&&(e.prototype.equals.call(this,t)&&t.z===this.z)},n.prototype.set=function(n,t,r){e.prototype.set.call(this,n,t);var o=r||(0!==r?n:0);return this._z!==o&&(this._z=o,this.cb.call(this.scope)),this},n.prototype.setFrom=function(e){return this.set(e[0],e[1],e[2]),this},n}(t(0).ObservablePoint);n.ObservablePoint3D=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),i=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),s=t(8),u=t(47),l=t(49),f=t(17),c=t(2),d=t(34),_=t(35),p=t(15),h=t(63),m={},g=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n._unlit=!1,n._alphaMode=p.StandardMaterialAlphaMode.opaque,n._transparent=!1,n._skinUniforms=new h.StandardMaterialSkinUniforms,n.roughness=1,n.metallic=1,n.baseColor=[1,1,1,1],n.alphaCutoff=.5,n.emissive=[0,0,0],n.exposure=3,n}return o(n,e),Object.defineProperty(n.prototype,"baseColorTexture",{get:function(){return this._baseColorTexture},set:function(e){e!==this._baseColorTexture&&(this.invalidateShader(),this._baseColorTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"metallicRoughnessTexture",{get:function(){return this._metallicRoughnessTexture},set:function(e){e!==this._metallicRoughnessTexture&&(this.invalidateShader(),this._metallicRoughnessTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"normalTexture",{get:function(){return this._normalTexture},set:function(e){e!==this._normalTexture&&(this.invalidateShader(),this._normalTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"occlusionTexture",{get:function(){return this._occlusionTexture},set:function(e){e!==this._occlusionTexture&&(this.invalidateShader(),this._occlusionTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"emissiveTexture",{get:function(){return this._emissiveTexture},set:function(e){e!==this._emissiveTexture&&(this.invalidateShader(),this._emissiveTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"alphaMode",{get:function(){return this._alphaMode},set:function(e){this._alphaMode!==e&&(this._alphaMode=e,this._alphaMode===p.StandardMaterialAlphaMode.opaque?this._transparent=!1:this._transparent=!0,this.invalidateShader())},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"shadowCastingLight",{get:function(){return this._shadowCastingLight},set:function(e){e!==this._shadowCastingLight&&(this.invalidateShader(),this._shadowCastingLight=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"debugMode",{get:function(){return this._debugMode},set:function(e){this._debugMode!==e&&(this.invalidateShader(),this._debugMode=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"transparent",{get:function(){return this._transparent},set:function(e){e!==this._transparent&&(this.alphaMode=e?p.StandardMaterialAlphaMode.blend:p.StandardMaterialAlphaMode.opaque),this._transparent=e},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"lightingEnvironment",{get:function(){return this._lightingEnvironment},set:function(e){e!==this._lightingEnvironment&&(this.invalidateShader(),this._lightingEnvironment=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"unlit",{get:function(){return this._unlit},set:function(e){this._unlit!==e&&(this._unlit=e,this.invalidateShader())},enumerable:!0,configurable:!0}),n.prototype.destroy=function(){var e,n,t,r,o;null===(e=this._baseColorTexture)||void 0===e||e.destroy(),null===(n=this._normalTexture)||void 0===n||n.destroy(),null===(t=this._emissiveTexture)||void 0===t||t.destroy(),null===(r=this._occlusionTexture)||void 0===r||r.destroy(),null===(o=this._metallicRoughnessTexture)||void 0===o||o.destroy(),this._skinUniforms.destroy()},n.prototype.invalidateShader=function(){this._shader=void 0},n.factory=function(e){return void 0===e&&(e={}),{create:function(t){return Object.assign(n.create(t),e)}}},n.create=function(e){var t,r,o,i,a,s=new n;if(e instanceof d.glTFMaterial){switch(s.baseColor=e.baseColor,s.baseColorTexture=null===(t=e.baseColorTexture)||void 0===t?void 0:t.clone(),s.metallic=e.metallic,s.roughness=e.roughness,s.metallicRoughnessTexture=null===(r=e.metallicRoughnessTexture)||void 0===r?void 0:r.clone(),e.alphaMode){case"BLEND":s.alphaMode=p.StandardMaterialAlphaMode.blend;break;case"MASK":s.alphaMode=p.StandardMaterialAlphaMode.mask}s.unlit=e.unlit,s.emissiveTexture=null===(o=e.emissiveTexture)||void 0===o?void 0:o.clone(),s.emissive=e.emissive,s.normalTexture=null===(i=e.normalTexture)||void 0===i?void 0:i.clone(),s.occlusionTexture=null===(a=e.occlusionTexture)||void 0===a?void 0:a.clone(),s.doubleSided=e.doubleSided,s.alphaCutoff=e.alphaCutoff}return s},n.prototype.render=function(n,t,r){var o=this.lightingEnvironment||_.LightingEnvironment.main;o.lights.length!==this._lightsCount&&(this.invalidateShader(),this._lightsCount=o.lights.length),e.prototype.render.call(this,n,t,r)},n.prototype.createShader=function(e,n){var t,r;if(1===n.context.webGLVersion){try{for(var o=i(["EXT_shader_texture_lod","OES_standard_derivatives"]),a=o.next();!a.done;a=o.next()){var s=a.value;n.gl.getExtension(s)||console.warn('PIXI3D: Extension "'+s+'" is not supported by current platform, the material may not be displayed correctly.')}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}}var f=this.lightingEnvironment||_.LightingEnvironment.main,c=u.StandardMaterialFeatureSet.build(n,e,e.geometry,this,f);if(c){e.skin&&u.StandardMaterialFeatureSet.hasSkinningTextureFeature(c)&&this._skinUniforms.enableJointMatrixTextures(e.skin.joints.length);var d=c.join(",");return m[d]||(m[d]=l.StandardShader.build(n,c)),m[d]}},n.prototype.updateUniforms=function(e,n){var t,r,o,i,u,l=this.camera||c.Camera.main;e.skin&&this._skinUniforms.update(e,n),n.uniforms.u_Camera=l.worldTransform.position,n.uniforms.u_ViewProjectionMatrix=l.viewProjection,n.uniforms.u_Exposure=this.exposure,n.uniforms.u_MetallicFactor=this.metallic,n.uniforms.u_RoughnessFactor=this.roughness,n.uniforms.u_BaseColorFactor=this.baseColor,n.uniforms.u_EmissiveFactor=this.emissive,n.uniforms.u_ModelMatrix=e.worldTransform.toArray(),n.uniforms.u_NormalMatrix=e.transform.normalTransform.toArray(),this._shadowCastingLight&&(n.uniforms.u_ShadowSampler=this._shadowCastingLight.shadowTexture,n.uniforms.u_LightViewProjectionMatrix=this._shadowCastingLight.lightViewProjection),this._alphaMode===p.StandardMaterialAlphaMode.mask&&(n.uniforms.u_AlphaCutoff=this.alphaCutoff),e.morphWeights&&(n.uniforms.u_morphWeights=e.morphWeights),(null===(t=this.baseColorTexture)||void 0===t?void 0:t.valid)&&(n.uniforms.u_BaseColorSampler=this.baseColorTexture,n.uniforms.u_BaseColorUVSet=0);for(var f=this.lightingEnvironment||_.LightingEnvironment.main,d=0;d<f.lights.length;d++){var h=f.lights[d],m=0;switch(h.type){case s.LightType.point:m=1;break;case s.LightType.directional:m=0;break;case s.LightType.spot:m=2}n.uniforms["u_Lights["+d+"].type"]=m,n.uniforms["u_Lights["+d+"].position"]=h.worldTransform.position,n.uniforms["u_Lights["+d+"].direction"]=h.worldTransform.forward,n.uniforms["u_Lights["+d+"].range"]=h.range,n.uniforms["u_Lights["+d+"].color"]=h.color,n.uniforms["u_Lights["+d+"].intensity"]=h.intensity,n.uniforms["u_Lights["+d+"].innerConeCos"]=Math.cos(h.innerConeAngle*a.DEG_TO_RAD),n.uniforms["u_Lights["+d+"].outerConeCos"]=Math.cos(h.outerConeAngle*a.DEG_TO_RAD)}var g=f.imageBasedLighting;(null==g?void 0:g.valid)&&(n.uniforms.u_DiffuseEnvSampler=g.diffuse,n.uniforms.u_SpecularEnvSampler=g.specular,n.uniforms.u_brdfLUT=g.brdf,n.uniforms.u_MipCount=g.specular.levels-1),(null===(r=this.emissiveTexture)||void 0===r?void 0:r.valid)&&(n.uniforms.u_EmissiveSampler=this.emissiveTexture,n.uniforms.u_EmissiveUVSet=0,n.uniforms.u_EmissiveFactor=[1,1,1]),(null===(o=this.normalTexture)||void 0===o?void 0:o.valid)&&(n.uniforms.u_NormalSampler=this.normalTexture,n.uniforms.u_NormalScale=1,n.uniforms.u_NormalUVSet=0),(null===(i=this.metallicRoughnessTexture)||void 0===i?void 0:i.valid)&&(n.uniforms.u_MetallicRoughnessSampler=this.metallicRoughnessTexture,n.uniforms.u_MetallicRoughnessUVSet=0),(null===(u=this.occlusionTexture)||void 0===u?void 0:u.valid)&&(n.uniforms.u_OcclusionSampler=this.occlusionTexture,n.uniforms.u_OcclusionStrength=1,n.uniforms.u_OcclusionUVSet=0)},n}(f.Material);n.StandardMaterial=g},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.set=function(e,n,t,r){return r[0]=e,r[1]=n,r[2]=t,r},e.add=function(e,n,t){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t},e.transformQuat=function(e,n,t){var r=n[0],o=n[1],i=n[2],a=n[3],s=e[0],u=e[1],l=e[2],f=o*l-i*u,c=i*s-r*l,d=r*u-o*s,_=o*d-i*c,p=i*f-r*d,h=r*c-o*f,m=2*a;return f*=m,c*=m,d*=m,_*=2,p*=2,h*=2,t[0]=s+f+_,t[1]=u+c+p,t[2]=l+d+h,t},e.subtract=function(e,n,t){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t},e.scale=function(e,n,t){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t},e.normalize=function(e,n){var t=e[0],r=e[1],o=e[2],i=t*t+r*r+o*o;return i>0&&(i=1/Math.sqrt(i)),n[0]=e[0]*i,n[1]=e[1]*i,n[2]=e[2]*i,n}}(n.Vec3||(n.Vec3={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.opaque="opaque",e.mask="mask",e.blend="blend"}(n.StandardMaterialAlphaMode||(n.StandardMaterialAlphaMode={}))},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(9),s=function(e){function n(n){var t=this,r=new Float32Array(16*n),o=new i.resources.BufferResource(r,{width:4,height:n});return(t=e.call(this,new i.BaseTexture(o,{mipmap:i.MIPMAP_MODES.OFF,wrapMode:i.WRAP_MODES.CLAMP,scaleMode:i.SCALE_MODES.NEAREST,format:i.FORMATS.RGBA,type:i.TYPES.FLOAT,alphaMode:i.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA}))||this)._buffer=r,t}return o(n,e),n.isSupported=function(e){return a.Platform.isFloatTextureSupported(e)},n.prototype.updateBuffer=function(e){for(var n=0;n<e.length;n++)this._buffer[n]=(e[n]+1)/2;this.baseTexture.resource.update()},n}(i.Texture);n.StandardMaterialMatrixTexture=s},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=function(){function e(){this.drawMode=r.DRAW_MODES.TRIANGLES,this.transparent=!1,this.doubleSided=!1}return e.prototype.destroy=function(){},e.prototype.render=function(e,n,t){(this._shader||(this._shader=this.createShader(e,n),this._shader))&&(this.updateUniforms&&this.updateUniforms(e,this._shader),this._shader.render(e,n,t,this.drawMode))},e}();n.Material=o},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(65),a=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.animations=[],n.meshes=[],n}return o(n,e),n.from=function(e,n){return i.glTFParser.createModel(e,n)},n}(t(1).Container3D);n.Model=a},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(3),s=t(29),u=function(e){function n(n){void 0===n&&(n=[]);var r=t(83).default,o=t(84).default;return e.call(this,i.Program.from(s.StandardShaderSource.build(r,n),s.StandardShaderSource.build(o,n)))||this}return o(n,e),n.prototype.createShaderGeometry=function(e){var n=new i.Geometry;return e.indices&&(1===e.indices.buffer.BYTES_PER_ELEMENT?n.addIndex(new i.Buffer(new Uint16Array(e.indices.buffer))):n.addIndex(new i.Buffer(e.indices.buffer))),e.positions&&n.addAttribute("a_Position",new i.Buffer(e.positions.buffer),3,!1,e.positions.componentType,e.positions.stride),n},Object.defineProperty(n.prototype,"name",{get:function(){return"shadow-shader"},enumerable:!0,configurable:!0}),n.prototype.updateUniforms=function(e,n){this.uniforms.u_ModelMatrix=e.worldTransform.toArray(),this.uniforms.u_ViewProjectionMatrix=n.lightViewProjection},n}(a.MeshShader);n.ShadowShader=u},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(88),s=t(89),u=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return o(n,e),Object.defineProperty(n,"faces",{get:function(){return["posx","negx","posy","negy","posz","negz"]},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"levels",{get:function(){return this.resource.levels},enumerable:!0,configurable:!0}),n.fromSource=function(e){var t=n.faces.map((function(n,t){var r=e.map((function(e){return i.Texture.from(e.replace("{{face}}",n))}));return new a.MipmapResource(r,i.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+t)}));return new n(new s.CubeMipmapResource(t,e.length))},n}(i.BaseTexture);n.CubeMipmapTexture=u},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.low="low",e.medium="medium",e.high="high"}(n.ShadowQuality||(n.ShadowQuality={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=function(){function e(e){this._buffers=[],this._images=[],this._descriptor=e}return Object.defineProperty(e.prototype,"images",{get:function(){return this._images},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"descriptor",{get:function(){return this._descriptor},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"buffers",{get:function(){return this._buffers},enumerable:!0,configurable:!0}),e.load=function(n,t){for(var o=new e(n),i=function(r){var i=n.buffers[r];if(e.isEmbeddedResource(i.uri))o._buffers[r]=e.getEmbeddedBuffer(i.uri);else{if(!t)throw new Error("PIXI3D: A resource loader is required when buffer is not embedded.");t.load(i.uri,(function(e){o._buffers[r]=e.data}))}},a=0;a<n.buffers.length;a++)i(a);if(!n.images)return o;var s=function(i){var a=n.images[i];if(e.isEmbeddedResource(a.uri))o._images[i]=r.Texture.from(a.uri,{wrapMode:r.WRAP_MODES.REPEAT});else{if(!t)throw new Error("PIXI3D: A resource loader is required when image is not embedded.");t.load(a.uri,(function(e){e.texture.baseTexture.wrapMode=r.WRAP_MODES.REPEAT,o._images[i]=e.texture}))}};for(a=0;a<n.images.length;a++)s(a);return o},e.isEmbeddedResource=function(e){return e.startsWith("data:")},e.getEmbeddedBuffer=function(e){return Uint8Array.from(atob(e.split(",")[1]),(function(e){return e.charCodeAt(0)})).buffer},e}();n.glTFAsset=o},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(4),a=t(12),s=new Float32Array(4),u=function(e){function n(n,t,r,o,i,a){void 0===r&&(r=0),void 0===o&&(o=0),void 0===i&&(i=0),void 0===a&&(a=1);var s=e.call(this,n,t,r,o,i)||this;return s._w=a,s}return o(n,e),n.prototype.setEulerAngles=function(e,n,t){i.Quat.fromEuler(e,n,t,s),this.set(s[0],s[1],s[2],s[3])},Object.defineProperty(n.prototype,"w",{get:function(){return this._w},set:function(e){this._w!==e&&(this._w=e,this.cb.call(this.scope))},enumerable:!0,configurable:!0}),n.prototype.clone=function(e,t){return new n(e||this.cb,t||this.scope,this.x,this.y,this.z,this.w)},n.prototype.copyFrom=function(t){return e.prototype.copyFrom.call(this,t),t instanceof n&&(this.w=t.w),this},n.prototype.copyTo=function(e){return e instanceof n&&e.set(this.x,this.y,this.z,this.w),e},n.prototype.equals=function(t){return t instanceof n&&(e.prototype.equals.call(this,t)&&t.w===this.w)},n.prototype.set=function(n,t,r,o){e.prototype.set.call(this,n,t,r);var i=o||(0!==o?n:0);return this._w!==i&&(this._w=i,this.cb.call(this.scope)),this},n.prototype.setFrom=function(e){return this.set(e[0],e[1],e[2],e[3]),this},n}(a.ObservablePoint3D);n.ObservableQuaternion=u},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(25),s=t(12),u=t(23),l=t(5),f=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.position=new s.ObservablePoint3D(n.onChange,n,0,0,0),n.scale=new s.ObservablePoint3D(n.onChange,n,1,1,1),n.rotationQuaternion=new u.ObservableQuaternion(n.onChange,n,0,0,0,1),n.worldTransform=new a.TransformMatrix,n.localTransform=new a.TransformMatrix,n.inverseWorldTransform=new a.TransformMatrix,n.normalTransform=new a.TransformMatrix,n}return o(n,e),n.prototype.updateLocalTransform=function(){this._localID!==this._currentLocalID&&(this.localTransform.setFromRotationPositionScale(this.rotationQuaternion,this.position,this.scale),this._parentID=-1,this._currentLocalID=this._localID)},n.prototype.setFromMatrix=function(e){this.localTransform.copyFrom(e),this.position.set(this.localTransform.position[0],this.localTransform.position[1],this.localTransform.position[2]),this.scale.set(this.localTransform.scaling[0],this.localTransform.scaling[1],this.localTransform.scaling[2]),this.rotationQuaternion.set(this.localTransform.rotation[0],this.localTransform.rotation[1],this.localTransform.rotation[2],this.localTransform.rotation[3])},n.prototype.updateTransform=function(e){this.updateLocalTransform(),e&&this._parentID===e._worldID||(e instanceof n?this.worldTransform.setFromMultiplyWorldLocal(e.worldTransform,this.localTransform):this.worldTransform.copyFrom(this.localTransform),l.Mat4.invert(this.worldTransform.toArray(),this.inverseWorldTransform.toArray()),l.Mat4.transpose(this.inverseWorldTransform.toArray(),this.normalTransform.toArray()),this._worldID++,e&&(this._parentID=e._worldID))},n}(i.Transform);n.Transform3D=f},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),i=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),s=t(5),u=t(14),l=t(26),f=t(27),c=t(4),d=function(e){function n(n){var t=e.call(this)||this;return t._id=0,t._array=n?new Float32Array(n):new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),t}return o(n,e),n.prototype.toArray=function(e,n){var t=n;return n||(t=this._array),t},Object.defineProperty(n.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"position",{get:function(){var e=this;return this._position||(this._position=new f.MatrixComponent(this,3,(function(n){s.Mat4.getTranslation(e._array,n)}))),this._position.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"scaling",{get:function(){var e=this;return this._scaling||(this._scaling=new f.MatrixComponent(this,3,(function(n){s.Mat4.getScaling(e._array,n)}))),this._scaling.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"rotation",{get:function(){var e=this;if(!this._rotation){var n=new Float32Array(16);this._rotation=new f.MatrixComponent(this,4,(function(t){var r,o;try{for(var a=i([0,1,2]),u=a.next();!u.done;u=a.next()){var l=u.value;n[l+0]=e._array[l+0]/e.scaling[0],n[l+4]=e._array[l+4]/e.scaling[1],n[l+8]=e._array[l+8]/e.scaling[2]}}catch(e){r={error:e}}finally{try{u&&!u.done&&(o=a.return)&&o.call(a)}finally{if(r)throw r.error}}c.Quat.normalize(s.Mat4.getRotation(n,t),t)}))}return this._rotation.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"up",{get:function(){var e=this;return this._up||(this._up=new f.MatrixComponent(this,3,(function(n){u.Vec3.normalize(u.Vec3.set(e._array[4],e._array[5],e._array[6],n),n)}))),this._up.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"forward",{get:function(){var e=this;return this._forward||(this._forward=new f.MatrixComponent(this,3,(function(n){u.Vec3.normalize(u.Vec3.set(e._array[8],e._array[9],e._array[10],n),n)}))),this._forward.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"target",{get:function(){var e=this;return this._target||(this._target=new f.MatrixComponent(this,3,(function(n){u.Vec3.add(e.position,e.forward,n)}))),this._target.array},enumerable:!0,configurable:!0}),n.prototype.copyFrom=function(e){return e instanceof n&&(s.Mat4.copy(e._array,this._array),this._id++),this},n.prototype.setFromRotationPositionScale=function(e,n,t){l.Vec4.set(e.x,e.y,e.z,e.w,this.rotation),u.Vec3.set(t.x,t.y,t.z,this.scaling),u.Vec3.set(n.x,n.y,n.z,this.position),s.Mat4.fromRotationTranslationScale(this.rotation,this.position,this.scaling,this._array),this._id++},n.prototype.setFromMultiplyWorldLocal=function(e,n){s.Mat4.multiply(e._array,n._array,this._array),this._id++},n}(a.Matrix);n.TransformMatrix=d},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.set=function(e,n,t,r,o){return o[0]=e,o[1]=n,o[2]=t,o[3]=r,o},e.transformMat4=function(e,n,t){var r=e[0],o=e[1],i=e[2],a=e[3];return t[0]=n[0]*r+n[4]*o+n[8]*i+n[12]*a,t[1]=n[1]*r+n[5]*o+n[9]*i+n[13]*a,t[2]=n[2]*r+n[6]*o+n[10]*i+n[14]*a,t[3]=n[3]*r+n[7]*o+n[11]*i+n[15]*a,t}}(n.Vec4||(n.Vec4={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,n,t){this._parent=e,this._update=t,this._array=new Float32Array(n)}return Object.defineProperty(e.prototype,"array",{get:function(){return this._id!==this._parent.id&&(this._update(this._array),this._id=this._parent.id),this._array},enumerable:!0,configurable:!0}),e}();n.MatrixComponent=r},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.alpha="alpha",e.emissive="emissive",e.f0="f0",e.metallic="metallic",e.normal="normal",e.occlusion="occlusion",e.roughness="roughness"}(n.StandardMaterialDebugMode||(n.StandardMaterialDebugMode={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.build=function(e,n){for(var r;null!==(r=/#include <(.+)>/gm.exec(e));)e=e.replace(r[0],t(50)("./"+r[1]).default);return e.replace(/#define FEATURES/,n.map((function(e){return"#define "+e})).join("\n"))}}(n.StandardShaderSource||(n.StandardShaderSource={}))},function(e,n,t){"use strict";t.r(n),n.default="//\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n#define FEATURES\n\n#ifdef USE_TEX_LOD\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n#ifdef USE_HDR\n#extension GL_OES_texture_float : enable\n#extension GL_OES_texture_float_linear : enable\n#endif\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\n#include <extensions.webgl1.glsl>\n#include <tonemapping.glsl>\n#include <textures.webgl1.glsl>\n#include <functions.webgl1.glsl>\n#include <shadow.webgl1.glsl>\n\n// KHR_lights_punctual extension.\n// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nstruct Light\n{\n    vec3 direction;\n    float range;\n\n    vec3 color;\n    float intensity;\n\n    vec3 position;\n    float innerConeCos;\n\n    float outerConeCos;\n    int type;\n\n    vec2 padding;\n};\n\nconst int LightType_Directional = 0;\nconst int LightType_Point = 1;\nconst int LightType_Spot = 2;\n\n#ifdef USE_PUNCTUAL\nuniform Light u_Lights[LIGHT_COUNT];\n#endif\n\n#if defined(MATERIAL_SPECULARGLOSSINESS) || defined(MATERIAL_METALLICROUGHNESS)\nuniform float u_MetallicFactor;\nuniform float u_RoughnessFactor;\nuniform vec4 u_BaseColorFactor;\n#endif\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\nuniform vec3 u_SpecularFactor;\nuniform vec4 u_DiffuseFactor;\nuniform float u_GlossinessFactor;\n#endif\n\n#ifdef ALPHAMODE_MASK\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec3 u_Camera;\n\nuniform int u_MipCount;\n\nstruct MaterialInfo\n{\n    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n    vec3 reflectance0;            // full reflectance color (normal incidence angle)\n\n    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n    vec3 diffuseColor;            // color contribution from diffuse lighting\n\n    vec3 reflectance90;           // reflectance color at grazing angle\n    vec3 specularColor;           // color contribution from specular lighting\n};\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)\n{\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n\n    float lod = clamp(materialInfo.perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    // retrieve a scale and bias to F0. See [1], Figure 3\n    vec2 brdf = texture2D(u_brdfLUT, brdfSamplePoint).rg;\n\n    vec4 diffuseSample = textureCube(u_DiffuseEnvSampler, n);\n\n#ifdef USE_TEX_LOD\n    vec4 specularSample = _textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod);\n#else\n    vec4 specularSample = textureCube(u_SpecularEnvSampler, reflection);\n#endif\n\n#ifdef USE_HDR\n    // Already linear.\n    vec3 diffuseLight = diffuseSample.rgb;\n    vec3 specularLight = specularSample.rgb;\n#else\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;\n#endif\n\n    vec3 diffuse = diffuseLight * materialInfo.diffuseColor;\n    vec3 specular = specularLight * (materialInfo.specularColor * brdf.x + brdf.y);\n\n    return diffuse + specular;\n}\n#endif\n\n// Lambert lighting\n// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\nvec3 diffuse(MaterialInfo materialInfo)\n{\n    return materialInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    return materialInfo.reflectance0 + (materialInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat visibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float NdotL = angularInfo.NdotL;\n    float NdotV = angularInfo.NdotV;\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n    float f = (angularInfo.NdotH * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nvec3 getPointShade(vec3 pointToLight, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    AngularInfo angularInfo = getAngularInfo(pointToLight, normal, view);\n\n    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)\n    {\n        // Calculate the shading terms for the microfacet specular shading model\n        vec3 F = specularReflection(materialInfo, angularInfo);\n        float Vis = visibilityOcclusion(materialInfo, angularInfo);\n        float D = microfacetDistribution(materialInfo, angularInfo);\n\n        // Calculation of analytical lighting contribution\n        vec3 diffuseContrib = (1.0 - F) * diffuse(materialInfo);\n        vec3 specContrib = F * Vis * D;\n\n        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n        return angularInfo.NdotL * (diffuseContrib + specContrib);\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(float range, float distance)\n{\n    if (range <= 0.0)\n    {\n        // negative range means unlimited\n        return 1.0;\n    }\n    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)\n{\n    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));\n    if (actualCos > outerConeCos)\n    {\n        if (actualCos < innerConeCos)\n        {\n            return smoothstep(outerConeCos, innerConeCos, actualCos);\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 applyDirectionalLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = -light.direction;\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return light.intensity * light.color * shade;\n}\n\nvec3 applyPointLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float attenuation = getRangeAttenuation(light.range, distance);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);\n    return attenuation * light.intensity * light.color * shade;\n}\n\nvec3 applySpotLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float rangeAttenuation = getRangeAttenuation(light.range, distance);\n    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return rangeAttenuation * spotAttenuation * light.intensity * light.color * shade;\n}\n\nvoid main()\n{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = 0.0;\n    float metallic = 0.0;\n    vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 specularColor= vec3(0.0);\n    vec3 f0 = vec3(0.04);\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    vec4 sgSample = SRGBtoLINEAR(texture2D(u_SpecularGlossinessSampler, getSpecularGlossinessUV()));\n    perceptualRoughness = (1.0 - sgSample.a * u_GlossinessFactor); // glossiness to roughness\n    f0 = sgSample.rgb * u_SpecularFactor; // specular\n#else\n    f0 = u_SpecularFactor;\n    perceptualRoughness = 1.0 - u_GlossinessFactor;\n#endif // ! HAS_SPECULAR_GLOSSINESS_MAP\n\n#ifdef HAS_DIFFUSE_MAP\n    baseColor = SRGBtoLINEAR(texture2D(u_DiffuseSampler, getDiffuseUV())) * u_DiffuseFactor;\n#else\n    baseColor = u_DiffuseFactor;\n#endif // !HAS_DIFFUSE_MAP\n\n    baseColor *= getVertexColor();\n\n    // f0 = specular\n    specularColor = f0;\n    float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);\n    diffuseColor = baseColor.rgb * oneMinusSpecularStrength;\n\n#ifdef DEBUG_METALLIC\n    // do conversion between metallic M-R and S-G metallic\n    metallic = solveMetallic(baseColor.rgb, specularColor, oneMinusSpecularStrength);\n#endif // ! DEBUG_METALLIC\n\n#endif // ! MATERIAL_SPECULARGLOSSINESS\n\n#ifdef MATERIAL_METALLICROUGHNESS\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, getMetallicRoughnessUV());\n    perceptualRoughness = mrSample.g * u_RoughnessFactor;\n    metallic = mrSample.b * u_MetallicFactor;\n#else\n    metallic = u_MetallicFactor;\n    perceptualRoughness = u_RoughnessFactor;\n#endif\n\n    // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASE_COLOR_MAP\n    baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, getBaseColorUV())) * u_BaseColorFactor;\n#else\n    baseColor = u_BaseColorFactor;\n#endif\n\n    baseColor *= getVertexColor();\n\n    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n\n    specularColor = mix(f0, baseColor.rgb, metallic);\n\n#endif // ! MATERIAL_METALLICROUGHNESS\n\n#ifdef ALPHAMODE_MASK\n    if(baseColor.a < u_AlphaCutoff)\n    {\n        discard;\n    }\n    baseColor.a = 1.0;\n#endif\n\n#ifdef ALPHAMODE_OPAQUE\n    baseColor.a = 1.0;\n#endif\n\n#ifdef MATERIAL_UNLIT\n    gl_FragColor = vec4(LINEARtoSRGB(baseColor.rgb) * baseColor.a, baseColor.a);\n    return;\n#endif\n\n    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));\n\n    MaterialInfo materialInfo = MaterialInfo(\n        perceptualRoughness,\n        specularEnvironmentR0,\n        alphaRoughness,\n        diffuseColor,\n        specularEnvironmentR90,\n        specularColor\n    );\n\n    // LIGHTING\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 normal = getNormal();\n    vec3 view = normalize(u_Camera - v_Position);\n\n    float shadow = 1.0;\n    #ifdef USE_SHADOW_MAPPING\n        shadow = getShadowContribution();\n    #endif\n\n#ifdef USE_PUNCTUAL\n    for (int i = 0; i < LIGHT_COUNT; ++i)\n    {\n        Light light = u_Lights[i];\n        if (light.type == LightType_Directional)\n        {\n            color += applyDirectionalLight(light, materialInfo, normal, view, shadow);\n        }\n        else if (light.type == LightType_Point)\n        {\n            color += applyPointLight(light, materialInfo, normal, view);\n        }\n        else if (light.type == LightType_Spot)\n        {\n            color += applySpotLight(light, materialInfo, normal, view, shadow);\n        }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    color += getIBLContribution(materialInfo, normal, view);\n#endif\n\n    float ao = 1.0;\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSION_MAP\n    ao = texture2D(u_OcclusionSampler,  getOcclusionUV()).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n    vec3 emissive = vec3(0);\n#ifdef HAS_EMISSIVE_MAP\n    emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, getEmissiveUV())).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifndef DEBUG_OUTPUT // no debug\n\n   // regular shading\n    gl_FragColor = vec4(toneMap(color) * baseColor.a, baseColor.a);\n\n#else // debug output\n\n    #ifdef DEBUG_METALLIC\n        gl_FragColor.rgb = vec3(metallic);\n    #endif\n\n    #ifdef DEBUG_ROUGHNESS\n        gl_FragColor.rgb = vec3(perceptualRoughness);\n    #endif\n\n    #ifdef DEBUG_NORMAL\n        #ifdef HAS_NORMAL_MAP\n            gl_FragColor.rgb = texture2D(u_NormalSampler, getNormalUV()).rgb;\n        #else\n            gl_FragColor.rgb = vec3(0.5, 0.5, 1.0);\n        #endif\n    #endif\n\n    #ifdef DEBUG_BASECOLOR\n        gl_FragColor.rgb = LINEARtoSRGB(baseColor.rgb);\n    #endif\n\n    #ifdef DEBUG_OCCLUSION\n        gl_FragColor.rgb = vec3(ao);\n    #endif\n\n    #ifdef DEBUG_EMISSIVE\n        gl_FragColor.rgb = LINEARtoSRGB(emissive);\n    #endif\n\n    #ifdef DEBUG_F0\n        gl_FragColor.rgb = vec3(f0);\n    #endif\n\n    #ifdef DEBUG_ALPHA\n        gl_FragColor.rgb = vec3(baseColor.a);\n    #endif\n\n    gl_FragColor.a = 1.0;\n\n#endif // !DEBUG_OUTPUT\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#version 300 es\n\n//\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n#define FEATURES\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\n#include <tonemapping.glsl>\n#include <textures.webgl2.glsl>\n#include <functions.webgl2.glsl>\n#include <shadow.webgl2.glsl>\n\n// KHR_lights_punctual extension.\n// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nstruct Light\n{\n    vec3 direction;\n    float range;\n\n    vec3 color;\n    float intensity;\n\n    vec3 position;\n    float innerConeCos;\n\n    float outerConeCos;\n    int type;\n\n    vec2 padding;\n};\n\nconst int LightType_Directional = 0;\nconst int LightType_Point = 1;\nconst int LightType_Spot = 2;\n\n#ifdef USE_PUNCTUAL\nuniform Light u_Lights[LIGHT_COUNT];\n#endif\n\n#if defined(MATERIAL_SPECULARGLOSSINESS) || defined(MATERIAL_METALLICROUGHNESS)\nuniform float u_MetallicFactor;\nuniform float u_RoughnessFactor;\nuniform vec4 u_BaseColorFactor;\n#endif\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\nuniform vec3 u_SpecularFactor;\nuniform vec4 u_DiffuseFactor;\nuniform float u_GlossinessFactor;\n#endif\n\n#ifdef ALPHAMODE_MASK\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec3 u_Camera;\n\nuniform int u_MipCount;\n\nstruct MaterialInfo\n{\n    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n    vec3 reflectance0;            // full reflectance color (normal incidence angle)\n\n    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n    vec3 diffuseColor;            // color contribution from diffuse lighting\n\n    vec3 reflectance90;           // reflectance color at grazing angle\n    vec3 specularColor;           // color contribution from specular lighting\n};\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)\n{\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n\n    float lod = clamp(materialInfo.perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    // retrieve a scale and bias to F0. See [1], Figure 3\n    vec2 brdf = texture(u_brdfLUT, brdfSamplePoint).rg;\n\n    vec4 diffuseSample = texture(u_DiffuseEnvSampler, n);\n\n#ifdef USE_TEX_LOD\n    vec4 specularSample = textureLod(u_SpecularEnvSampler, reflection, lod);\n#else\n    vec4 specularSample = texture(u_SpecularEnvSampler, reflection);\n#endif\n\n#ifdef USE_HDR\n    // Already linear.\n    vec3 diffuseLight = diffuseSample.rgb;\n    vec3 specularLight = specularSample.rgb;\n#else\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;\n#endif\n\n    vec3 diffuse = diffuseLight * materialInfo.diffuseColor;\n    vec3 specular = specularLight * (materialInfo.specularColor * brdf.x + brdf.y);\n\n    return diffuse + specular;\n}\n#endif\n\n// Lambert lighting\n// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\nvec3 diffuse(MaterialInfo materialInfo)\n{\n    return materialInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    return materialInfo.reflectance0 + (materialInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat visibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float NdotL = angularInfo.NdotL;\n    float NdotV = angularInfo.NdotV;\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n    float f = (angularInfo.NdotH * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nvec3 getPointShade(vec3 pointToLight, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    AngularInfo angularInfo = getAngularInfo(pointToLight, normal, view);\n\n    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)\n    {\n        // Calculate the shading terms for the microfacet specular shading model\n        vec3 F = specularReflection(materialInfo, angularInfo);\n        float Vis = visibilityOcclusion(materialInfo, angularInfo);\n        float D = microfacetDistribution(materialInfo, angularInfo);\n\n        // Calculation of analytical lighting contribution\n        vec3 diffuseContrib = (1.0 - F) * diffuse(materialInfo);\n        vec3 specContrib = F * Vis * D;\n\n        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n        return angularInfo.NdotL * (diffuseContrib + specContrib);\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(float range, float distance)\n{\n    if (range <= 0.0)\n    {\n        // negative range means unlimited\n        return 1.0;\n    }\n    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)\n{\n    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));\n    if (actualCos > outerConeCos)\n    {\n        if (actualCos < innerConeCos)\n        {\n            return smoothstep(outerConeCos, innerConeCos, actualCos);\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 applyDirectionalLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = -light.direction;\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return light.intensity * light.color * shade;\n}\n\nvec3 applyPointLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float attenuation = getRangeAttenuation(light.range, distance);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);\n    return attenuation * light.intensity * light.color * shade;\n}\n\nvec3 applySpotLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float rangeAttenuation = getRangeAttenuation(light.range, distance);\n    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return rangeAttenuation * spotAttenuation * light.intensity * light.color * shade;\n}\n\nout vec4 fragColor;\n\nvoid main()\n{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = 0.0;\n    float metallic = 0.0;\n    vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 specularColor= vec3(0.0);\n    vec3 f0 = vec3(0.04);\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    vec4 sgSample = SRGBtoLINEAR(texture(u_SpecularGlossinessSampler, getSpecularGlossinessUV()));\n    perceptualRoughness = (1.0 - sgSample.a * u_GlossinessFactor); // glossiness to roughness\n    f0 = sgSample.rgb * u_SpecularFactor; // specular\n#else\n    f0 = u_SpecularFactor;\n    perceptualRoughness = 1.0 - u_GlossinessFactor;\n#endif // ! HAS_SPECULAR_GLOSSINESS_MAP\n\n#ifdef HAS_DIFFUSE_MAP\n    baseColor = SRGBtoLINEAR(texture2D(u_DiffuseSampler, getDiffuseUV())) * u_DiffuseFactor;\n#else\n    baseColor = u_DiffuseFactor;\n#endif // !HAS_DIFFUSE_MAP\n\n    baseColor *= getVertexColor();\n\n    // f0 = specular\n    specularColor = f0;\n    float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);\n    diffuseColor = baseColor.rgb * oneMinusSpecularStrength;\n\n#ifdef DEBUG_METALLIC\n    // do conversion between metallic M-R and S-G metallic\n    metallic = solveMetallic(baseColor.rgb, specularColor, oneMinusSpecularStrength);\n#endif // ! DEBUG_METALLIC\n\n#endif // ! MATERIAL_SPECULARGLOSSINESS\n\n#ifdef MATERIAL_METALLICROUGHNESS\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(u_MetallicRoughnessSampler, getMetallicRoughnessUV());\n    perceptualRoughness = mrSample.g * u_RoughnessFactor;\n    metallic = mrSample.b * u_MetallicFactor;\n#else\n    metallic = u_MetallicFactor;\n    perceptualRoughness = u_RoughnessFactor;\n#endif\n\n    // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASE_COLOR_MAP\n    baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, getBaseColorUV())) * u_BaseColorFactor;\n#else\n    baseColor = u_BaseColorFactor;\n#endif\n\n    baseColor *= getVertexColor();\n\n    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n\n    specularColor = mix(f0, baseColor.rgb, metallic);\n\n#endif // ! MATERIAL_METALLICROUGHNESS\n\n#ifdef ALPHAMODE_MASK\n    if(baseColor.a < u_AlphaCutoff)\n    {\n        discard;\n    }\n    baseColor.a = 1.0;\n#endif\n\n#ifdef ALPHAMODE_OPAQUE\n    baseColor.a = 1.0;\n#endif\n\n#ifdef MATERIAL_UNLIT\n    fragColor = vec4(LINEARtoSRGB(baseColor.rgb) * baseColor.a, baseColor.a);\n    return;\n#endif\n\n    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));\n\n    MaterialInfo materialInfo = MaterialInfo(\n        perceptualRoughness,\n        specularEnvironmentR0,\n        alphaRoughness,\n        diffuseColor,\n        specularEnvironmentR90,\n        specularColor\n    );\n\n    // LIGHTING\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 normal = getNormal();\n    vec3 view = normalize(u_Camera - v_Position);\n\n    float shadow = 1.0;\n    #ifdef USE_SHADOW_MAPPING\n        shadow = getShadowContribution();\n    #endif\n\n#ifdef USE_PUNCTUAL\n    for (int i = 0; i < LIGHT_COUNT; ++i)\n    {\n        Light light = u_Lights[i];\n        if (light.type == LightType_Directional)\n        {\n            color += applyDirectionalLight(light, materialInfo, normal, view, shadow);\n        }\n        else if (light.type == LightType_Point)\n        {\n            color += applyPointLight(light, materialInfo, normal, view);\n        }\n        else if (light.type == LightType_Spot)\n        {\n            color += applySpotLight(light, materialInfo, normal, view, shadow);\n        }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    color += getIBLContribution(materialInfo, normal, view);\n#endif\n\n    float ao = 1.0;\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSION_MAP\n    ao = texture(u_OcclusionSampler,  getOcclusionUV()).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n    vec3 emissive = vec3(0);\n#ifdef HAS_EMISSIVE_MAP\n    emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, getEmissiveUV())).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifndef DEBUG_OUTPUT // no debug\n\n   // regular shading\n    fragColor = vec4(toneMap(color) * baseColor.a, baseColor.a);\n\n#else // debug output\n\n    #ifdef DEBUG_METALLIC\n        fragColor.rgb = vec3(metallic);\n    #endif\n\n    #ifdef DEBUG_ROUGHNESS\n        fragColor.rgb = vec3(perceptualRoughness);\n    #endif\n\n    #ifdef DEBUG_NORMAL\n        #ifdef HAS_NORMAL_MAP\n            fragColor.rgb = texture(u_NormalSampler, getNormalUV()).rgb;\n        #else\n            fragColor.rgb = vec3(0.5, 0.5, 1.0);\n        #endif\n    #endif\n\n    #ifdef DEBUG_BASECOLOR\n        fragColor.rgb = LINEARtoSRGB(baseColor.rgb);\n    #endif\n\n    #ifdef DEBUG_OCCLUSION\n        fragColor.rgb = vec3(ao);\n    #endif\n\n    #ifdef DEBUG_EMISSIVE\n        gl_FragColor.rgb = LINEARtoSRGB(emissive);\n    #endif\n\n    #ifdef DEBUG_F0\n        fragColor.rgb = vec3(f0);\n    #endif\n\n    #ifdef DEBUG_ALPHA\n        fragColor.rgb = vec3(baseColor.a);\n    #endif\n\n    fragColor.a = 1.0;\n\n#endif // !DEBUG_OUTPUT\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\n#define FEATURES\n\n#include <animation.webgl1.glsl>\n\nattribute vec4 a_Position;\nvarying vec3 v_Position;\n\n#ifdef HAS_NORMALS\nattribute vec4 a_Normal;\n#endif\n\n#ifdef HAS_TANGENTS\nattribute vec4 a_Tangent;\n#endif\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 v_TBN;\n#else\nvarying vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_UV_SET1\nattribute vec2 a_UV1;\n#endif\n\n#ifdef HAS_UV_SET2\nattribute vec2 a_UV2;\n#endif\n\nvarying vec2 v_UVCoord1;\nvarying vec2 v_UVCoord2;\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nattribute vec3 a_Color;\nvarying vec3 v_Color;\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC4\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\n#ifdef USE_SHADOW_MAPPING\nuniform mat4 u_LightViewProjectionMatrix;\nvarying vec4 v_PositionLightSpace;\n#endif\n\nvec4 getPosition()\n{\n    vec4 pos = a_Position;\n\n#ifdef USE_MORPHING\n    pos += getTargetPosition();\n#endif\n\n#ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n#endif\n\n    return pos;\n}\n\n#ifdef HAS_NORMALS\nvec4 getNormal()\n{\n    vec4 normal = a_Normal;\n\n#ifdef USE_MORPHING\n    normal += getTargetNormal();\n#endif\n\n#ifdef USE_SKINNING\n    normal = getSkinningNormalMatrix() * normal;\n#endif\n\n    return normalize(normal);\n}\n#endif\n\n#ifdef HAS_TANGENTS\nvec4 getTangent()\n{\n    vec4 tangent = a_Tangent;\n\n#ifdef USE_MORPHING\n    tangent += getTargetTangent();\n#endif\n\n#ifdef USE_SKINNING\n    tangent = getSkinningMatrix() * tangent;\n#endif\n\n    return normalize(tangent);\n}\n#endif\n\nvoid main()\n{\n    vec4 pos = u_ModelMatrix * getPosition();\n    v_Position = vec3(pos.xyz) / pos.w;\n\n    #ifdef HAS_NORMALS\n    #ifdef HAS_TANGENTS\n    vec4 tangent = getTangent();\n    vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(getNormal().xyz, 0.0)));\n    vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n    vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n    v_TBN = mat3(tangentW, bitangentW, normalW);\n    #else // !HAS_TANGENTS\n    v_Normal = normalize(vec3(u_NormalMatrix * vec4(getNormal().xyz, 0.0)));\n    #endif\n    #endif // !HAS_NORMALS\n\n    v_UVCoord1 = vec2(0.0, 0.0);\n    v_UVCoord2 = vec2(0.0, 0.0);\n\n    #ifdef HAS_UV_SET1\n    v_UVCoord1 = a_UV1;\n    #endif\n\n    #ifdef HAS_UV_SET2\n    v_UVCoord2 = a_UV2;\n    #endif\n\n    #if defined(HAS_VERTEX_COLOR_VEC3) || defined(HAS_VERTEX_COLOR_VEC4)\n    v_Color = a_Color;\n    #endif\n\n    #ifdef USE_SHADOW_MAPPING\n    v_PositionLightSpace = u_LightViewProjectionMatrix * pos;\n    #endif\n\n    gl_Position = u_ViewProjectionMatrix * pos;\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#version 300 es\n\n#define FEATURES\n\n#include <animation.webgl2.glsl>\n\nin vec4 a_Position;\nout vec3 v_Position;\n\n#ifdef HAS_NORMALS\nin vec4 a_Normal;\n#endif\n\n#ifdef HAS_TANGENTS\nin vec4 a_Tangent;\n#endif\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nout mat3 v_TBN;\n#else\nout vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_UV_SET1\nin vec2 a_UV1;\n#endif\n\n#ifdef HAS_UV_SET2\nin vec2 a_UV2;\n#endif\n\nout vec2 v_UVCoord1;\nout vec2 v_UVCoord2;\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nin vec3 a_Color;\nout vec3 v_Color;\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC4\nin vec4 a_Color;\nout vec4 v_Color;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\n#ifdef USE_SHADOW_MAPPING\nuniform mat4 u_LightViewProjectionMatrix;\nout vec4 v_PositionLightSpace;\n#endif\n\nvec4 getPosition()\n{\n    vec4 pos = a_Position;\n\n#ifdef USE_MORPHING\n    pos += getTargetPosition();\n#endif\n\n#ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n#endif\n\n    return pos;\n}\n\n#ifdef HAS_NORMALS\nvec4 getNormal()\n{\n    vec4 normal = a_Normal;\n\n#ifdef USE_MORPHING\n    normal += getTargetNormal();\n#endif\n\n#ifdef USE_SKINNING\n    normal = getSkinningNormalMatrix() * normal;\n#endif\n\n    return normalize(normal);\n}\n#endif\n\n#ifdef HAS_TANGENTS\nvec4 getTangent()\n{\n    vec4 tangent = a_Tangent;\n\n#ifdef USE_MORPHING\n    tangent += getTargetTangent();\n#endif\n\n#ifdef USE_SKINNING\n    tangent = getSkinningMatrix() * tangent;\n#endif\n\n    return normalize(tangent);\n}\n#endif\n\nvoid main()\n{\n    vec4 pos = u_ModelMatrix * getPosition();\n    v_Position = vec3(pos.xyz) / pos.w;\n\n    #ifdef HAS_NORMALS\n    #ifdef HAS_TANGENTS\n    vec4 tangent = getTangent();\n    vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(getNormal().xyz, 0.0)));\n    vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n    vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n    v_TBN = mat3(tangentW, bitangentW, normalW);\n    #else // !HAS_TANGENTS\n    v_Normal = normalize(vec3(u_NormalMatrix * vec4(getNormal().xyz, 0.0)));\n    #endif\n    #endif // !HAS_NORMALS\n\n    v_UVCoord1 = vec2(0.0, 0.0);\n    v_UVCoord2 = vec2(0.0, 0.0);\n\n    #ifdef HAS_UV_SET1\n    v_UVCoord1 = a_UV1;\n    #endif\n\n    #ifdef HAS_UV_SET2\n    v_UVCoord2 = a_UV2;\n    #endif\n\n    #if defined(HAS_VERTEX_COLOR_VEC3) || defined(HAS_VERTEX_COLOR_VEC4)\n    v_Color = a_Color;\n    #endif\n\n    #ifdef USE_SHADOW_MAPPING\n    v_PositionLightSpace = u_LightViewProjectionMatrix * pos;\n    #endif\n\n    gl_Position = u_ViewProjectionMatrix * pos;\n}\n"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){this.alphaCutoff=.5,this.alphaMode="OPAQUE",this.doubleSided=!1,this.roughness=1,this.metallic=1,this.emissive=[0,0,0],this.baseColor=[1,1,1,1],this.unlit=!1};n.glTFMaterial=r},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),i=function(){function e(n,t){var o=this;this.renderer=n,this.lights=[],this.renderer.on("prerender",(function(){var e,n;try{for(var t=r(o.lights),i=t.next();!i.done;i=t.next()){var a=i.value;a.parent||a.transform.updateTransform()}}catch(n){e={error:n}}finally{try{i&&!i.done&&(n=t.return)&&n.call(t)}finally{if(e)throw e.error}}})),e.main||(e.main=this),this._imageBasedLighting=t}return Object.defineProperty(e.prototype,"imageBasedLighting",{get:function(){return this._imageBasedLighting},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"valid",{get:function(){return!this._imageBasedLighting||this._imageBasedLighting.valid},enumerable:!0,configurable:!0}),e}();n.LightingEnvironment=i,o.Renderer.registerPlugin("lighting",i)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=function(e){function n(n){var t=e.call(this)||this;return t.name=n,t.speed=1,t.loop=!1,t}return o(n,e),n.prototype.play=function(e){var n=this;void 0===e&&(e=i.Ticker.shared),this.position=0,this._ticker||(this._update=function(){n.update(e.deltaMS/1e3*n.speed)},this._ticker=e.add(this._update))},n.prototype.stop=function(){this._ticker&&this._update&&(this._ticker.remove(this._update),this._ticker=this._update=void 0)},n.prototype.update=function(e){this.position+=e,this.position<this.duration||(this.loop?this.position>this.duration&&(this.position=this.position%this.duration):(this.position=this.duration,this.stop()),this.emit("complete"))},n}(i.utils.EventEmitter);n.Animation=a},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(5),o=function(){function e(e,n){this.parent=e,this.joints=n,this._arrayVertexMatrices=[],this._arrayNormalMatrices=[],this._jointVertexMatrices=new Float32Array(16*n.length),this._jointNormalMatrices=new Float32Array(16*n.length);for(var t=0;t<n.length;t++)this._arrayVertexMatrices.push(new Float32Array(this._jointVertexMatrices.buffer,64*t,16)),this._arrayNormalMatrices.push(new Float32Array(this._jointNormalMatrices.buffer,64*t,16))}return e.prototype.calculateJointMatrices=function(){for(var e=0;e<this.joints.length;e++)r.Mat4.multiply(this.joints[e].node.worldTransform.toArray(),this.joints[e].inverseBindMatrix,this._arrayVertexMatrices[e]),r.Mat4.multiply(this.parent.transform.inverseWorldTransform.toArray(),this._arrayVertexMatrices[e],this._arrayVertexMatrices[e]),r.Mat4.invert(this._arrayVertexMatrices[e],this._arrayNormalMatrices[e]),r.Mat4.transpose(this._arrayNormalMatrices[e],this._arrayNormalMatrices[e]);return{jointVertexMatrices:this._jointVertexMatrices,jointNormalMatrices:this._jointNormalMatrices}},e}();n.Skin=o},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(e,n){this.node=e,this.inverseBindMatrix=n};n.Joint=r},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),i=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),s=t(40),u=t(41),l=function(e){function n(n){var t=e.call(this,n)||this;return t.renderer=n,t._meshes=[],t._shadowRenderPass=new u.ShadowRenderPass(n,"shadow"),t._materialRenderPass=new s.MaterialRenderPass(n,"material"),t.renderPasses=[t._shadowRenderPass,t._materialRenderPass],n.on("prerender",(function(){var e,n;try{for(var r=i(t.renderPasses),o=r.next();!o.done;o=r.next()){var a=o.value;a.clear&&a.clear()}}catch(n){e={error:n}}finally{try{o&&!o.done&&(n=r.return)&&n.call(r)}finally{if(e)throw e.error}}})),t}return o(n,e),Object.defineProperty(n.prototype,"shadowRenderPass",{get:function(){return this._shadowRenderPass},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"materialRenderPass",{get:function(){return this._materialRenderPass},enumerable:!0,configurable:!0}),n.from=function(e){return e.plugins.pipeline},n.prototype.render=function(e){this._meshes.push(e)},n.prototype.flush=function(){var e,n;this.sort();var t=function(e){e.render(r._meshes.filter((function(n){return n.renderPasses.indexOf(e.name)>=0})))},r=this;try{for(var o=i(this.renderPasses),a=o.next();!a.done;a=o.next()){t(a.value)}}catch(n){e={error:n}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(e)throw e.error}}this._meshes=[]},n.prototype.sort=function(){this._meshes.sort((function(e,n){return e.material&&n.material?e.material.transparent===n.material.transparent?0:e.material.transparent?1:-1:0}))},n}(a.ObjectRenderer);n.StandardPipeline=l,a.Renderer.registerPlugin("pipeline",l)},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),i=t(39),a=function(){function e(e,n){this.renderer=e,this.name=n,this._transparent=[Object.assign(new o.State,{culling:!0,clockwiseFrontFace:!0,depthTest:!0}),Object.assign(new o.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0})],this._default=Object.assign(new o.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0}),this._doubleSided=Object.assign(new o.State,{culling:!1,clockwiseFrontFace:!0,depthTest:!0}),this.clearColor=[0,0,0,0]}return Object.defineProperty(e.prototype,"renderTexture",{get:function(){return this._renderTexture},set:function(e){this._renderTexture=e},enumerable:!0,configurable:!0}),e.addAsRenderPass=function(n,t){var r=new e(n,t);return i.StandardPipeline.from(n).renderPasses.push(r),r},e.prototype.clear=function(){this._renderTexture&&this.clearColor&&(this.renderer.renderTexture.bind(this._renderTexture),this.renderer.renderTexture.clear(this.clearColor),this.renderer.renderTexture.bind(void 0))},e.prototype.render=function(e){var n,t;this._renderTexture&&this.renderer.renderTexture.bind(this._renderTexture);try{for(var o=r(e),i=o.next();!i.done;i=o.next()){var a=i.value;if(!a.material)return;a.material.doubleSided&&!a.material.transparent?a.material.render(a,this.renderer,this._doubleSided):a.material.doubleSided?(a.material.render(a,this.renderer,this._transparent[0]),a.material.render(a,this.renderer,this._transparent[1])):a.material.render(a,this.renderer,this._default)}}catch(e){n={error:e}}finally{try{i&&!i.done&&(t=o.return)&&t.call(o)}finally{if(n)throw n.error}}this._renderTexture&&this.renderer.renderTexture.bind(void 0)},e}();n.MaterialRenderPass=a},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(79),i=t(18),a=t(13),s=t(82),u=function(){function e(e,n){void 0===n&&(n="shadow"),this.renderer=e,this.name=n,this.lights=[],this._filter=new o.ShadowFilter(e),this._shadow=new s.ShadowRenderer(e)}return e.prototype.enableShadows=function(e,n){var t,o,s=e instanceof i.Model?e.meshes:[e];try{for(var u=r(s),l=u.next();!l.done;l=u.next()){var f=l.value;n&&f.material instanceof a.StandardMaterial&&(f.material.shadowCastingLight=n),f.renderPasses.push(this.name)}}catch(e){t={error:e}}finally{try{l&&!l.done&&(o=u.return)&&o.call(u)}finally{if(t)throw t.error}}},e.prototype.clear=function(){var e,n;try{for(var t=r(this.lights),o=t.next();!o.done;o=t.next()){o.value.clear()}}catch(n){e={error:n}}finally{try{o&&!o.done&&(n=t.return)&&n.call(t)}finally{if(e)throw e.error}}},e.prototype.render=function(e){var n,t,o,i;try{for(var a=r(this.lights),s=a.next();!s.done;s=a.next()){var u=s.value;this.renderer.renderTexture.bind(u.shadowTexture),u.updateLightViewProjection();try{for(var l=(o=void 0,r(e)),f=l.next();!f.done;f=l.next()){var c=f.value;this._shadow.render(c,u)}}catch(e){o={error:e}}finally{try{f&&!f.done&&(i=l.return)&&i.call(l)}finally{if(o)throw o.error}}this.renderer.renderTexture.bind(void 0),u.softness>0&&this._filter.applyGaussianBlur(u)}}catch(e){n={error:e}}finally{try{s&&!s.done&&(t=a.return)&&t.call(a)}finally{if(n)throw n.error}}},e}();n.ShadowRenderPass=u},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(43);n.glTFLoader=r.glTFLoader;var o=t(22);n.glTFAsset=o.glTFAsset;var i=t(12);n.ObservablePoint3D=i.ObservablePoint3D;var a=t(23);n.ObservableQuaternion=a.ObservableQuaternion;var s=t(24);n.Transform3D=s.Transform3D;var u=t(1);n.Container3D=u.Container3D;var l=t(2);n.Camera=l.Camera;var f=t(44);n.CameraOrbitControl=f.CameraOrbitControl;var c=t(6);n.Mesh3D=c.Mesh3D;var d=t(7);n.MeshGeometry3D=d.MeshGeometry3D;var _=t(3);n.MeshShader=_.MeshShader;var p=t(18);n.Model=p.Model;var h=t(36);n.Animation=h.Animation;var m=t(8);n.LightType=m.LightType;var g=t(76);n.Light=g.Light;var v=t(35);n.LightingEnvironment=v.LightingEnvironment;var S=t(77);n.ImageBasedLighting=S.ImageBasedLighting;var y=t(39);n.StandardPipeline=y.StandardPipeline;var T=t(40);n.MaterialRenderPass=T.MaterialRenderPass;var b=t(17);n.Material=b.Material;var A=t(87);n.CubeMipmapLoader=A.CubeMipmapLoader;var M=t(20);n.CubeMipmapTexture=M.CubeMipmapTexture;var E=t(90);n.ShaderSourceLoader=E.ShaderSourceLoader;var x=t(91);n.Skybox=x.Skybox;var O=t(13);n.StandardMaterial=O.StandardMaterial;var w=t(15);n.StandardMaterialAlphaMode=w.StandardMaterialAlphaMode;var P=t(28);n.StandardMaterialDebugMode=P.StandardMaterialDebugMode;var R=t(95);n.PickingHitArea=R.PickingHitArea;var N=t(97);n.PickingManager=N.PickingManager;var C=t(37);n.Skin=C.Skin;var I=t(38);n.Joint=I.Joint;var L=t(41);n.ShadowRenderPass=L.ShadowRenderPass;var U=t(101);n.ShadowCastingLight=U.ShadowCastingLight;var G=t(21);n.ShadowQuality=G.ShadowQuality;var j=t(104);n.PostProcessingSprite=j.PostProcessingSprite},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(22);n.glTFLoader={use:function(e,n){if("gltf"!==e.extension)return n();Object.assign(e,{gltf:o.glTFAsset.load(e.data,new i(this,e))}),n()},add:function(){r.LoaderResource.setExtensionXhrType("bin",r.LoaderResource.XHR_RESPONSE_TYPE.BUFFER),r.LoaderResource.setExtensionXhrType("gltf",r.LoaderResource.XHR_RESPONSE_TYPE.JSON)}},r.Loader.registerPlugin(n.glTFLoader);var i=function(){function e(e,n){this._loader=e,this._resource=n}return e.prototype.load=function(e,n){this._loader.add({parentResource:this._resource,url:this._resource.url.substring(0,this._resource.url.lastIndexOf("/")+1)+e,onComplete:n})},e}()},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(2),i=t(4),a=t(14),s=function(){function e(e,n){var t=this;void 0===n&&(n=o.Camera.main),this.camera=n,this._distance=5,this._angles=new r.ObservablePoint((function(){t._angles.x=Math.min(Math.max(-85,t._angles.x),85)}),void 0,0,180),this.target={x:0,y:0,z:0},this.allowControl=!0,this.camera.renderer.on("prerender",(function(){t.updateCamera()})),e.addEventListener("mousemove",(function(e){t.allowControl&&1===e.buttons&&(t._angles.x+=.5*e.movementY,t._angles.y-=.5*e.movementX)})),e.addEventListener("mousewheel",(function(e){t.allowControl&&(t.distance+=.01*e.deltaY,e.preventDefault())}))}return Object.defineProperty(e.prototype,"angles",{get:function(){return this._angles},enumerable:!0,configurable:!0}),e.prototype.updateCamera=function(){var e=i.Quat.fromEuler(this._angles.x,this._angles.y,0,new Float32Array(4)),n=a.Vec3.transformQuat(a.Vec3.set(0,0,1,new Float32Array(3)),e,new Float32Array(3)),t=a.Vec3.subtract(a.Vec3.set(this.target.x,this.target.y,this.target.z,new Float32Array(3)),a.Vec3.scale(n,this.distance,new Float32Array(3)),new Float32Array(3));this.camera.position.set(t[0],t[1],t[2]),this.camera.rotationQuaternion.set(e[0],e[1],e[2],e[3])},Object.defineProperty(e.prototype,"distance",{get:function(){return this._distance},set:function(e){this._distance=Math.min(Math.max(e,.01),Number.MAX_SAFE_INTEGER)},enumerable:!0,configurable:!0}),e}();n.CameraOrbitControl=s},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(7);!function(e){e.create=function(){return Object.assign(new r.MeshGeometry3D,{positions:{buffer:new Float32Array([-1,0,1,1,0,-1,-1,0,-1,1,0,1])},indices:{buffer:new Uint8Array([0,1,2,0,3,1])},normals:{buffer:new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0])},uvs:[{buffer:new Float32Array([0,1,1,0,0,0,1,1])}]})}}(n.PlaneGeometry||(n.PlaneGeometry={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(7);!function(e){e.create=function(){return Object.assign(new r.MeshGeometry3D,{positions:{buffer:new Float32Array([-1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1])},indices:{buffer:new Uint8Array([0,1,2,0,3,1,4,5,6,4,7,5,8,9,10,8,11,9,12,13,14,12,15,13,16,17,18,16,19,17,20,21,22,20,23,21])},normals:{buffer:new Float32Array([-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0])},uvs:[{buffer:new Float32Array([.625,1,.375,.75,.375,1,.625,.75,.625,.75,.375,.5,.375,.75,.625,.5,.625,.5,.375,.25,.375,.5,.625,.25,.625,.25,.375,0,.375,.25,.625,0,.375,.25,.125,.5,.375,.5,.125,.25,.875,.25,.625,.5,.875,.5,.625,.25])}],tangents:{buffer:new Float32Array([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1])}})}}(n.CubeGeometry||(n.CubeGeometry={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(15),o=t(28),i=t(9),a=t(16),s=t(48);!function(e){e.build=function(e,n,t,u,l){var f=[];if(t.normals&&f.push("HAS_NORMALS 1"),t.uvs&&f.push("HAS_UV_SET1 1"),t.tangents&&f.push("HAS_TANGENTS 1"),t.targets){for(var c=0;c<t.targets.length;c++)t.targets[c].positions&&f.push("HAS_TARGET_POSITION"+c),t.targets[c].normals&&f.push("HAS_TARGET_NORMAL"+c),t.targets[c].tangents&&f.push("HAS_TARGET_TANGENT"+c);n.morphWeights&&(f.push("WEIGHT_COUNT "+n.morphWeights.length),f.push("USE_MORPHING 1"))}if(t.joints&&f.push("HAS_JOINT_SET1 1"),t.weights&&f.push("HAS_WEIGHT_SET1 1"),n.skin&&(!function(e,n){var t=i.Platform.getMaxVertexUniformVectors(n)-25;return e>Math.floor(t/8)}(n.skin.joints.length,e)?f.push("USE_SKINNING 1"):a.StandardMaterialMatrixTexture.isSupported(e)?(f.push("USE_SKINNING 1"),f.push("USE_SKINNING_TEXTURE 1")):s.Console.error("PIXI3D: Mesh contains "+n.skin.joints.length+" joints, which is more than supported on this device. Skinning will be disabled and result may not be as expected."),f.push("JOINT_COUNT "+n.skin.joints.length)),u.unlit&&f.push("MATERIAL_UNLIT 1"),f.push("MATERIAL_METALLICROUGHNESS 1"),l.lights.length>0&&(f.push("LIGHT_COUNT "+l.lights.length),f.push("USE_PUNCTUAL 1")),l.imageBasedLighting){if(!l.imageBasedLighting.valid)return;i.Platform.isShaderTextureLodSupported(e)&&f.push("USE_TEX_LOD 1"),f.push("USE_IBL 1")}if(u.shadowCastingLight&&f.push("USE_SHADOW_MAPPING 1"),u.baseColorTexture){if(!u.baseColorTexture.valid)return;f.push("HAS_BASE_COLOR_MAP 1")}if(u.emissiveTexture){if(!u.emissiveTexture.valid)return;f.push("HAS_EMISSIVE_MAP 1")}if(u.normalTexture){if(!u.normalTexture.valid)return;f.push("HAS_NORMAL_MAP 1")}if(u.metallicRoughnessTexture){if(!u.metallicRoughnessTexture.valid)return;f.push("HAS_METALLIC_ROUGHNESS_MAP 1")}if(u.occlusionTexture){if(!u.occlusionTexture.valid)return;f.push("HAS_OCCLUSION_MAP 1")}switch(u.alphaMode){case r.StandardMaterialAlphaMode.opaque:f.push("ALPHAMODE_OPAQUE 1");break;case r.StandardMaterialAlphaMode.mask:f.push("ALPHAMODE_MASK 1")}switch(u.debugMode&&f.push("DEBUG_OUTPUT 1"),u.debugMode){case o.StandardMaterialDebugMode.alpha:f.push("DEBUG_ALPHA 1");break;case o.StandardMaterialDebugMode.emissive:f.push("DEBUG_EMISSIVE 1");break;case o.StandardMaterialDebugMode.f0:f.push("DEBUG_F0 1");break;case o.StandardMaterialDebugMode.metallic:f.push("DEBUG_METALLIC 1");break;case o.StandardMaterialDebugMode.normal:f.push("DEBUG_NORMAL 1");break;case o.StandardMaterialDebugMode.occlusion:f.push("DEBUG_OCCLUSION 1");break;case o.StandardMaterialDebugMode.roughness:f.push("DEBUG_ROUGHNESS 1")}return f},e.hasSkinningTextureFeature=function(e){return e.includes("USE_SKINNING_TEXTURE 1")}}(n.StandardMaterialFeatureSet||(n.StandardMaterialFeatureSet={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){var n=[];e.error=function(e){n.includes(e)||(n.push(e),console.error(e))}}(n.Console||(n.Console={}))},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(3),s=t(29),u=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return o(n,e),n.build=function(e,r){var o="webgl1";2===e.context.webGLVersion&&(o="webgl2");var a=t(61)("./primitive."+o+".vert").default,u=t(62)("./metallic-roughness."+o+".frag").default;return new n(i.Program.from(s.StandardShaderSource.build(a,r),s.StandardShaderSource.build(u,r)))},Object.defineProperty(n.prototype,"name",{get:function(){return"standard-shader"},enumerable:!0,configurable:!0}),n.prototype.createShaderGeometry=function(n){var t=e.prototype.createShaderGeometry.call(this,n);if(n.targets)for(var r=0;r<n.targets.length;r++){var o=n.targets[r].positions;o&&t.addAttribute("a_Target_Position"+r,new i.Buffer(o.buffer),3,!1,o.componentType,o.stride);var a=n.targets[r].normals;a&&t.addAttribute("a_Target_Normal"+r,new i.Buffer(a.buffer),3,!1,a.componentType,a.stride);var s=n.targets[r].tangents;s&&t.addAttribute("a_Target_Tangent"+r,new i.Buffer(s.buffer),3,!1,s.componentType,s.stride)}return n.joints&&t.addAttribute("a_Joint1",new i.Buffer(n.joints.buffer),4,!1,n.joints.componentType,n.joints.stride),n.weights&&t.addAttribute("a_Weight1",new i.Buffer(n.weights.buffer),4,!1,n.weights.componentType,n.weights.stride),t},n}(a.MeshShader);n.StandardShader=u},function(e,n,t){var r={"./animation.webgl1.glsl":51,"./animation.webgl2.glsl":52,"./extensions.webgl1.glsl":53,"./functions.webgl1.glsl":54,"./functions.webgl2.glsl":55,"./metallic-roughness.webgl1.frag":30,"./metallic-roughness.webgl2.frag":31,"./primitive.webgl1.vert":32,"./primitive.webgl2.vert":33,"./shadow.webgl1.glsl":56,"./shadow.webgl2.glsl":57,"./textures.webgl1.glsl":58,"./textures.webgl2.glsl":59,"./tonemapping.glsl":60};function o(e){var n=i(e);return t(n)}function i(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=i,e.exports=o,o.id=50},function(e,n,t){"use strict";t.r(n),n.default="#ifdef HAS_TARGET_POSITION0\nattribute vec3 a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\nattribute vec3 a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\nattribute vec3 a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\nattribute vec3 a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\nattribute vec3 a_Target_Position4;\n#endif\n\n#ifdef HAS_TARGET_POSITION5\nattribute vec3 a_Target_Position5;\n#endif\n\n#ifdef HAS_TARGET_POSITION6\nattribute vec3 a_Target_Position6;\n#endif\n\n#ifdef HAS_TARGET_POSITION7\nattribute vec3 a_Target_Position7;\n#endif\n\n#ifdef HAS_TARGET_NORMAL0\nattribute vec3 a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\nattribute vec3 a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\nattribute vec3 a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\nattribute vec3 a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT0\nattribute vec3 a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\nattribute vec3 a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\nattribute vec3 a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\nattribute vec3 a_Target_Tangent3;\n#endif\n\n#ifdef USE_MORPHING\nuniform float u_morphWeights[WEIGHT_COUNT];\n#endif\n\n#ifdef HAS_JOINT_SET1\nattribute vec4 a_Joint1;\n#endif\n\n#ifdef HAS_JOINT_SET2\nattribute vec4 a_Joint2;\n#endif\n\n#ifdef HAS_WEIGHT_SET1\nattribute vec4 a_Weight1;\n#endif\n\n#ifdef HAS_WEIGHT_SET2\nattribute vec4 a_Weight2;\n#endif\n\n#ifdef USE_SKINNING\n#ifdef USE_SKINNING_TEXTURE\nuniform sampler2D u_jointMatrixSampler;\nuniform sampler2D u_jointNormalMatrixSampler;\n#else\nuniform mat4 u_jointMatrix[JOINT_COUNT];\nuniform mat4 u_jointNormalMatrix[JOINT_COUNT];\n#endif\n#endif\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.0)\n#define ROW1_U ((0.5 + 1.0) / 4.0)\n#define ROW2_U ((0.5 + 2.0) / 4.0)\n#define ROW3_U ((0.5 + 3.0) / 4.0)\n \n#ifdef USE_SKINNING\nmat4 getJointMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(JOINT_COUNT);\n    return mat4(\n        texture2D(u_jointMatrixSampler, vec2(ROW0_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW1_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW2_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW3_U, v)) * 2.0 - 1.0\n    );\n    #else\n    return u_jointMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getJointNormalMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(JOINT_COUNT);\n    return mat4(\n        texture2D(u_jointNormalMatrixSampler, vec2(ROW0_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointNormalMatrixSampler, vec2(ROW1_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointNormalMatrixSampler, vec2(ROW2_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointNormalMatrixSampler, vec2(ROW3_U, v)) * 2.0 - 1.0\n    );\n    #else\n    return u_jointNormalMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * getJointMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointMatrix(a_Joint1.w);\n    #endif\n\n    return skin;\n}\n\nmat4 getSkinningNormalMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * getJointNormalMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointNormalMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointNormalMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointNormalMatrix(a_Joint1.w);\n    #endif\n\n    return skin;\n}\n#endif // !USE_SKINNING\n\n#ifdef USE_MORPHING\nvec4 getTargetPosition()\n{\n    vec4 pos = vec4(0);\n\n#ifdef HAS_TARGET_POSITION0\n    pos.xyz += u_morphWeights[0] * a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\n    pos.xyz += u_morphWeights[1] * a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\n    pos.xyz += u_morphWeights[2] * a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\n    pos.xyz += u_morphWeights[3] * a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\n    pos.xyz += u_morphWeights[4] * a_Target_Position4;\n#endif\n\n    return pos;\n}\n\nvec4 getTargetNormal()\n{\n    vec4 normal = vec4(0);\n\n#ifdef HAS_TARGET_NORMAL0\n    normal.xyz += u_morphWeights[0] * a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\n    normal.xyz += u_morphWeights[1] * a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\n    normal.xyz += u_morphWeights[2] * a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\n    normal.xyz += u_morphWeights[3] * a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_NORMAL4\n    normal.xyz += u_morphWeights[4] * a_Target_Normal4;\n#endif\n\n    return normal;\n}\n\nvec4 getTargetTangent()\n{\n    vec4 tangent = vec4(0);\n\n#ifdef HAS_TARGET_TANGENT0\n    tangent.xyz += u_morphWeights[0] * a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\n    tangent.xyz += u_morphWeights[1] * a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\n    tangent.xyz += u_morphWeights[2] * a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\n    tangent.xyz += u_morphWeights[3] * a_Target_Tangent3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT4\n    tangent.xyz += u_morphWeights[4] * a_Target_Tangent4;\n#endif\n\n    return tangent;\n}\n\n#endif // !USE_MORPHING\n"},function(e,n,t){"use strict";t.r(n),n.default="#ifdef HAS_TARGET_POSITION0\nin vec3 a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\nin vec3 a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\nin vec3 a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\nin vec3 a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\nin vec3 a_Target_Position4;\n#endif\n\n#ifdef HAS_TARGET_POSITION5\nin vec3 a_Target_Position5;\n#endif\n\n#ifdef HAS_TARGET_POSITION6\nin vec3 a_Target_Position6;\n#endif\n\n#ifdef HAS_TARGET_POSITION7\nin vec3 a_Target_Position7;\n#endif\n\n#ifdef HAS_TARGET_NORMAL0\nin vec3 a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\nin vec3 a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\nin vec3 a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\nin vec3 a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT0\nin vec3 a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\nin vec3 a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\nin vec3 a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\nin vec3 a_Target_Tangent3;\n#endif\n\n#ifdef USE_MORPHING\nuniform float u_morphWeights[WEIGHT_COUNT];\n#endif\n\n#ifdef HAS_JOINT_SET1\nin vec4 a_Joint1;\n#endif\n\n#ifdef HAS_JOINT_SET2\nin vec4 a_Joint2;\n#endif\n\n#ifdef HAS_WEIGHT_SET1\nin vec4 a_Weight1;\n#endif\n\n#ifdef HAS_WEIGHT_SET2\nin vec4 a_Weight2;\n#endif\n\n#ifdef USE_SKINNING\n#ifdef USE_SKINNING_TEXTURE\nuniform sampler2D u_jointMatrixSampler;\nuniform sampler2D u_jointNormalMatrixSampler;\n#else\nuniform mat4 u_jointMatrix[JOINT_COUNT];\nuniform mat4 u_jointNormalMatrix[JOINT_COUNT];\n#endif\n#endif\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.0)\n#define ROW1_U ((0.5 + 1.0) / 4.0)\n#define ROW2_U ((0.5 + 2.0) / 4.0)\n#define ROW3_U ((0.5 + 3.0) / 4.0)\n\n#ifdef USE_SKINNING\nmat4 getJointMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(JOINT_COUNT);\n    return mat4(\n        texture(u_jointMatrixSampler, vec2(ROW0_U, v)) * 2.0 - 1.0,\n        texture(u_jointMatrixSampler, vec2(ROW1_U, v)) * 2.0 - 1.0,\n        texture(u_jointMatrixSampler, vec2(ROW2_U, v)) * 2.0 - 1.0,\n        texture(u_jointMatrixSampler, vec2(ROW3_U, v)) * 2.0 - 1.0\n    );\n    #else\n    return u_jointMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getJointNormalMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(JOINT_COUNT);\n    return mat4(\n        texture(u_jointNormalMatrixSampler, vec2(ROW0_U, v)) * 2.0 - 1.0,\n        texture(u_jointNormalMatrixSampler, vec2(ROW1_U, v)) * 2.0 - 1.0,\n        texture(u_jointNormalMatrixSampler, vec2(ROW2_U, v)) * 2.0 - 1.0,\n        texture(u_jointNormalMatrixSampler, vec2(ROW3_U, v)) * 2.0 - 1.0\n    );\n    #else\n    return u_jointNormalMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * getJointMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointMatrix(a_Joint1.w);\n    #endif\n\n    return skin;\n}\n\nmat4 getSkinningNormalMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * getJointNormalMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointNormalMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointNormalMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointNormalMatrix(a_Joint1.w);\n    #endif\n\n    return skin;\n}\n#endif // !USE_SKINNING\n\n#ifdef USE_MORPHING\nvec4 getTargetPosition()\n{\n    vec4 pos = vec4(0);\n\n#ifdef HAS_TARGET_POSITION0\n    pos.xyz += u_morphWeights[0] * a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\n    pos.xyz += u_morphWeights[1] * a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\n    pos.xyz += u_morphWeights[2] * a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\n    pos.xyz += u_morphWeights[3] * a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\n    pos.xyz += u_morphWeights[4] * a_Target_Position4;\n#endif\n\n    return pos;\n}\n\nvec4 getTargetNormal()\n{\n    vec4 normal = vec4(0);\n\n#ifdef HAS_TARGET_NORMAL0\n    normal.xyz += u_morphWeights[0] * a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\n    normal.xyz += u_morphWeights[1] * a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\n    normal.xyz += u_morphWeights[2] * a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\n    normal.xyz += u_morphWeights[3] * a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_NORMAL4\n    normal.xyz += u_morphWeights[4] * a_Target_Normal4;\n#endif\n\n    return normal;\n}\n\nvec4 getTargetTangent()\n{\n    vec4 tangent = vec4(0);\n\n#ifdef HAS_TARGET_TANGENT0\n    tangent.xyz += u_morphWeights[0] * a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\n    tangent.xyz += u_morphWeights[1] * a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\n    tangent.xyz += u_morphWeights[2] * a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\n    tangent.xyz += u_morphWeights[3] * a_Target_Tangent3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT4\n    tangent.xyz += u_morphWeights[4] * a_Target_Tangent4;\n#endif\n\n    return tangent;\n}\n\n#endif // !USE_MORPHING\n"},function(e,n,t){"use strict";t.r(n),n.default="vec3 _dFdx(vec3 coord)\n{\n#ifdef GL_OES_standard_derivatives\n    return dFdx(coord);\n#endif\n    return vec3(0.0);\n}\n\nvec3 _dFdy(vec3 coord)\n{\n#ifdef GL_OES_standard_derivatives\n    return dFdy(coord);\n#endif\n    return vec3(0.0);\n}\n\n#ifdef USE_TEX_LOD\nvec4 _textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod)\n{\n#ifdef GL_EXT_shader_texture_lod\n    return textureCubeLodEXT(sampler, coord, lod);\n#endif\n    return vec4(0.0);\n}\n#endif"},function(e,n,t){"use strict";t.r(n),n.default="// textures.glsl needs to be included\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinReflectance = 0.04;\n\nvarying vec3 v_Position;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 v_TBN;\n#else\nvarying vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nvarying vec3 v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\nvarying vec4 v_Color;\n#endif\n\nstruct AngularInfo\n{\n    float NdotL;                  // cos angle between normal and light direction\n    float NdotV;                  // cos angle between normal and view direction\n    float NdotH;                  // cos angle between normal and half vector\n    float LdotH;                  // cos angle between light direction and half vector\n\n    float VdotH;                  // cos angle between view direction and half vector\n\n    vec3 padding;\n};\n\nvec4 getVertexColor()\n{\n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef HAS_VERTEX_COLOR_VEC3\n    color.rgb = v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\n    color = v_Color;\n#endif\n\n   return color;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    vec2 UV = getNormalUV();\n\n    // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n    vec3 pos_dx = _dFdx(v_Position);\n    vec3 pos_dy = _dFdy(v_Position);\n    vec3 tex_dx = _dFdx(vec3(UV, 0.0));\n    vec3 tex_dy = _dFdy(vec3(UV, 0.0));\n    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n    vec3 ng = normalize(v_Normal);\n#else\n    vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n    t = normalize(t - ng * dot(ng, t));\n    vec3 b = normalize(cross(ng, t));\n    mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n    mat3 tbn = v_TBN;\n#endif\n\n#ifdef HAS_NORMAL_MAP\n    vec3 n = texture2D(u_NormalSampler, UV).rgb;\n    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n    // The tbn matrix is linearly interpolated, so we need to re-normalize\n    vec3 n = normalize(tbn[2].xyz);\n#endif\n\n    return n;\n}\n\nfloat getPerceivedBrightness(vec3 vector)\n{\n    return sqrt(0.299 * vector.r * vector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34\nfloat solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecularStrength) {\n    float specularBrightness = getPerceivedBrightness(specular);\n\n    if (specularBrightness < c_MinReflectance) {\n        return 0.0;\n    }\n\n    float diffuseBrightness = getPerceivedBrightness(diffuse);\n\n    float a = c_MinReflectance;\n    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;\n    float c = c_MinReflectance - specularBrightness;\n    float D = b * b - 4.0 * a * c;\n\n    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);\n}\n\nAngularInfo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)\n{\n    // Standard one-letter names\n    vec3 n = normalize(normal);           // Outward direction of surface point\n    vec3 v = normalize(view);             // Direction from surface point to view\n    vec3 l = normalize(pointToLight);     // Direction from surface point to light\n    vec3 h = normalize(l + v);            // Direction of the vector between l and v\n\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    return AngularInfo(\n        NdotL,\n        NdotV,\n        NdotH,\n        LdotH,\n        VdotH,\n        vec3(0, 0, 0)\n    );\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="// textures.glsl needs to be included\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinReflectance = 0.04;\n\nin vec3 v_Position;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 v_TBN;\n#else\nin vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nin vec3 v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\nin vec4 v_Color;\n#endif\n\nstruct AngularInfo\n{\n    float NdotL;                  // cos angle between normal and light direction\n    float NdotV;                  // cos angle between normal and view direction\n    float NdotH;                  // cos angle between normal and half vector\n    float LdotH;                  // cos angle between light direction and half vector\n\n    float VdotH;                  // cos angle between view direction and half vector\n\n    vec3 padding;\n};\n\nvec4 getVertexColor()\n{\n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef HAS_VERTEX_COLOR_VEC3\n    color.rgb = v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\n    color = v_Color;\n#endif\n\n   return color;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    vec2 UV = getNormalUV();\n\n    // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n    vec3 pos_dx = dFdx(v_Position);\n    vec3 pos_dy = dFdy(v_Position);\n    vec3 tex_dx = dFdx(vec3(UV, 0.0));\n    vec3 tex_dy = dFdy(vec3(UV, 0.0));\n    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n    vec3 ng = normalize(v_Normal);\n#else\n    vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n    t = normalize(t - ng * dot(ng, t));\n    vec3 b = normalize(cross(ng, t));\n    mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n    mat3 tbn = v_TBN;\n#endif\n\n#ifdef HAS_NORMAL_MAP\n    vec3 n = texture(u_NormalSampler, UV).rgb;\n    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n    // The tbn matrix is linearly interpolated, so we need to re-normalize\n    vec3 n = normalize(tbn[2].xyz);\n#endif\n\n    return n;\n}\n\nfloat getPerceivedBrightness(vec3 vector)\n{\n    return sqrt(0.299 * vector.r * vector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34\nfloat solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecularStrength) {\n    float specularBrightness = getPerceivedBrightness(specular);\n\n    if (specularBrightness < c_MinReflectance) {\n        return 0.0;\n    }\n\n    float diffuseBrightness = getPerceivedBrightness(diffuse);\n\n    float a = c_MinReflectance;\n    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;\n    float c = c_MinReflectance - specularBrightness;\n    float D = b * b - 4.0 * a * c;\n\n    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);\n}\n\nAngularInfo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)\n{\n    // Standard one-letter names\n    vec3 n = normalize(normal);           // Outward direction of surface point\n    vec3 v = normalize(view);             // Direction from surface point to view\n    vec3 l = normalize(pointToLight);     // Direction from surface point to light\n    vec3 h = normalize(l + v);            // Direction of the vector between l and v\n\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    return AngularInfo(\n        NdotL,\n        NdotV,\n        NdotH,\n        LdotH,\n        VdotH,\n        vec3(0, 0, 0)\n    );\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#ifdef USE_SHADOW_MAPPING\nvarying vec4 v_PositionLightSpace;\n#endif\n\nfloat linstep(float low, float high, float v)\n{\n    return clamp((v-low) / (high-low), 0.0, 1.0);\n}\n\n#ifdef USE_SHADOW_MAPPING\nfloat getShadowContribution()\n{\n    vec3 coords = v_PositionLightSpace.xyz / v_PositionLightSpace.w * 0.5 + 0.5;\n    if (coords.z < 0.01 || coords.z > 0.99 || coords.x < 0.01 || coords.x > 0.99 || coords.y < 0.01 || coords.y > 0.99) {\n        return 1.0;\n    }\n    vec2 moments = vec2(1.0) - texture2D(u_ShadowSampler, coords.xy).xy;\n    float p = step(coords.z, moments.x);\n    float variance = max(moments.y - moments.x * moments.x, 0.00002);\n    float d = coords.z - moments.x;\n    float pMax = linstep(0.2, 1.0, variance / (variance + d*d));\n    return min(max(p, pMax), 1.0);\n}\n#endif"},function(e,n,t){"use strict";t.r(n),n.default="#ifdef USE_SHADOW_MAPPING\nin vec4 v_PositionLightSpace;\n#endif\n\nfloat linstep(float low, float high, float v)\n{\n    return clamp((v-low) / (high-low), 0.0, 1.0);\n}\n\n#ifdef USE_SHADOW_MAPPING\nfloat getShadowContribution()\n{\n    vec3 coords = v_PositionLightSpace.xyz / v_PositionLightSpace.w * 0.5 + 0.5;\n    if (coords.z < 0.01 || coords.z > 0.99 || coords.x < 0.01 || coords.x > 0.99 || coords.y < 0.01 || coords.y > 0.99) {\n        return 1.0;\n    }\n    vec2 moments = vec2(1.0) - texture(u_ShadowSampler, coords.xy).xy;\n    float p = step(coords.z, moments.x);\n    float variance = max(moments.y - moments.x * moments.x, 0.00002);\n    float d = coords.z - moments.x;\n    float pMax = linstep(0.2, 1.0, variance / (variance + d*d));\n    return min(max(p, pMax), 1.0);\n}\n#endif"},function(e,n,t){"use strict";t.r(n),n.default="varying vec2 v_UVCoord1;\nvarying vec2 v_UVCoord2;\n\n// General Material\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\nuniform int u_NormalUVSet;\nuniform mat3 u_NormalUVTransform;\n#endif\n\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D u_EmissiveSampler;\nuniform int u_EmissiveUVSet;\nuniform vec3 u_EmissiveFactor;\nuniform mat3 u_EmissiveUVTransform;\n#endif\n\n#ifdef HAS_OCCLUSION_MAP\nuniform sampler2D u_OcclusionSampler;\nuniform int u_OcclusionUVSet;\nuniform float u_OcclusionStrength;\nuniform mat3 u_OcclusionUVTransform;\n#endif\n\n// Metallic Roughness Material\n#ifdef HAS_BASE_COLOR_MAP\nuniform sampler2D u_BaseColorSampler;\nuniform int u_BaseColorUVSet;\nuniform mat3 u_BaseColorUVTransform;\n#endif\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\nuniform sampler2D u_MetallicRoughnessSampler;\nuniform int u_MetallicRoughnessUVSet;\nuniform mat3 u_MetallicRoughnessUVTransform;\n#endif\n\n// Specular Glossiness Material\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D u_DiffuseSampler;\nuniform int u_DiffuseUVSet;\nuniform mat3 u_DiffuseUVTransform;\n#endif\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\nuniform sampler2D u_SpecularGlossinessSampler;\nuniform int u_SpecularGlossinessUVSet;\nuniform mat3 u_SpecularGlossinessUVTransform;\n#endif\n\n// IBL\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\n#endif\n\n#ifdef USE_SHADOW_MAPPING\nuniform sampler2D u_ShadowSampler;\n#endif\n\nvec2 getNormalUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_NORMAL_MAP\n    uv.xy = u_NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_NORMAL_UV_TRANSFORM\n    uv *= u_NormalUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getEmissiveUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_EMISSIVE_MAP\n    uv.xy = u_EmissiveUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_EMISSIVE_UV_TRANSFORM\n    uv *= u_EmissiveUVTransform;\n    #endif\n#endif\n\n    return uv.xy;\n}\n\nvec2 getOcclusionUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_OCCLUSION_MAP\n    uv.xy = u_OcclusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_OCCLSION_UV_TRANSFORM\n    uv *= u_OcclusionUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getBaseColorUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_BASE_COLOR_MAP\n    uv.xy = u_BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_BASECOLOR_UV_TRANSFORM\n    uv *= u_BaseColorUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getMetallicRoughnessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    uv.xy = u_MetallicRoughnessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM\n    uv *= u_MetallicRoughnessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getSpecularGlossinessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    uv.xy = u_SpecularGlossinessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\n    uv *= u_SpecularGlossinessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getDiffuseUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_DIFFUSE_MAP\n    uv.xy = u_DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_DIFFUSE_UV_TRANSFORM\n    uv *= u_DiffuseUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="in vec2 v_UVCoord1;\nin vec2 v_UVCoord2;\n\n// General Material\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\nuniform int u_NormalUVSet;\nuniform mat3 u_NormalUVTransform;\n#endif\n\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D u_EmissiveSampler;\nuniform int u_EmissiveUVSet;\nuniform vec3 u_EmissiveFactor;\nuniform mat3 u_EmissiveUVTransform;\n#endif\n\n#ifdef HAS_OCCLUSION_MAP\nuniform sampler2D u_OcclusionSampler;\nuniform int u_OcclusionUVSet;\nuniform float u_OcclusionStrength;\nuniform mat3 u_OcclusionUVTransform;\n#endif\n\n// Metallic Roughness Material\n#ifdef HAS_BASE_COLOR_MAP\nuniform sampler2D u_BaseColorSampler;\nuniform int u_BaseColorUVSet;\nuniform mat3 u_BaseColorUVTransform;\n#endif\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\nuniform sampler2D u_MetallicRoughnessSampler;\nuniform int u_MetallicRoughnessUVSet;\nuniform mat3 u_MetallicRoughnessUVTransform;\n#endif\n\n// Specular Glossiness Material\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D u_DiffuseSampler;\nuniform int u_DiffuseUVSet;\nuniform mat3 u_DiffuseUVTransform;\n#endif\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\nuniform sampler2D u_SpecularGlossinessSampler;\nuniform int u_SpecularGlossinessUVSet;\nuniform mat3 u_SpecularGlossinessUVTransform;\n#endif\n\n// IBL\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\n#endif\n\n#ifdef USE_SHADOW_MAPPING\nuniform sampler2D u_ShadowSampler;\n#endif\n\nvec2 getNormalUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_NORMAL_MAP\n    uv.xy = u_NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_NORMAL_UV_TRANSFORM\n    uv *= u_NormalUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getEmissiveUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_EMISSIVE_MAP\n    uv.xy = u_EmissiveUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_EMISSIVE_UV_TRANSFORM\n    uv *= u_EmissiveUVTransform;\n    #endif\n#endif\n\n    return uv.xy;\n}\n\nvec2 getOcclusionUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_OCCLUSION_MAP\n    uv.xy = u_OcclusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_OCCLSION_UV_TRANSFORM\n    uv *= u_OcclusionUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getBaseColorUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_BASE_COLOR_MAP\n    uv.xy = u_BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_BASECOLOR_UV_TRANSFORM\n    uv *= u_BaseColorUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getMetallicRoughnessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    uv.xy = u_MetallicRoughnessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM\n    uv *= u_MetallicRoughnessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getSpecularGlossinessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    uv.xy = u_SpecularGlossinessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\n    uv *= u_SpecularGlossinessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getDiffuseUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_DIFFUSE_MAP\n    uv.xy = u_DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_DIFFUSE_UV_TRANSFORM\n    uv *= u_DiffuseUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="uniform float u_Exposure;\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\n// linear to sRGB approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec3 LINEARtoSRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\n// sRGB to linear approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\n// Uncharted 2 tone map\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapUncharted2Impl(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\n\nvec3 toneMapUncharted(vec3 color)\n{\n    const float W = 11.2;\n    color = toneMapUncharted2Impl(color * 2.0);\n    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\n    return LINEARtoSRGB(color * whiteScale);\n}\n\n// Hejl Richard tone map\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapHejlRichard(vec3 color)\n{\n    color = max(vec3(0.0), color - vec3(0.004));\n    return (color*(6.2*color+.5))/(color*(6.2*color+1.7)+0.06);\n}\n\n// ACES tone map\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return LINEARtoSRGB(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0));\n}\n\nvec3 toneMap(vec3 color)\n{\n    color *= u_Exposure;\n\n#ifdef TONEMAP_UNCHARTED\n    return toneMapUncharted(color);\n#endif\n\n#ifdef TONEMAP_HEJLRICHARD\n    return toneMapHejlRichard(color);\n#endif\n\n#ifdef TONEMAP_ACES\n    return toneMapACES(color);\n#endif\n\n    return LINEARtoSRGB(color);\n}\n"},function(e,n,t){var r={"./primitive.webgl1.vert":32,"./primitive.webgl2.vert":33};function o(e){var n=i(e);return t(n)}function i(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=i,e.exports=o,o.id=61},function(e,n,t){var r={"./metallic-roughness.webgl1.frag":30,"./metallic-roughness.webgl2.frag":31};function o(e){var n=i(e);return t(n)}function i(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=i,e.exports=o,o.id=62},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(16),o=function(){function e(){}return e.prototype.enableJointMatrixTextures=function(e){this._jointMatrixTexture||(this._jointMatrixTexture=new r.StandardMaterialMatrixTexture(e)),this._jointNormalTexture||(this._jointNormalTexture=new r.StandardMaterialMatrixTexture(e))},e.prototype.destroy=function(){var e,n;null===(e=this._jointNormalTexture)||void 0===e||e.destroy(!0),null===(n=this._jointMatrixTexture)||void 0===n||n.destroy(!0)},e.prototype.update=function(e,n){if(e.skin){var t=e.skin.calculateJointMatrices(),r=t.jointVertexMatrices,o=t.jointNormalMatrices;this._jointMatrixTexture?(this._jointMatrixTexture.updateBuffer(r),n.uniforms.u_jointMatrixSampler=this._jointMatrixTexture):n.uniforms.u_jointMatrix=r,this._jointNormalTexture?(this._jointNormalTexture.updateBuffer(o),n.uniforms.u_jointNormalMatrixSampler=this._jointNormalTexture):n.uniforms.u_jointNormalMatrix=o}},e}();n.StandardMaterialSkinUniforms=o},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(7);!function(e){e.create=function(){return Object.assign(new r.MeshGeometry3D,{positions:{buffer:new Float32Array([-1,1,0,1,-1,0,-1,-1,0,1,1,0])},indices:{buffer:new Uint8Array([0,2,1,0,1,3])},normals:{buffer:new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1])},uvs:[{buffer:new Float32Array([0,0,1,1,0,1,1,0])}]})}}(n.QuadGeometry||(n.QuadGeometry={}))},function(e,n,t){"use strict";var r,o=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(10),s=t(74),u=t(75),l=t(34),f=t(6),c=t(1),d=t(13),_=t(7),p=t(18),h=t(25),m=t(37),g=t(38),v=function(){function e(e,n){this._asset=e,this._materialFactory=n||d.StandardMaterial,this._descriptor=this._asset.descriptor}return e.createModel=function(n,t){return new e(n,t).parseModel()},e.createMesh=function(n,t,r){return void 0===r&&(r=0),new e(n,t).parseMesh(r)},e.prototype.parseBuffer=function(e){if(void 0!==e){"number"==typeof e&&(e=this._asset.descriptor.accessors[e]);var n=this._descriptor.bufferViews[e.bufferView||0],t=e.byteOffset||0;void 0!==n.byteOffset&&(t+=n.byteOffset);var r=e.count*S[e.type];void 0!==n.byteStride&&(r*=n.byteStride/y[e.componentType]/S[e.type]);var o=this._asset.buffers[n.buffer];return u.glTFBufferView.from(e.componentType,o,t,r,n.byteStride)}},e.prototype.parseAnimation=function(e,n){var t,r;"number"==typeof e&&(e=this._asset.descriptor.animations[e]);var i=[];try{for(var u=o(e.channels),l=u.next();!l.done;l=u.next()){var f=l.value,c=e.samplers[f.sampler],d=this.parseBuffer(c.input);if(void 0!==d){var _=this.parseBuffer(c.output);if(void 0!==_){var p=a.glTFChannel.from(d.buffer,_.buffer,c.interpolation||"LINEAR",f.target.path,n[f.target.node]);p&&i.push(p)}}}}catch(e){t={error:e}}finally{try{l&&!l.done&&(r=u.return)&&r.call(u)}finally{if(t)throw t.error}}return new s.glTFAnimation(i,e.name)},e.prototype.parseMaterial=function(e){"number"==typeof e&&(e=this._asset.descriptor.materials[e]);var n=new l.glTFMaterial;if(!e)return this._materialFactory.create(n);n.occlusionTexture=this.parseTexture(e.occlusionTexture),n.normalTexture=this.parseTexture(e.normalTexture),n.emissiveTexture=this.parseTexture(e.emissiveTexture),void 0!==e.doubleSided&&(n.doubleSided=e.doubleSided),e.emissive&&(n.emissive=e.emissive),e.alphaMode&&(n.alphaMode=e.alphaMode),void 0!==e.alphaCutoff&&(n.alphaCutoff=e.alphaCutoff);var t=e.pbrMetallicRoughness;return n.metallicRoughnessTexture=this.parseTexture(null==t?void 0:t.metallicRoughnessTexture),(null==t?void 0:t.baseColorFactor)&&(n.baseColor=t.baseColorFactor),n.baseColorTexture=this.parseTexture(null==t?void 0:t.baseColorTexture),n.baseColorTexture&&(n.baseColorTexture.baseTexture.alphaMode=i.ALPHA_MODES.PREMULTIPLIED_ALPHA),void 0!==(null==t?void 0:t.metallicFactor)&&(n.metallic=t.metallicFactor),void 0!==(null==t?void 0:t.roughnessFactor)&&(n.roughness=t.roughnessFactor),e.extensions&&(n.unlit=null!=e.extensions.KHR_materials_unlit),this._materialFactory.create(n)},e.prototype.parseTexture=function(e){if(void 0!==e)return"number"==typeof e&&(e={index:e}),this._asset.images[this._descriptor.textures[e.index].source]},e.prototype.parseMesh=function(e){var n=this;"number"==typeof e&&(e=this._asset.descriptor.meshes[e]);var t=e.weights||[];return e.primitives.map((function(r){return Object.assign(n.parsePrimitive(r),{name:e.name,morphWeights:t})}))},e.prototype.parseSkin=function(e,n,t){"number"==typeof e&&(e=this._asset.descriptor.skins[e]);var r=this.parseBuffer(e.inverseBindMatrices),o=[];if(r)for(var i=0;i<e.joints.length;i++)o.push(new g.Joint(t[e.joints[i]],r.buffer.slice(16*i,16*i+16)));return new m.Skin(n,o)},e.prototype.parsePrimitive=function(e){for(var n,t=e.attributes,r=e.targets,o=Object.assign(new _.MeshGeometry3D,{indices:this.parseBuffer(e.indices),positions:this.parseBuffer(t.POSITION),normals:this.parseBuffer(t.NORMAL),tangents:this.parseBuffer(t.TANGENT),joints:this.parseBuffer(t.JOINTS_0),weights:this.parseBuffer(t.WEIGHTS_0)}),i=0;;i++){var a=this.parseBuffer(t["TEXCOORD_"+i]);if(void 0===a)break;o.uvs=o.uvs||[],o.uvs.push(a)}if(r)for(i=0;i<r.length;i++)o.targets=o.targets||[],o.targets.push({positions:this.parseBuffer(r[i].POSITION),normals:this.parseBuffer(r[i].NORMAL),tangents:this.parseBuffer(r[i].TANGENT)});return n=void 0!==e.material?this.parseMaterial(this._asset.descriptor.materials[e.material]):this.parseMaterial(),new f.Mesh3D(o,n)},e.prototype.parseNode=function(e){"number"==typeof e&&(e=this._asset.descriptor.nodes[e]);var n=Object.assign(new c.Container3D,{name:e.name});return e.translation&&n.position.set(e.translation[0],e.translation[1],e.translation[2]),e.rotation&&n.rotationQuaternion.set(e.rotation[0],e.rotation[1],e.rotation[2],e.rotation[3]),e.scale&&n.scale.set(e.scale[0],e.scale[1],e.scale[2]),e.matrix&&n.transform.setFromMatrix(new h.TransformMatrix(e.matrix)),n},e.prototype.parseModel=function(){var e,n,t,r,i=this,a=this._descriptor.nodes.map((function(e){return i.parseNode(e)})),s=this._descriptor.scenes[this._asset.descriptor.scene||0],u=new p.Model,l=function(e,n){var t,r,s,f,c,d=i._asset.descriptor.nodes[n].mesh;if(void 0!==i._asset.descriptor.nodes[n].skin&&(c=i.parseSkin(i._asset.descriptor.nodes[n].skin,a[n],a)),void 0!==d)try{for(var _=o(i.parseMesh(d)),p=_.next();!p.done;p=_.next()){var h=p.value;u.meshes.push(a[n].addChild(h)),u.meshes[u.meshes.length-1].skin=c}}catch(e){t={error:e}}finally{try{p&&!p.done&&(r=_.return)&&r.call(_)}finally{if(t)throw t.error}}if(e.addChild(a[n]),i._asset.descriptor.nodes[n].children)try{for(var m=o(i._asset.descriptor.nodes[n].children),g=m.next();!g.done;g=m.next()){var v=g.value;l(a[n],v)}}catch(e){s={error:e}}finally{try{g&&!g.done&&(f=m.return)&&f.call(m)}finally{if(s)throw s.error}}};try{for(var f=o(s.nodes),c=f.next();!c.done;c=f.next()){var d=c.value;l(u,d)}}catch(n){e={error:n}}finally{try{c&&!c.done&&(n=f.return)&&n.call(f)}finally{if(e)throw e.error}}if(this._asset.descriptor.animations)try{for(var _=o(this._asset.descriptor.animations),h=_.next();!h.done;h=_.next()){var m=h.value;u.animations.push(this.parseAnimation(m,a))}}catch(e){t={error:e}}finally{try{h&&!h.done&&(r=_.return)&&r.call(_)}finally{if(t)throw t.error}}return u},e}();n.glTFParser=v;var S={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},y=((r={})[5120]=1,r[5121]=1,r[5122]=2,r[5123]=2,r[5125]=4,r[5126]=4,r)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t){var r=e.call(this)||this;return r._output=n,r._stride=t,r._data=new Float32Array(t),r}return o(n,e),n.prototype.interpolate=function(e,n){for(var t=(e+0)*this._stride,r=(e+1)*this._stride,o=0;o<this._stride;o++)this._output.length>r?this._data[o]=(1-n)*this._output[t+o]+n*this._output[r+o]:this._data[o]=this._output[t+o];return this._data},n}(t(11).glTFInterpolation);n.glTFLinear=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this)||this;return o._input=n,o._output=t,o._stride=r,o._data=new Float32Array(r),o}return o(n,e),n.prototype.interpolate=function(e,t){for(var r=this._input[e+1]-this._input[e],o=(e+0)*this._stride*3,i=(e+1)*this._stride*3,a=0;a<this._stride;a++)this._data[a]=n.calculate(t,this._output[o+a+1*this._stride],this._output[i+a+1*this._stride],r*this._output[i+a],r*this._output[o+a+2*this._stride]);return this._data},n.calculate=function(e,n,t,r,o){return(2*Math.pow(e,3)-3*Math.pow(e,2)+1)*n+(Math.pow(e,3)-2*Math.pow(e,2)+e)*r+(-2*Math.pow(e,3)+3*Math.pow(e,2))*t+(Math.pow(e,3)-Math.pow(e,2))*o},n}(t(11).glTFInterpolation);n.glTFCubicSpline=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t){var r=e.call(this)||this;return r._output=n,r._stride=t,r._data=new Float32Array(t),r}return o(n,e),n.prototype.interpolate=function(e){for(var n=0;n<this._stride;n++)this._data[n]=this._output[e*this._stride+n];return this._data},n}(t(11).glTFInterpolation);n.glTFStep=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(4),a=function(e){function n(n){var t=e.call(this)||this;return t._output=n,t._data=new Float32Array(4),t}return o(n,e),n.prototype.interpolate=function(e,n){var t=4*(e+0),r=4*(e+1),o=i.Quat.set(this._output[t],this._output[t+1],this._output[t+2],this._output[t+3],new Float32Array(4));if(this._output.length<=r)return i.Quat.normalize(o,this._data);var a=i.Quat.set(this._output[r],this._output[r+1],this._output[r+2],this._output[r+3],new Float32Array(4));return i.Quat.normalize(i.Quat.slerp(o,a,n,this._data),this._data)},n}(t(11).glTFInterpolation);n.glTFSphericalLinear=a},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this,t,r)||this;return o._transform=n,o}return o(n,e),n.prototype.updateTarget=function(e){this._transform.scale.set(e[0],e[1],e[2])},n}(t(10).glTFChannel);n.glTFScale=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this,t,r)||this;return o._weights=n,o}return o(n,e),n.prototype.updateTarget=function(e){for(var n=0;n<e.length;n++)this._weights[n]=e[n]},n}(t(10).glTFChannel);n.glTFWeights=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this,t,r)||this;return o._transform=n,o}return o(n,e),n.prototype.updateTarget=function(e){this._transform.rotationQuaternion.set(e[0],e[1],e[2],e[3])},n}(t(10).glTFChannel);n.glTFRotation=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this,t,r)||this;return o._transform=n,o}return o(n,e),n.prototype.updateTarget=function(e){this._transform.position.set(e[0],e[1],e[2])},n}(t(10).glTFChannel);n.glTFTranslation=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),i=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var a=function(e){function n(n,t){var r,o,a=e.call(this,t)||this;a._duration=0,a._position=0,a._channels=[];try{for(var s=i(n),u=s.next();!u.done;u=s.next()){var l=u.value;a._duration=Math.max(a._duration,l.duration)}}catch(e){r={error:e}}finally{try{u&&!u.done&&(o=s.return)&&o.call(s)}finally{if(r)throw r.error}}return a._channels=n,a}return o(n,e),Object.defineProperty(n.prototype,"duration",{get:function(){return this._duration},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"position",{get:function(){return this._position},set:function(e){var n,t;this._position=e;try{for(var r=i(this._channels),o=r.next();!o.done;o=r.next()){o.value.position=this._position}}catch(e){n={error:e}}finally{try{o&&!o.done&&(t=r.return)&&t.call(r)}finally{if(n)throw n.error}}},enumerable:!0,configurable:!0}),n}(t(36).Animation);n.glTFAnimation=a},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,n,t){void 0===t&&(t=0),this.buffer=e,this.componentType=n,this.stride=t}return e.from=function(n,t,r,o,i){switch(n){case 5125:return new e(new Uint32Array(t,r,o),n,i);case 5126:return new e(new Float32Array(t,r,o),n,i);case 5120:return new e(new Int8Array(t,r,o),n,i);case 5121:return new e(new Uint8Array(t,r,o),n,i);case 5122:return new e(new Int16Array(t,r,o),n,i);case 5123:return new e(new Uint16Array(t,r,o),n,i);default:throw new Error('PIXI3D: Unknown component type "'+n+'".')}},e}();n.glTFBufferView=r},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(1),a=t(8),s=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.type=a.LightType.point,n.color=[1,1,1],n.range=10,n.intensity=10,n.innerConeAngle=0,n.outerConeAngle=45,n}return o(n,e),n}(i.Container3D);n.Light=s},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=function(){function e(e,n,o){this._diffuse=e,this._brdf=o||r.Texture.from(t(78).default),this._specular=n}return Object.defineProperty(e.prototype,"diffuse",{get:function(){return this._diffuse},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"brdf",{get:function(){return this._brdf},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"specular",{get:function(){return this._specular},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"valid",{get:function(){return this._diffuse.valid&&this._specular.valid&&this._brdf.valid},enumerable:!0,configurable:!0}),e}();n.ImageBasedLighting=o},function(e,n,t){"use strict";t.r(n),n.default="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wsXDggToON7ZwAAFfZJREFUeNrNXWuv2zqSrKaU3ExwL7DA/Pv9pQvEIveD+OgnRck+Z8Y4MCiKkq2q6uomJSf0v3//lV+vQlSAUlAQ/BUUALIT8QB4w0SjBP2toTrte7irjMPd93nn4t71Abyh2q+cd7xe5XVYrO0fvH7FwTXuvBFzcBv0hfeVXY/7nzFBwE5ERABAHTsKOKBxApJA1x6qmPa9xMaQbPTxdjBN3xUfasDYW8TIiIBvQ9wNggzsBFABkRgRvhoG/WplN2+5x13vUFivfB33EGLsOtwzttxNeP2PG4oJDt1OBOIdF4DVXTOApuBpmFpg+SAuBMQkUC47J5ufwhrTTtQIuItjE1d43KKAg89aOXqJAwKVVcl/UOmLnZIA96Kv4mAdU9XnxgGVG/JfHcY4mMN9C+KogQXVxxHwaQ6IRkU4OYHKHxHWt6xGwEoglrfmKK9gvWg10QC1KS3oEQeP88Hi+LvnmB9uozBKAGoXvL2TTsTRI5OwcqUv8CLXW9zTrOSPlUoGKkRY0nrHZ2itE1PJGwuyVdBNDnqMX2C2/LpV3sw3B7IElBugT/Yuthd3BVXQAgcioT/KyQ8Gz/3EBoSwApkMLL7vgz4hIOqpBDgqvhMHXWLrsNrhQrlmGjXXO64iANND4EUGPHpUewJ6AdICJSMCuvmu52Rd1d6PA7eytIMnBeicA4WpMiKFF7wgmKBvM2qZbl4Q0L+4uMjlOChmPuHPPm560WRyEEEPM0Z8GWZE8JjAVLYrrnKrxyRhY/RqLjOGQasJ8gonsK7XOWBxeWlB8CIAUTRIOFZcZRHc9WEE7DAIWoDUNPVazu/l5EVnm3+IncSBkcqDAJK8+ablyTUZW9dEXzVYiiBzEOsRn+GV2G9y4C5UTGZ8l/MgWOGb5awH9j25vnIFwDmATgLgcnDVc30xVxe56EWcA6ffO9ndSuYWvoues7ILKgkXD3GacgCJtTbZOF1PBkwI6U5IV5KPNu13i5zEmR4tALrOBFUCaNyNITjmo1ixqNnrsTKfXA+m0nbtO8q6l7jrAc3ZFOi3UvRdhtQrzgHBZmk9ZDgobuf9OdrFKFMRrMgfU0zhHRsBGiopPiS6HIgqSKGshO+VRjC3ZYpXs77JQVTPIG4jNhYNYhS4mHV+8DWSsCq61aXbgD0HOCVQMFUOuVngQPNhJgeInQextPneFV3bo9556Rxg4XM3+z0Wkj0kPce/Zynl5syPLidxJuXMvy//qlFpqKJzEdlbhE0GNwvisrVa8sJC5G1565VzYPsnl6jKzXCM98Xm2u/9FJ/0WSg8OwRqHjABWn2/c5O4NUEscl3GgZurRdtwEE4TZQUFw906NAVIj3C8RBlTD5RrQWc9Gs1teMVGAAQN50nUbMAPDjhzNOeLX3lBdy1dJUtYVz7k9ozkCm5aGAaxFsSsfDK/POmxEzdioaDSspt7xZdd4yAaPq9SLiOAFnrWob+1tyXhvs19JuIA+lkH51afSct93zzr+iSVeYf3DWMgLlz+Kj/d3UULnTuaBfFlwgkHapidnRbolAA5Tbs9VY4voMiT3Dr2Maz8A1cgdjt7RdAioINIsxwAply7yY0e3hNRyvrD2tde6ApGT008OsktXSNgV5Fk2zskZFBpbepFonSzD8O6a2em4OP9kJ92G9mncTDftRI38x63PSZiIC3kyUzflkk2AxdLqqwdfd+flEaP1H03A0czFYqPWsc9+rgWAR3KBfkLFauUe06qi+AA3nJFKfo7XUzTFtUdDIukrSwiTY9aZ2JlU0fAgF7J39W7bBObAZwjRQLwpqx2AeCdfOD6+IpRrCO+uOvusF186QaluNqFtFziTfQMAYOLXVm6w8HMr68KUzKnFNbsUbiC8sp4nQN6cxT4FvomXZJy1rcJ1fP4fGIhL2x0RlhPOaCVOLhpII8xpbW9ve0kYW4dOhO48uflTbB6YQshyI+4xnri5it5MjCiVZGaw99Bf9IYEYAr+Yedqv6RaRneXeVieuaAOv0r+AZ+tSjVB2jeIqZZEOuuCeBK/itlUgnygYUm4qB3hhDP974hzzfhXhygcwDaTLg4SzbXHPAcwM85OICE2Moz4IDi4Lhut8OfgCsJdsF9k4yiImDmQiu+pPiQ1+DY0UpkmE7XZG7h+/EBz8Y7ESAaHvThYpHyH+gZw/gSCk3PixzJT4D2dCoa94W8iO9HTrLrDnHfJCRjVD5BWh4FlQFde7dXF61wcEN3yxzozscHLo8ZEVDYSlxpeq//bEFHPIJ+OlvmY4pEMwJXcTAR+9ys13FZP/zuSeZjdt3dJG+nAqpHSHuhNLLCJ8+L3AEUD7uUKsmz3YL+/QGXR+2g9hhEq39K7ELFQB+tIFF0cw0MQYWaCosIbnbUZyH2373TXn7KIiWlW1CBQL/bTm2U8ayK5WAEhOwku6xk/cekaFrh4D0o58M+8EFrPJ3rgCIJ6wjoYEnQBRmyoeF2Papt+qBbxQWsuMmAyrvA2dO+ifXkvQB76Z9wGQGB+TgLR24a8PzHhzjmYO4Mqt+5Zs++Lsn47Lsm4ESwoP6BQdfR58IfUQLRWJypUdDWgFqkJEkzDmLsJmL/Bujdj5BVUBllKE/FxaLPClOARU87FXnEdM9x/cdyoPBdlWo7vz9mvnd6yPxzH/BXLahGgPEclYG7EYURwFQ/HvjpVhPl3oAD6+mTsLiU/DwIbsXNA6BnBJyn6dCjG1GR1lTEHE1EwMLCUSeDoDvJa1vQOeLXHKiTvEfD1xJQ+jygyVdAL3Ef72ChwDa56guCKojz4XHAQXcpsYjfa6y50GNW7IBpBEDDzecEKiV0uKPJWukal/0C9/bhM+0bCc/a7uArnu4CfTcOIuh5/yhDu9V0DjIME13EZrmCiHVa4XMy0HCRHFg/6SRZ1asQ4SeZQ2yxWHenZ+lhEhNpWBBYEjZMwKQBmPex9NbiwzEfq/qOI/cELw4UxD4HMJuKNg7EdyWJaMDZSKIKKqbBcC9K9VzaaLruj7ZR5aBvgjUgOdCNqzYhwH3NtVa0/3F3ciOg5QAy2g+C4HwViTua2EuLgNLIuMgEHa8OqxcHrrrJ8GEHOPxdYf0R3C+jgb8XYM+MgFyQqTbCGrTh3j2n9PqnP5dIjAM4ZJA0JRUH2n9MMnA5cGzKEHML/U/5zyQ4RARkV/4sCIb8PfRF/dPtSEbAcCEJLg8Iq9kVIwp9aRIfb5ez78gfQDr/7ehCKEn8a90Zgg/wIJi/JDEKfa33Bj1J6IXkOdaR4cxjwu15lAbuIs69PnqvSTjTAP00nyxD4TxC1aBa/sx5eBUk7Ejp3ap+wkoUEG1h/VZMvGk+t4JgMjIDe0nSggi5tM2+5NCCYJzSe1GLEjHKlq22s1GioE+tJ6ldkzYukvMkBzwz/Wc5AEDSZWgQAfAqH27lXf717N5EwXUh8uKgN5KL3QK40VGLQfCluNuT7Pm0IELONeuOCODVp4wmV/4gnaUh/YfsBK25mW84C0ak2ousID7qe9DHyAHNgkpCLsi2HJJ+UvrvmSDNfUKPGw0sDiwHyQuL04jSCtbzKVvc+W3aR88BmZAZ9JYAHgHcwIf2TX5Wwh/csDg4N30OPBAvHWkd9Fv+E1nHY9Wr89QcoNDXNaiUsiWBTH7W8WETeLcjy8FCNIRJIgKdgOLUS4s0fBb33pmAPacWAfmagAme/DVmxR7WIeLtPTEOEiTiVubRvOxqMeNZBHwEd2FB5zygADmhZEEAzC8pHNzdJTmbHiT6kJ4TadZhQu29sv457ovQv2/3LivVgnJCJhxABo6EXFohVNo6c1c+g9SVvwGcMSEJ63oHgeAEgUoGggmDsutFn4X+I7bDYWAEEHJC8SwI1n+CH8gRRoGkFyFkcBBEHIi1h8CIkge0sKOr1SEs0HAL+ruIR5syApLgQGi/GDxJkGMqe8m2e1OsZwKwTGsioOcAy8dE/hWjqSMh7tRYl3DvCu4LBPQkfDYKSkY5cwTHsd1g6VeOdpE9YWj0FeIQoOs7Ym4Z6gbB2lT50n8mfEzkf5eAyeawoJxxnO+ok7JS5H9AwBLmCXNuHBQmc651/mEqDsQ8AHHpKct8Jwgm1VH7tFF6Brch16F/4PvzgKgRcFBDPyFnPQur8uwu1GakwHhgtBuVY/58Lsagh2viEvcTaJV1dSa4+YegcRfudclPhgkLOjBcqJZAjQcut6H9VqSWnpyL/mDn1b1I8tFDIc3JUCGyzAQWOIiE/KbkhQ1IMAYBR0YmHQF9UIEAAkAmpK59+b+vwnxGB3rgDmY+CFd+VBAkSQZ58fEmB2+KPULc5eBs7EfCkZCBAzhyXZIrzIaovZ9XmwtSmyLU/49WTdbI44EL37Ii0U9ePrDFqC6HvKoUCzSscLC4edmvxrQckHCgzsVqCaQk3Dw+l5aYT9UXnTDQskJSZwC7Ee+GAsIgEPmWB0E0SY4Rf5YGngG9eOx+nBYE5NIsKDH3739NdJmAUv2nNDLAc4b8JNUeMy/Zk04JG1Pi8ldpIII+ukOJmIMZE0V3RnKOdk32jgg40T9ynRX3GUC91AI6QS91xlvl33D3Zsf6k8T188TOmEgsN4x8q9C3/uOtC/XYdZfk1oNgUe+POdiPhIPwai5UTgtKwvrrV+zaZ4jXCMhs0/vSloPEA8KFkrVnSfiO/8xxd1Auq0zcIoN/3H5sODaWAzJKEuk3Mflz7fMIQBJ5GwWUfQ7En6qOlB0pr/cW41bmAVgm4M0g4PiucMMiIOEojQBUTEmWQANZ4z/n6p1OXGlwYCHmedX6ybAgmHpUxcpaDTrh4DEBdzmINlsVJAnomBK3nbZSfR4pbljyCMjtChNIEuNIHtriE68442SrXAhrBOiGSbAu3CuqjzR+ubkfWyOg4FwX6kqv8Mk5QS092Y1jDv2pfXTtNw6EulkCiNw8UTBA5tvFu5I2Auz7x6FXQEc9+5HwSjgKXmX4z6nitA3zoS7/k4MkjKgi3uFm2odZeBheb6JhjFEzL6/OWU+/Su8PnOcd6CMmaETAhtcZAY2A01tLm/RSd55SyyQxAcugs2rKbQE1g1Lzos5Kl/95vwVjM7XHxJIr8N7J66Ivy71j0yxtzRPAAyYA7K8zAs65GI3bMYnl3lM+Q++EkpnzoAUBi4DKCof+BF3GAS/8Oe4Dejg1z8r6zwMCbsn/Et+5HfVvUnPAK7UMjGE49YnM5jzEsjEwzKrfNqgxLkFX76ftdEUP6N3k7C1KLy5BTwhYkv8Vjo+zrk7Cr21EQH++6tTmMB9T+4OA3O6xZOY5qXFwyr9Dz2/2NmlzYxkuFC+3XaM//aleRMM7wr+FtduzH6nmgP4oCpr1K/PhKbcwDupVnY0T9DQaKYOo5VvvGYjIhXgjBSiPxOA9frsu/P8I9Gcni4BmLMRMpkY9qzX77eJ6N6ZnqgwiIIEAnOh366cmeXPnPSkXmjwINFl/NpIfm7LSvyH/4nV+FP0WARvOPHw+mE55+A9answFKbcIOD2H2kRXJcMOfQKhyl+TUczaTnehsyEr0WTiw6VnXf6RzD9u9xPh9/f9da4Fnc/EZXbLl2m/33s5I6CaD0A05lz91BUdDj3JVX552z1x+SurwYB+/jzEHH1f+IHGn0F/F/3+qhb02moJRBj+c2o/A1tu97lYBBRiqw7d2YO/1Iyogug9BuoK/EHN86zsWaThMdBRZyMgsV+bMiYK6rwX3IIY9EOkiYFVhvXrhveYyeyx3PsEuOivFzxR55vQR/37K+FPQk4oaA9wl6ry3DbrM0K5PefcAO3npTZPHgmgMNB5xdL/WBU05sA9B8SOf/kkqEvACvSL5nOLjMtdIwewn66Me7/13kuW6ddGfalBoOSfuOd4D75Nnqly/haeeltBfx36y813oD/37q8NfxLyVpE9e+sPV3v5n9pKw4GeKzT0pYk66XyQeA5gZOibLVc/d3Ghn6D/HPriAHcX+su952s/JwE5ATQqjUxiyaGuN5zyP8a8CZ0AxoGy/oE7m+UmiJhIrrF4T0VYPX4E/Qeq/wj66Em4bPVuOwDi/35KX23O0vR7gy0Tdflz0HWjEyPv9yr3f/+Zwzn6i3b/ddD3MY2AU1yEdKLf/92sfnvgaLn3aKcowZ+VP5oFWU93y/+bRvRM/lHnBMRnfMyH7a+EY0NBBav+XgO1KKo3hI9qPj7uWfi7rj7ZjRcdGUVMr6K8+hn046WFS9U/zrErI/c/Ca8EnA/YnvVoI6A08wEBh7gejn7Num3qi4n/gDFx52Y63kT/qvGl0M8HVwsiAraGPrF5bwEO0CEvuzDQ3YVPmXgH9DRF3Hu4U+VeVf/cRX/R+j8I/eX4+lgKEWhD3lASSv/dRZN/RxO94EkM/TTkrysfHgERB5fP0soBLhPUfGYF/Wc1zwPoVw7ZX4QjIW3IO8qOktpBp8CPkXX7fcpKwIZUkJK37tathoOuAsIs0kVpAPCzMeQYLEQAngr/K6BvBCQcG7Aj/2QENPM5r687T73Tm4bh+NC3IICKAGrfjBnLiuO7l+TSsIq+N6V4E8pnh+wvwrEBP7F1AsCebOhr8aWqnjoHdPWnIiCwoPp91S8Rp3e4esTAYyhCdrXyKeGwz0JfCTgIx4b0E+Unyo92h72ADuBlCh4a0EPRACcOQJ77x6kYpg3ZuQKuS8Z6+v026BsBCfkH8k+UX8De/OcYzlMXQZn5uPJP0mqcTOvhq+ocq2sX9Mi13Pe76H8b9JWAFyH/QPmF8gvYmvxT8+sT+mygNxwIsWNscggFDa1/AuVE4Krfxf2r0X8H90FAJuSfwC/gL6BV9936kWstBCZ/JGM7LMFSy9sdcatZ8B5vjupm15XMPEHnWf3zddBXAo6E8gvlN/ADICBX6x9laGw7o0YiR9SuC4304KVQnn4vr/Mbqs8vhb4SkBPwG/hd/WesNp/ob40DYsI3kyxAB0QPAn3xkiE0xDWa3ux3koRXGHoT/Y9DXwkoO/A38C+AQF3+GbQBG+glPKdLHhhwgxis7DnDkcaD2gZyfktM+xx6C8S85vm4mXwR9JWA/BfSP8AvEBj6zO4RZ92BCM+3PLX25MwG86PcKxwBFP/4725+fgzll6IPYC+/gX9AP4BjaJ+2pvoki5ymMeHmYL/DJilqFwgSbZWEXQhWKpZL+d81n6+G/nzt+Af0N1BAL1CpBQ+Sdp6hVhLSBvf982Wy6wQjy9Akiy4ysfj6b0AfwI7/AX4DfwAAx5jfwpq+iQCLZn1uxUBMcowF173sSxRu+c/669vQB5Dwb9BfoB20Nd9n6CtnBwYHrmJ7TPRM4FyZipj+VPba9Ys4uMvYf99rL/8uBcCfeitGwc3/x4b+6wHxr0Owdn+OqP+bBbUXrF3iM9jO4MAC9q/j8IZ6Zw1bX0UZ/ptJ3Pff+4//w55oJ+wJW8JG2HqD2uaGLSElpA3bhpTZX2l/uT3kXNj9XrAbaqf22zMWvFFn4O29/vqD//6SwU39n2gpU9wVhYg3F3d9+lVy/n9jYs5HdicqpQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0xMS0yM1QxMzowODoyOSswMTowMMdwaqMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMTEtMjNUMTM6MDg6MTkrMDE6MDA4otX8AAAAAElFTkSuQmCC"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(3),i=t(6),a=function(){function e(e){this.renderer=e,this._mesh=i.Mesh3D.createQuad(),this._gaussianBlurShader=new o.MeshShader(r.Program.from(t(80).default,t(81).default))}return e.prototype.applyGaussianBlur=function(e){this.applyBlurScale(e.shadowTexture,e.filterTexture,new Float32Array([0,e.softness/e.shadowTexture.height])),this.applyBlurScale(e.filterTexture,e.shadowTexture,new Float32Array([e.softness/e.shadowTexture.width,0]))},e.prototype.applyBlurScale=function(e,n,t){this.renderer.renderTexture.bind(n),this.renderer.renderTexture.clear(),this._gaussianBlurShader.uniforms.u_FilterSampler=e,this._gaussianBlurShader.uniforms.u_BlurScale=t,this._gaussianBlurShader.render(this._mesh,this.renderer),this.renderer.renderTexture.bind(void 0)},e}();n.ShadowFilter=a},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\nattribute vec3 a_Position;\nattribute vec2 a_UV1;\n\nvarying vec2 v_UV1;\n\nvoid main() {\n  v_UV1 = a_UV1;\n  gl_Position = vec4(a_Position, 1.0);\n}"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying vec2 v_UV1;\n\nuniform vec2 u_BlurScale;\nuniform sampler2D u_FilterSampler;\n\nvoid main() {\n  vec4 color = vec4(0.0);\n\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-3.0) * u_BlurScale.xy)) * (1.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-2.0) * u_BlurScale.xy)) * (6.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-1.0) * u_BlurScale.xy)) * (15.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+0.0) * u_BlurScale.xy)) * (20.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+1.0) * u_BlurScale.xy)) * (15.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+2.0) * u_BlurScale.xy)) * (6.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+3.0) * u_BlurScale.xy)) * (1.0/64.0);\n\n  gl_FragColor = color;\n}"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(19),i=t(85),a=t(86),s=function(){function e(e){this.renderer=e,this._state=Object.assign(new r.State,{depthTest:!0,clockwiseFrontFace:!1,culling:!0,blendMode:r.BLEND_MODES.NONE}),this._shadowShader=new o.ShadowShader}return e.prototype.render=function(e,n){var t=this._shadowShader;e.skin&&e.geometry.joints&&e.geometry.weights&&(this._skinningShader||(this._skinningShader=new i.SkinningShader(this.renderer)),t=this._skinningShader,e.skin.joints.length>this._skinningShader.maxSupportedJoints&&(this._textureShader||a.TextureShader.isSupported(this.renderer)&&(this._textureShader=new a.TextureShader),t=this._textureShader)),t&&(t.updateUniforms(e,n),t.render(e,this.renderer,this._state))},e}();n.ShadowRenderer=s},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\n#define FEATURES\n\nattribute vec3 a_Position;\n\n#ifdef USE_SKINNING\nattribute vec4 a_Joint1;\nattribute vec4 a_Weight1;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\n\n#ifdef USE_SKINNING\n  #ifdef USE_SKINNING_TEXTURE\n    uniform sampler2D u_jointMatrixSampler;\n  #else\n    uniform mat4 u_jointMatrix[MAX_JOINT_COUNT];\n  #endif\n#endif\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.0)\n#define ROW1_U ((0.5 + 1.0) / 4.0)\n#define ROW2_U ((0.5 + 2.0) / 4.0)\n#define ROW3_U ((0.5 + 3.0) / 4.0)\n\n#ifdef USE_SKINNING\nmat4 getJointMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(MAX_JOINT_COUNT);\n    return mat4(\n        texture2D(u_jointMatrixSampler, vec2(ROW0_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW1_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW2_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW3_U, v)) * 2.0 - 1.0\n    );\n    #else\n    return u_jointMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n    skin +=\n        a_Weight1.x * getJointMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointMatrix(a_Joint1.w);\n    return skin;\n}\n#endif\n\nvoid main() {\n  vec4 pos = vec4(a_Position, 1.0);\n  #ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n  #endif\n  gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * pos;\n}"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\n#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvoid main() {\n  float depth = gl_FragCoord.z;\n  float dx = 0.0;\n  float dy = 0.0;\n\n  #ifdef GL_OES_standard_derivatives\n    dx = dFdx(depth);\n    dy = dFdy(depth);\n  #endif\n\n  float moment2 = depth * depth + 0.25 * (dx * dx + dy * dy);\n  gl_FragColor = vec4(1.0 - depth, 1.0 - moment2, 0.0, 0.0);\n}"},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(9),s=function(e){function n(n){var t=this,r=a.Platform.getMaxVertexUniformVectors(n)-8,o=Math.floor(r/4);return(t=e.call(this,["USE_SKINNING 1","MAX_JOINT_COUNT "+o])||this)._maxSupportedJoints=o,t}return o(n,e),Object.defineProperty(n.prototype,"maxSupportedJoints",{get:function(){return this._maxSupportedJoints},enumerable:!0,configurable:!0}),n.prototype.createShaderGeometry=function(n){var t=e.prototype.createShaderGeometry.call(this,n);return n.joints&&t.addAttribute("a_Joint1",new i.Buffer(n.joints.buffer),4,!1,n.joints.componentType,n.joints.stride),n.weights&&t.addAttribute("a_Weight1",new i.Buffer(n.weights.buffer),4,!1,n.weights.componentType,n.weights.stride),t},Object.defineProperty(n.prototype,"name",{get:function(){return"skinned-shadow-shader"},enumerable:!0,configurable:!0}),n.prototype.updateUniforms=function(n,t){if(e.prototype.updateUniforms.call(this,n,t),n.skin){var r=n.skin.calculateJointMatrices().jointVertexMatrices;this.uniforms.u_jointMatrix=r}},n}(t(19).ShadowShader);n.SkinningShader=s},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(19),s=t(16),u=256,l=function(e){function n(){var n=e.call(this,["USE_SKINNING 1","USE_SKINNING_TEXTURE 1","MAX_JOINT_COUNT "+u])||this;return n._jointMatrixTexture=new s.StandardMaterialMatrixTexture(u),n}return o(n,e),Object.defineProperty(n.prototype,"maxSupportedJoints",{get:function(){return u},enumerable:!0,configurable:!0}),n.isSupported=function(e){return s.StandardMaterialMatrixTexture.isSupported(e)},n.prototype.createShaderGeometry=function(n){var t=e.prototype.createShaderGeometry.call(this,n);return n.joints&&t.addAttribute("a_Joint1",new i.Buffer(n.joints.buffer),4,!1,n.joints.componentType,n.joints.stride),n.weights&&t.addAttribute("a_Weight1",new i.Buffer(n.weights.buffer),4,!1,n.weights.componentType,n.weights.stride),t},Object.defineProperty(n.prototype,"name",{get:function(){return"skinned-shadow-shader"},enumerable:!0,configurable:!0}),n.prototype.updateUniforms=function(n,t){if(e.prototype.updateUniforms.call(this,n,t),n.skin){var r=n.skin.calculateJointMatrices().jointVertexMatrices;this._jointMatrixTexture.updateBuffer(r),this.uniforms.u_jointMatrixSampler=this._jointMatrixTexture}},n}(a.ShadowShader);n.TextureShader=l},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(20);n.CubeMipmapLoader={use:function(e,n){if("cubemap"!==e.extension)return n();var t=this,r=e.data.map((function(n){return e.url.substring(0,e.url.lastIndexOf("/")+1)+n})),i=o.CubeMipmapTexture.faces.map((function(e){return r.map((function(n){return n.replace("{{face}}",e)}))})).reduce((function(e,n){return e.concat(n)}),[]);t.add(i.filter((function(e){return!t.resources[e]})).map((function(n){return{parentResource:e,url:n}})));var a=0,s=t.onLoad.add((function(n,t){i.includes(t.url)&&++a===i.length&&(e.texture=o.CubeMipmapTexture.fromSource(r),s.detach())}));n()},add:function(){r.LoaderResource.setExtensionXhrType("cubemap",r.LoaderResource.XHR_RESPONSE_TYPE.JSON)}},r.Loader.registerPlugin(n.CubeMipmapLoader)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t){var r=e.call(this,n)||this;return r.target=t,r}return o(n,e),n.prototype.upload=function(e,n){for(var t=0;t<this.items.length;t++){var r=this.items[t].resource.source;e.gl.texImage2D(this.target,t,n.format,n.format,n.type,r)}return!0},n}(t(0).resources.ArrayResource);n.MipmapResource=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t){void 0===t&&(t=1);var r=e.call(this,n)||this;return r.levels=t,r}return o(n,e),n.prototype.style=function(e){var n=e.gl;return n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),this.levels>1?n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR):n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR),!0},n}(t(0).resources.CubeResource);n.CubeMipmapResource=i},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),i=["glsl","vert","frag"];n.ShaderSourceLoader={use:function(e,n){if(!i.includes(e.extension))return n();n()},add:function(){var e,n;try{for(var t=r(i),a=t.next();!a.done;a=t.next()){var s=a.value;o.LoaderResource.setExtensionXhrType(s,o.LoaderResource.XHR_RESPONSE_TYPE.TEXT)}}catch(n){e={error:n}}finally{try{a&&!a.done&&(n=t.return)&&n.call(t)}finally{if(e)throw e.error}}}},o.Loader.registerPlugin(n.ShaderSourceLoader)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(92),a=t(6),s=t(1),u=t(20),l=function(e){function n(n){var t=e.call(this)||this;return t._mesh=t.addChild(a.Mesh3D.createCube(new i.SkyboxMaterial(n))),t}return o(n,e),Object.defineProperty(n.prototype,"camera",{get:function(){return this._mesh.material.camera},set:function(e){this._mesh.material.camera=e},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"texture",{get:function(){return this._mesh.material.texture},set:function(e){this._mesh.material.texture=e},enumerable:!0,configurable:!0}),n.from=function(e){return new n(u.CubeMipmapTexture.fromSource([e]))},n}(s.Container3D);n.Skybox=l},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(2),s=t(17),u=t(3),l=function(e){function n(n){var t=e.call(this)||this;return t._texture=n,t._state=Object.assign(new i.State,{culling:!0,clockwiseFrontFace:!0,depthTest:!0}),t}return o(n,e),Object.defineProperty(n.prototype,"texture",{get:function(){return this._texture},set:function(e){e!==this._texture&&(this._texture.valid||(this._shader=void 0),this._texture=e)},enumerable:!0,configurable:!0}),n.prototype.updateUniforms=function(e,n){var t=this.camera||a.Camera.main;n.uniforms.u_ModelMatrix=e.worldTransform.toArray(),n.uniforms.u_View=t.view,n.uniforms.u_Projection=t.projection,n.uniforms.u_EnvironmentSampler=this.texture},n.prototype.render=function(n,t){t.gl.depthMask(!1),e.prototype.render.call(this,n,t,this._state),t.gl.depthMask(!0)},n.prototype.createShader=function(){var e=t(93).default,n=t(94).default;if(this.texture.valid)return new u.MeshShader(i.Program.from(e,n))},n}(s.Material);n.SkyboxMaterial=l},function(e,n,t){"use strict";t.r(n),n.default="attribute vec3 a_Position;\n\nvarying vec3 v_Position;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\nvoid main() {\n  v_Position = a_Position.xyz;\n\n  // Converting the view to 3x3 matrix and then back to 4x4 matrix \n  // removes the translation. We do this because we want the skybox to \n  // be centered around the camera.\n  gl_Position = u_Projection * mat4(mat3(u_View)) * u_ModelMatrix * vec4(a_Position, 1.0);\n}"},function(e,n,t){"use strict";t.r(n),n.default="varying vec3 v_Position;\n\nuniform samplerCube u_EnvironmentSampler;\n\nvoid main() {\n  gl_FragColor = vec4(textureCube(u_EnvironmentSampler, v_Position).rgb, 1.0);\n}"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(96),o=function(){function e(e,n,t){this.object=n,this.camera=t,this.id=r.PickingId.next(),this._manager=e.plugins.picking}return e.prototype.contains=function(e,n){return this._manager.containsHitArea(e,n,this)},e}();n.PickingHitArea=o},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){var n=0;e.next=function(){return n++,new Uint8Array([n>>16&255,n>>8&255,255&n])}}(n.PickingId||(n.PickingId={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(98),i=function(){function e(e){var n=this;this.renderer=e,this._hitAreas=[],this._map=new o.PickingMap(this.renderer,128*Math.floor(this.renderer.width/this.renderer.height),128),e.on("postrender",(function(){if(n.renderer.plugins.interaction.hitTest(new r.Point(0,0)),0!==n._hitAreas.length){var e=Math.floor(n._map.height*(n.renderer.width/n.renderer.height));n._map.width!==e&&n._map.resize(e,n._map.height),n._map.update(n._hitAreas),n._hitAreas=[]}}))}return e.prototype.containsHitArea=function(e,n,t){return this._hitAreas.indexOf(t)<0&&this._hitAreas.push(t),this._map.containsId(e,n,t.id)},e}();n.PickingManager=i,r.Renderer.registerPlugin("picking",i)},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),i=t(2),a=t(6),s=t(3),u=function(){function e(e,n,r){this._renderer=e,this._update=0,this._pixels=new Uint8Array(n*r*4),this._output=o.RenderTexture.create({width:n,height:r}),this._shader=new s.MeshShader(o.Program.from(t(99).default,t(100).default)),this._output.framebuffer.addDepthTexture()}return e.prototype.resize=function(e,n){this._pixels=new Uint8Array(e*n*4),this._output.resize(e,n)},e.prototype.containsId=function(e,n,t){e=Math.floor(e/this._renderer.width*this._output.width),n=Math.floor((this._renderer.height-n)/this._renderer.height*this._output.height);for(var r=0;r<3;r++)if(t[r]!==this._pixels[4*(n*this._output.width+e)+r])return!1;return!0},Object.defineProperty(e.prototype,"width",{get:function(){return this._output.width},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this._output.height},enumerable:!0,configurable:!0}),e.prototype.update=function(e){var n,t,o,s;if(this._renderer.renderTexture.bind(this._output),this._update++%2==0){this._renderer.renderTexture.clear();try{for(var u=r(e),l=u.next();!l.done;l=u.next()){var f=l.value,c=f.object instanceof a.Mesh3D?[f.object]:f.object.meshes,d=f.camera||i.Camera.main;try{for(var _=(o=void 0,r(c)),p=_.next();!p.done;p=_.next()){var h=p.value;this._shader.uniforms.u_World=h.transform.worldTransform.toArray(),this._shader.uniforms.u_Id=f.id,this._shader.uniforms.u_ViewProjection=d.viewProjection,this._shader.render(h,this._renderer)}}catch(e){o={error:e}}finally{try{p&&!p.done&&(s=_.return)&&s.call(_)}finally{if(o)throw o.error}}}}catch(e){n={error:e}}finally{try{l&&!l.done&&(t=u.return)&&t.call(u)}finally{if(n)throw n.error}}}else{var m=this._renderer.gl;m.readPixels(0,0,this._output.width*this._renderer.resolution,this._output.height*this._renderer.resolution,m.RGBA,m.UNSIGNED_BYTE,this._pixels)}this._renderer.renderTexture.bind(void 0)},e}();n.PickingMap=u},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\nattribute vec3 a_Position;\n\nuniform mat4 u_World;\nuniform mat4 u_ViewProjection;\n\nvoid main() {\n  gl_Position = u_ViewProjection * u_World * vec4(a_Position, 1.0);\n}"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec3 u_Id;\n\nvoid main() {\n  gl_FragColor = vec4(u_Id / 255.0, 1.0);\n}"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(8),o=t(9),i=t(102),a=t(21),s=t(103),u=function(){function e(e,n,t,o,s,u){if(void 0===s&&(s=0),void 0===u&&(u=a.ShadowQuality.medium),this.renderer=e,this.light=n,this.shadowArea=o,this.softness=s,this._lightViewProjection=new Float32Array(16),this.followCamera=!0,n.type===r.LightType.point)throw new Error("PIXI3D: Only directional and spot lights are supported as shadow casters.");this._shadowTexture=i.ShadowTexture.create(e,t,u),this._shadowTexture.baseTexture.framebuffer.addDepthTexture(),this._filterTexture=i.ShadowTexture.create(e,t,u)}return Object.defineProperty(e.prototype,"lightViewProjection",{get:function(){return this._lightViewProjection},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"shadowTexture",{get:function(){return this._shadowTexture},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"filterTexture",{get:function(){return this._filterTexture},enumerable:!0,configurable:!0}),e.prototype.destroy=function(){this._shadowTexture.destroy(!0),this._filterTexture.destroy(!0)},e.prototype.clear=function(){this.renderer.renderTexture.bind(this._shadowTexture),this.renderer.renderTexture.clear([0,0,0,0],this.renderer.gl.COLOR_BUFFER_BIT|this.renderer.gl.DEPTH_BUFFER_BIT),this.renderer.renderTexture.bind(void 0)},e.prototype.updateLightViewProjection=function(){this.light.type===r.LightType.directional?s.ShadowMath.calculateDirectionalLightViewProjection(this):this.light.type===r.LightType.spot&&s.ShadowMath.calculateSpotLightViewProjection(this)},e.isMediumQualitySupported=function(e){return o.Platform.isHalfFloatFramebufferSupported(e)},e.isHighQualitySupported=function(e){return o.Platform.isFloatFramebufferSupported(e)},e}();n.ShadowCastingLight=u},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(21),i=t(9);!function(e){function n(e){return i.Platform.supportsFloatLinear(e)?r.SCALE_MODES.LINEAR:r.SCALE_MODES.NEAREST}e.create=function(e,t,a){var s=function(e,n){if(n===o.ShadowQuality.high){if(i.Platform.isFloatFramebufferSupported(e))return r.TYPES.FLOAT;if(i.Platform.isHalfFloatFramebufferSupported(e))return r.TYPES.HALF_FLOAT}if(n===o.ShadowQuality.medium&&i.Platform.isHalfFloatFramebufferSupported(e))return r.TYPES.HALF_FLOAT;return r.TYPES.UNSIGNED_BYTE}(e,a);return r.RenderTexture.create({width:t,height:t,type:s,scaleMode:n(e)})}}(n.ShadowTexture||(n.ShadowTexture={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(5),o=t(8),i=t(14),a=t(4),s=t(2);!function(e){var n=new Float32Array(16),t=new Float32Array(16),u=(new Float32Array([0,1,0]),new Float32Array(4)),l=new Float32Array(3),f=new Float32Array(3),c=new Float32Array(3),d=new Float32Array(3);e.calculateDirectionalLightViewProjection=function(e){if(e.light.type===o.LightType.directional){var _=e.shadowArea/2,p=2*_/e.shadowArea,h=r.Mat4.ortho(-_,_,-_,_,-_,_,n),m=e.light,g=e.camera||s.Camera.main;g&&e.followCamera?(i.Vec3.scale(g.worldTransform.forward,_,d),i.Vec3.add(g.worldTransform.position,d,c),i.Vec3.transformQuat(c,a.Quat.conjugate(e.light.worldTransform.rotation,u),l),l[0]=p*Math.floor(l[0]/p),l[1]=p*Math.floor(l[1]/p),i.Vec3.transformQuat(l,m.worldTransform.rotation,l),i.Vec3.add(l,m.worldTransform.forward,f),r.Mat4.lookAt(l,f,m.worldTransform.up,t),r.Mat4.multiply(h,t,e.lightViewProjection)):(i.Vec3.add(m.worldTransform.position,e.light.worldTransform.forward,c),r.Mat4.lookAt(m.worldTransform.position,c,m.worldTransform.up,t),r.Mat4.multiply(h,t,e.lightViewProjection))}},e.calculateSpotLightViewProjection=function(e){if(e.light.type===o.LightType.spot){var a=e.light;r.Mat4.perspective(a.outerConeAngle*PIXI.DEG_TO_RAD*2,1,2,a.range,n),i.Vec3.add(a.worldTransform.position,a.worldTransform.forward,c),r.Mat4.lookAt(a.worldTransform.position,c,a.worldTransform.up,t),r.Mat4.multiply(n,t,e.lightViewProjection)}}}(n.ShadowMath||(n.ShadowMath={}))},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=function(e){function n(n,t){var r=e.call(this)||this;r._fxaa=new i.filters.FXAAFilter;var o=t||{},a=o.width,s=void 0===a?512:a,u=o.height,l=void 0===u?512:u;return r._renderTexture=i.RenderTexture.create({width:s,height:l}),r._renderTexture.rotate=8,r._renderTexture.baseTexture.framebuffer.addDepthTexture(),r._fxaa.enabled=!1,r.texture=r._renderTexture,r.filters=[r._fxaa],t&&t.width&&t.height||n.on("prerender",(function(){r._renderTexture.resize(n.width,n.height)})),r}return o(n,e),Object.defineProperty(n.prototype,"renderTexture",{get:function(){return this._renderTexture},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"depthTexture",{get:function(){if(this._renderTexture)return this._renderTexture.baseTexture.framebuffer.depthTexture},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"fxaa",{get:function(){return this._fxaa},enumerable:!0,configurable:!0}),n}(i.Sprite);n.PostProcessingSprite=a}])}));