!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("pixi.js")):"function"==typeof define&&define.amd?define("PIXI3D",["pixi.js"],n):"object"==typeof exports?exports.PIXI3D=n(require("pixi.js")):e.PIXI3D=n(e.PIXI)}(window,(function(e){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=37)}([function(n,t){n.exports=e},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(22),s=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.transform=new a.Transform3D,n}return o(n,e),Object.defineProperty(n.prototype,"position",{get:function(){return this.transform.position},set:function(e){this.transform.position.copyFrom(e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"scale",{get:function(){return this.transform.scale},set:function(e){this.transform.scale.copyFrom(e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"rotationQuaternion",{get:function(){return this.transform.rotationQuaternion},set:function(e){this.transform.rotationQuaternion.copyFrom(e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"z",{get:function(){return this.transform.position.z},set:function(e){this.transform.position.z=e},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"localTransform",{get:function(){return this.transform.localTransform},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"worldTransform",{get:function(){return this.transform.worldTransform},enumerable:!0,configurable:!0}),n}(i.Container);n.Container3D=s},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(1),s=t(4),u=t(24),l=t(25),f=t(10),c=new Float32Array(16),d=new Float32Array(4),_=function(e){function n(t){var r=e.call(this)||this;return r.renderer=t,r._id=0,r._fieldOfView=60,r._near=.1,r._far=1e3,r.renderer.on("prerender",(function(){r._aspect||r._id++,r.parent||r.transform.updateTransform()})),n.main||(n.main=r),r.transform.position.z=5,r.transform.rotationQuaternion.setEulerAngles(0,180,0),r}return o(n,e),Object.defineProperty(n.prototype,"id",{get:function(){return this.transform._worldID+this._id},enumerable:!0,configurable:!0}),n.prototype.screenToWorld=function(e,n,t,r){void 0===r&&(r=new f.ObservablePoint3D((function(){}),void 0));var o=this.far;this.far=t;var i=s.Mat4.invert(this.viewProjection,c);if(null!==i){var a=u.Vec4.set(e/this.renderer.width*2-1,-1*(n/this.renderer.height*2-1),1,1,d);this.far=o;var l=u.Vec4.transformMat4(a,i,d);l[3]=1/l[3];for(var _=0;_<3;_++)l[_]*=l[3];return r.set(l[0],l[1],l[2])}},n.prototype.worldToScreen=function(e,n,t,r){void 0===r&&(r=new i.Point);var o=u.Vec4.set(e,n,t,1,d),a=u.Vec4.transformMat4(u.Vec4.transformMat4(o,this.view,d),this.projection,d);if(0!==a[3])for(var s=0;s<3;s++)a[s]/=a[3];var l=this.renderer,f=l.width,c=l.height;return r.set((a[0]+1)/2*f,c-(a[1]+1)/2*c)},Object.defineProperty(n.prototype,"aspect",{get:function(){return this._aspect},set:function(e){this._aspect!==e&&(this._aspect=e,this._id++)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"fieldOfView",{get:function(){return this._fieldOfView},set:function(e){this._fieldOfView!==e&&(this._fieldOfView=e,this._id++)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"near",{get:function(){return this._near},set:function(e){this._near!==e&&(this._near=e,this._id++)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"far",{get:function(){return this._far},set:function(e){this._far!==e&&(this._far=e,this._id++)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"projection",{get:function(){var e=this;return this._projection||(this._projection=new l.MatrixComponent(this,16,(function(n){s.Mat4.perspective(e._fieldOfView*i.DEG_TO_RAD,e._aspect||e.renderer.width/e.renderer.height,e._near,e._far,n)}))),this._projection.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"view",{get:function(){var e=this;return this._view||(this._view=new l.MatrixComponent(this,16,(function(n){s.Mat4.lookAt(e.worldTransform.position,e.worldTransform.target,e.worldTransform.up,n)}))),this._view.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"viewProjection",{get:function(){var e=this;return this._viewProjection||(this._viewProjection=new l.MatrixComponent(this,16,(function(n){s.Mat4.multiply(e.projection,e.view,n)}))),this._viewProjection.array},enumerable:!0,configurable:!0}),n}(a.Container3D);n.Camera=_,i.Renderer.registerPlugin("camera",_)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.state=Object.assign(new i.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0}),n.drawMode=i.DRAW_MODES.TRIANGLES,n}return o(n,e),Object.defineProperty(n.prototype,"name",{get:function(){return"mesh-shader"},enumerable:!0,configurable:!0}),n.prototype.addGeometryAttributes=function(e){e.indices&&e.addIndex(new i.Buffer(new Uint32Array(e.indices.buffer))),e.positions&&e.addAttribute("a_Position",new i.Buffer(e.positions.buffer),3,!1,e.positions.componentType,e.positions.stride),e.uvs&&e.uvs[0]&&e.addAttribute("a_UV1",new i.Buffer(e.uvs[0].buffer),2,!1,e.uvs[0].componentType,e.uvs[0].stride),e.normals&&e.addAttribute("a_Normal",new i.Buffer(e.normals.buffer),3,!1,e.normals.componentType,e.normals.stride),e.tangents&&e.addAttribute("a_Tangent",new i.Buffer(e.tangents.buffer),4,!1,e.tangents.componentType,e.tangents.stride)},n.prototype.render=function(e,n,t,r){e.geometry.hasShaderAttributes(this)||e.geometry.addShaderAttributes(this),n.shader.bind(this,!1),n.state.set(t||this.state),n.geometry.bind(e.geometry,this),n.geometry.draw(r||this.drawMode)},n}(i.Shader);n.MeshShader=a},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){function n(e,n){var t=e[0],r=e[1],o=e[2],i=e[4],a=e[5],s=e[6],u=e[8],l=e[9],f=e[10];return n[0]=Math.hypot(t,r,o),n[1]=Math.hypot(i,a,s),n[2]=Math.hypot(u,l,f),n}function t(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}e.getTranslation=function(e,n){return n[0]=e[12],n[1]=e[13],n[2]=e[14],n},e.getScaling=n,e.getRotation=function(e,t){var r=n(e,new Float32Array(3)),o=1/r[0],i=1/r[1],a=1/r[2],s=e[0]*o,u=e[1]*i,l=e[2]*a,f=e[4]*o,c=e[5]*i,d=e[6]*a,_=e[8]*o,h=e[9]*i,p=e[10]*a,g=s+c+p,m=0;return g>0?(m=2*Math.sqrt(g+1),t[3]=.25*m,t[0]=(d-h)/m,t[1]=(_-l)/m,t[2]=(u-f)/m):s>c&&s>p?(m=2*Math.sqrt(1+s-c-p),t[3]=(d-h)/m,t[0]=.25*m,t[1]=(u+f)/m,t[2]=(_+l)/m):c>p?(m=2*Math.sqrt(1+c-s-p),t[3]=(_-l)/m,t[0]=(u+f)/m,t[1]=.25*m,t[2]=(d+h)/m):(m=2*Math.sqrt(1+p-s-c),t[3]=(u-f)/m,t[0]=(_+l)/m,t[1]=(d+h)/m,t[2]=.25*m),t},e.copy=function(e,n){return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15],n},e.fromRotationTranslationScale=function(e,n,t,r){var o=e[0],i=e[1],a=e[2],s=e[3],u=o+o,l=i+i,f=a+a,c=o*u,d=o*l,_=o*f,h=i*l,p=i*f,g=a*f,m=s*u,v=s*l,S=s*f,y=t[0],A=t[1],T=t[2];return r[0]=(1-(h+g))*y,r[1]=(d+S)*y,r[2]=(_-v)*y,r[3]=0,r[4]=(d-S)*A,r[5]=(1-(c+g))*A,r[6]=(p+m)*A,r[7]=0,r[8]=(_+v)*T,r[9]=(p-m)*T,r[10]=(1-(c+h))*T,r[11]=0,r[12]=n[0],r[13]=n[1],r[14]=n[2],r[15]=1,r},e.multiply=function(e,n,t){var r=e[0],o=e[1],i=e[2],a=e[3],s=e[4],u=e[5],l=e[6],f=e[7],c=e[8],d=e[9],_=e[10],h=e[11],p=e[12],g=e[13],m=e[14],v=e[15],S=n[0],y=n[1],A=n[2],T=n[3];return t[0]=S*r+y*s+A*c+T*p,t[1]=S*o+y*u+A*d+T*g,t[2]=S*i+y*l+A*_+T*m,t[3]=S*a+y*f+A*h+T*v,S=n[4],y=n[5],A=n[6],T=n[7],t[4]=S*r+y*s+A*c+T*p,t[5]=S*o+y*u+A*d+T*g,t[6]=S*i+y*l+A*_+T*m,t[7]=S*a+y*f+A*h+T*v,S=n[8],y=n[9],A=n[10],T=n[11],t[8]=S*r+y*s+A*c+T*p,t[9]=S*o+y*u+A*d+T*g,t[10]=S*i+y*l+A*_+T*m,t[11]=S*a+y*f+A*h+T*v,S=n[12],y=n[13],A=n[14],T=n[15],t[12]=S*r+y*s+A*c+T*p,t[13]=S*o+y*u+A*d+T*g,t[14]=S*i+y*l+A*_+T*m,t[15]=S*a+y*f+A*h+T*v,t},e.lookAt=function(e,n,r,o){var i,a,s,u,l,f,c,d,_,h,p=e[0],g=e[1],m=e[2],v=r[0],S=r[1],y=r[2],A=n[0],T=n[1],b=n[2];return Math.abs(p-A)<1e-6&&Math.abs(g-T)<1e-6&&Math.abs(m-b)<1e-6?t(o):(c=p-A,d=g-T,_=m-b,i=S*(_*=h=1/Math.hypot(c,d,_))-y*(d*=h),a=y*(c*=h)-v*_,s=v*d-S*c,(h=Math.hypot(i,a,s))?(i*=h=1/h,a*=h,s*=h):(i=0,a=0,s=0),u=d*s-_*a,l=_*i-c*s,f=c*a-d*i,(h=Math.hypot(u,l,f))?(u*=h=1/h,l*=h,f*=h):(u=0,l=0,f=0),o[0]=i,o[1]=u,o[2]=c,o[3]=0,o[4]=a,o[5]=l,o[6]=d,o[7]=0,o[8]=s,o[9]=f,o[10]=_,o[11]=0,o[12]=-(i*p+a*g+s*m),o[13]=-(u*p+l*g+f*m),o[14]=-(c*p+d*g+_*m),o[15]=1,o)},e.identity=t,e.perspective=function(e,n,t,r,o){var i,a=1/Math.tan(e/2);return o[0]=a/n,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=a,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[11]=-1,o[12]=0,o[13]=0,o[15]=0,null!=r&&r!==1/0?(i=1/(t-r),o[10]=(r+t)*i,o[14]=2*r*t*i):(o[10]=-1,o[14]=-2*t),o},e.ortho=function(e,n,t,r,o,i,a){var s=1/(e-n),u=1/(t-r),l=1/(o-i);return a[0]=-2*s,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=-2*u,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=2*l,a[11]=0,a[12]=(e+n)*s,a[13]=(r+t)*u,a[14]=(i+o)*l,a[15]=1,a},e.invert=function(e,n){var t=e[0],r=e[1],o=e[2],i=e[3],a=e[4],s=e[5],u=e[6],l=e[7],f=e[8],c=e[9],d=e[10],_=e[11],h=e[12],p=e[13],g=e[14],m=e[15],v=t*s-r*a,S=t*u-o*a,y=t*l-i*a,A=r*u-o*s,T=r*l-i*s,b=o*l-i*u,M=f*p-c*h,E=f*g-d*h,O=f*m-_*h,w=c*g-d*p,x=c*m-_*p,P=d*m-_*g,C=v*P-S*x+y*w+A*O-T*E+b*M;return C?(C=1/C,n[0]=(s*P-u*x+l*w)*C,n[1]=(o*x-r*P-i*w)*C,n[2]=(p*b-g*T+m*A)*C,n[3]=(d*T-c*b-_*A)*C,n[4]=(u*O-a*P-l*E)*C,n[5]=(t*P-o*O+i*E)*C,n[6]=(g*y-h*b-m*S)*C,n[7]=(f*b-d*y+_*S)*C,n[8]=(a*x-s*O+l*M)*C,n[9]=(r*O-t*x-i*M)*C,n[10]=(h*T-p*y+m*v)*C,n[11]=(c*y-f*T-_*v)*C,n[12]=(s*E-a*w-u*M)*C,n[13]=(t*w-r*E+o*M)*C,n[14]=(p*S-h*A-g*v)*C,n[15]=(f*A-c*S+d*v)*C,n):null},e.transpose=function(e,n){if(n===e){var t=e[1],r=e[2],o=e[3],i=e[6],a=e[7],s=e[11];n[1]=e[4],n[2]=e[8],n[3]=e[12],n[4]=t,n[6]=e[9],n[7]=e[13],n[8]=r,n[9]=i,n[11]=e[14],n[12]=o,n[13]=a,n[14]=s}else n[0]=e[0],n[1]=e[4],n[2]=e[8],n[3]=e[12],n[4]=e[1],n[5]=e[5],n[6]=e[9],n[7]=e[13],n[8]=e[2],n[9]=e[6],n[10]=e[10],n[11]=e[14],n[12]=e[3],n[13]=e[7],n[14]=e[11],n[15]=e[15];return n},e.fromScaling=function(e,n){return n[0]=e[0],n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=e[1],n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=e[2],n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},e.fromTranslation=function(e,n){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n}}(n.Mat4||(n.Mat4={}))},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(40),a=t(41),s=t(12),u=t(1),l=t(58),f=function(e){function n(n,t){var r=e.call(this)||this;if(r.geometry=n,r.material=t,r.pluginName="mesh3d",r.renderPasses=["standard"],!n)throw new Error("PIXI3D: Geometry is required when creating a mesh.");return r}return o(n,e),n.prototype._render=function(e){e.batch.setObjectRenderer(e.plugins[this.pluginName]),e.plugins[this.pluginName].render(this)},n.createQuad=function(e){return void 0===e&&(e=new s.StandardMaterial),new n(l.QuadGeometry.create(),e)},n.createCube=function(e){return void 0===e&&(e=new s.StandardMaterial),new n(a.CubeGeometry.create(),e)},n.createPlane=function(e){return void 0===e&&(e=new s.StandardMaterial),new n(i.PlaneGeometry.create(),e)},n}(u.Container3D);n.Mesh3D=f},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n._shaders=[],n}return o(n,e),n.prototype.addAttribute=function(n,t,r,o,i,a,s){return this.getAttribute(n)?this:e.prototype.addAttribute.call(this,n,t,r,o,i,a,s)},n.prototype.addIndex=function(n){return this.getIndex()?this:e.prototype.addIndex.call(this,n)},n.prototype.addShaderAttributes=function(e){e.addGeometryAttributes(this),this._shaders.push(e.name)},n.prototype.hasShaderAttributes=function(e){return this._shaders.indexOf(e.name)>=0},n}(t(0).Geometry);n.MeshGeometry3D=i},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.spot="spot",e.directional="directional",e.point="point"}(n.LightType||(n.LightType={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,n){this._position=0,this._frame=0,this._input=e,this._interpolation=n}return Object.defineProperty(e.prototype,"position",{get:function(){return this._position},set:function(e){this.setPosition(e)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"duration",{get:function(){return this._input[this._input.length-1]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"frame",{get:function(){return this._frame},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"length",{get:function(){return this._input.length},enumerable:!0,configurable:!0}),e.prototype.setPosition=function(e){e>this.duration&&(e%=this.duration),this._position=e,this._frame=this.calculateFrame(this._position),this.updateTarget(this._interpolation.interpolate(this._frame,this.calculateFramePosition(this._frame,this._position)))},e.prototype.update=function(e){this.position+=e},e.prototype.calculateFramePosition=function(e,n){return e===this._input.length-1?1:(n-this._input[e])/(this._input[e+1]-this._input[e])},e.prototype.calculateFrame=function(e){if(e<this._input[0])return 0;for(var n=0;n<this._input.length-1;n++)if(e>=this._input[n]&&e<this._input[n+1])return n;return this._input.length-1},e.from=function(e,n,t,r,f){if("translation"===r)return new l.glTFTranslation(f.transform,e,o.glTFInterpolation.from(t,e,n,3));if("scale"===r)return new a.glTFScale(f.transform,e,o.glTFInterpolation.from(t,e,n,3));if("rotation"===r)return"LINEAR"===t?new u.glTFRotation(f.transform,e,new i.glTFSphericalLinear(n)):new u.glTFRotation(f.transform,e,o.glTFInterpolation.from(t,e,n,4));if("weights"===r){var c=f.children[0].morphWeights;if(!c)return;return new s.glTFWeights(c,e,o.glTFInterpolation.from(t,e,n,c.length))}throw new Error('PIXI3D: Unknown channel path "'+r+'"')},e}();n.glTFChannel=r;var o=t(9),i=t(63),a=t(64),s=t(65),u=t(66),l=t(67)},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(){}return e.from=function(e,n,t,r){switch(e){case"LINEAR":return new o.glTFLinear(t,r);case"CUBICSPLINE":return new i.glTFCubicSpline(n,t,r);case"STEP":return new a.glTFStep(t,r)}throw new Error('PIXI3D: Unknown interpolation type "'+e+'"')},e}();n.glTFInterpolation=r;var o=t(60),i=t(61),a=t(62)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r,o,i){void 0===r&&(r=0),void 0===o&&(o=0),void 0===i&&(i=0);var a=e.call(this,n,t,r,o)||this;return a.cb=n,a.scope=t,a._z=i,a}return o(n,e),Object.defineProperty(n.prototype,"z",{get:function(){return this._z},set:function(e){this._z!==e&&(this._z=e,this.cb.call(this.scope))},enumerable:!0,configurable:!0}),n.prototype.clone=function(e,t){return new n(e||this.cb,t||this.scope,this.x,this.y,this._z)},n.prototype.copyFrom=function(t){return e.prototype.copyFrom.call(this,t),t instanceof n&&(this.z=t.z),this},n.prototype.copyTo=function(e){return e instanceof n&&e.set(this.x,this.y,this.z),e},n.prototype.equals=function(t){return t instanceof n&&(e.prototype.equals.call(this,t)&&t.z===this.z)},n.prototype.set=function(n,t,r){e.prototype.set.call(this,n,t);var o=r||(0!==r?n:0);return this._z!==o&&(this._z=o,this.cb.call(this.scope)),this},n.prototype.setFrom=function(e){return this.set(e[0],e[1],e[2]),this},n}(t(0).ObservablePoint);n.ObservablePoint3D=i},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.set=function(e,n,t,r,o){return o[0]=e,o[1]=n,o[2]=t,o[3]=r,o},e.normalize=function(e,n){var t=e[0],r=e[1],o=e[2],i=e[3],a=t*t+r*r+o*o+i*i;return a>0&&(a=1/Math.sqrt(a)),n[0]=t*a,n[1]=r*a,n[2]=o*a,n[3]=i*a,n},e.slerp=function(e,n,t,r){var o,i,a,s,u=e[0],l=e[1],f=e[2],c=e[3],d=n[0],_=n[1],h=n[2],p=n[3],g=u*d+l*_+f*h+c*p;return g<0&&(g=-g,d=-d,_=-_,h=-h,p=-p),1-g>1e-6?(o=Math.acos(g),i=Math.sin(o),a=Math.sin((1-t)*o)/i,s=Math.sin(t*o)/i):(a=1-t,s=t),r[0]=a*u+s*d,r[1]=a*l+s*_,r[2]=a*f+s*h,r[3]=a*c+s*p,r},e.fromEuler=function(e,n,t,r){var o=.5*Math.PI/180;e*=o,n*=o,t*=o;var i=Math.sin(e),a=Math.cos(e),s=Math.sin(n),u=Math.cos(n),l=Math.sin(t),f=Math.cos(t);return r[0]=i*u*f-a*s*l,r[1]=a*s*f+i*u*l,r[2]=a*u*l-i*s*f,r[3]=a*u*f+i*s*l,r},e.conjugate=function(e,n){return n[0]=-e[0],n[1]=-e[1],n[2]=-e[2],n[3]=e[3],n}}(n.Quat||(n.Quat={}))},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),i=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),s=t(7),u=t(42),l=t(43),f=t(16),c=t(2),d=t(31),_=t(32),h=t(14),p={},g=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n._unlit=!1,n._alphaMode=h.StandardMaterialAlphaMode.opaque,n._transparent=!1,n.roughness=1,n.metallic=1,n.baseColor=[1,1,1,1],n.alphaCutoff=.5,n.emissive=[0,0,0],n.exposure=3,n}return o(n,e),Object.defineProperty(n.prototype,"baseColorTexture",{get:function(){return this._baseColorTexture},set:function(e){e!==this._baseColorTexture&&(this.invalidateShader(),this._baseColorTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"metallicRoughnessTexture",{get:function(){return this._metallicRoughnessTexture},set:function(e){e!==this._metallicRoughnessTexture&&(this.invalidateShader(),this._metallicRoughnessTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"normalTexture",{get:function(){return this._normalTexture},set:function(e){e!==this._normalTexture&&(this.invalidateShader(),this._normalTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"occlusionTexture",{get:function(){return this._occlusionTexture},set:function(e){e!==this._occlusionTexture&&(this.invalidateShader(),this._occlusionTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"emissiveTexture",{get:function(){return this._emissiveTexture},set:function(e){e!==this._emissiveTexture&&(this.invalidateShader(),this._emissiveTexture=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"alphaMode",{get:function(){return this._alphaMode},set:function(e){this._alphaMode!==e&&(this._alphaMode=e,this._alphaMode===h.StandardMaterialAlphaMode.opaque?this._transparent=!1:this._transparent=!0,this.invalidateShader())},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"shadowCastingLight",{get:function(){return this._shadowCastingLight},set:function(e){e!==this._shadowCastingLight&&(this.invalidateShader(),this._shadowCastingLight=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"debugMode",{get:function(){return this._debugMode},set:function(e){this._debugMode!==e&&(this.invalidateShader(),this._debugMode=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"transparent",{get:function(){return this._transparent},set:function(e){e!==this._transparent&&(this.alphaMode=e?h.StandardMaterialAlphaMode.blend:h.StandardMaterialAlphaMode.opaque),this._transparent=e},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"lightingEnvironment",{get:function(){return this._lightingEnvironment},set:function(e){e!==this._lightingEnvironment&&(this.invalidateShader(),this._lightingEnvironment=e)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"unlit",{get:function(){return this._unlit},set:function(e){this._unlit!==e&&(this._unlit=e,this.invalidateShader())},enumerable:!0,configurable:!0}),n.prototype.invalidateShader=function(){this._shader=void 0},n.factory=function(e){return void 0===e&&(e={}),{create:function(t){return Object.assign(n.create(t),e)}}},n.create=function(e){var t=new n;if(e instanceof d.glTFMaterial){switch(t.baseColor=e.baseColor,t.baseColorTexture=e.baseColorTexture,t.metallic=e.metallic,t.roughness=e.roughness,t.metallicRoughnessTexture=e.metallicRoughnessTexture,e.alphaMode){case"BLEND":t.alphaMode=h.StandardMaterialAlphaMode.blend;break;case"MASK":t.alphaMode=h.StandardMaterialAlphaMode.mask}t.unlit=e.unlit,t.emissiveTexture=e.emissiveTexture,t.emissive=e.emissive,t.normalTexture=e.normalTexture,t.occlusionTexture=e.occlusionTexture,t.doubleSided=e.doubleSided,t.alphaCutoff=e.alphaCutoff}return t},n.prototype.createShader=function(e,n){var t,r;if(1===n.context.webGLVersion){try{for(var o=i(["EXT_shader_texture_lod","OES_standard_derivatives"]),a=o.next();!a.done;a=o.next()){var s=a.value;n.gl.getExtension(s)||console.warn('PIXI3D: Extension "'+s+'" is not supported by current platform, the material may not be displayed correctly.')}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}}var f=this.lightingEnvironment||_.LightingEnvironment.main,c=u.StandardMaterialFeatureSet.build(n,e,e.geometry,this,f);if(c){var d=c.join(",");return p[d]||(p[d]=l.StandardShader.build(n,c)),p[d]}},n.prototype.updateUniforms=function(e,n){var t,r,o,i,u,l=this.camera||c.Camera.main;if(e.skin){var f=e.skin.calculateJointMatrices(),d=f.jointVertexMatrices,p=f.jointNormalMatrices;Object.assign(n.uniforms,{u_jointMatrix:d,u_jointNormalMatrix:p})}n.uniforms.u_Camera=l.worldTransform.position,n.uniforms.u_ViewProjectionMatrix=l.viewProjection,n.uniforms.u_Exposure=this.exposure,n.uniforms.u_MetallicFactor=this.metallic,n.uniforms.u_RoughnessFactor=this.roughness,n.uniforms.u_BaseColorFactor=this.baseColor,n.uniforms.u_EmissiveFactor=this.emissive,n.uniforms.u_ModelMatrix=e.worldTransform.toArray(),n.uniforms.u_NormalMatrix=e.transform.normalTransform.toArray(),this._shadowCastingLight&&(n.uniforms.u_ShadowSampler=this._shadowCastingLight.shadowTexture,n.uniforms.u_LightViewProjectionMatrix=this._shadowCastingLight.lightViewProjection),this._alphaMode===h.StandardMaterialAlphaMode.mask&&(n.uniforms.u_AlphaCutoff=this.alphaCutoff),e.morphWeights&&(n.uniforms.u_morphWeights=e.morphWeights),(null===(t=this.baseColorTexture)||void 0===t?void 0:t.valid)&&(n.uniforms.u_BaseColorSampler=this.baseColorTexture,n.uniforms.u_BaseColorUVSet=0);for(var g=this.lightingEnvironment||_.LightingEnvironment.main,m=0;m<g.lights.length;m++){var v=g.lights[m],S=0;switch(v.type){case s.LightType.point:S=1;break;case s.LightType.directional:S=0;break;case s.LightType.spot:S=2}n.uniforms["u_Lights["+m+"].type"]=S,n.uniforms["u_Lights["+m+"].position"]=v.worldTransform.position,n.uniforms["u_Lights["+m+"].direction"]=v.worldTransform.forward,n.uniforms["u_Lights["+m+"].range"]=v.range,n.uniforms["u_Lights["+m+"].color"]=v.color,n.uniforms["u_Lights["+m+"].intensity"]=v.intensity,n.uniforms["u_Lights["+m+"].innerConeCos"]=Math.cos(v.innerConeAngle*a.DEG_TO_RAD),n.uniforms["u_Lights["+m+"].outerConeCos"]=Math.cos(v.outerConeAngle*a.DEG_TO_RAD)}var y=g.imageBasedLighting;(null==y?void 0:y.valid)&&(n.uniforms.u_DiffuseEnvSampler=y.diffuse,n.uniforms.u_SpecularEnvSampler=y.specular,n.uniforms.u_brdfLUT=y.brdf,n.uniforms.u_MipCount=y.specular.levels-1),(null===(r=this.emissiveTexture)||void 0===r?void 0:r.valid)&&(n.uniforms.u_EmissiveSampler=this.emissiveTexture,n.uniforms.u_EmissiveUVSet=0,n.uniforms.u_EmissiveFactor=[1,1,1]),(null===(o=this.normalTexture)||void 0===o?void 0:o.valid)&&(n.uniforms.u_NormalSampler=this.normalTexture,n.uniforms.u_NormalScale=1,n.uniforms.u_NormalUVSet=0),(null===(i=this.metallicRoughnessTexture)||void 0===i?void 0:i.valid)&&(n.uniforms.u_MetallicRoughnessSampler=this.metallicRoughnessTexture,n.uniforms.u_MetallicRoughnessUVSet=0),(null===(u=this.occlusionTexture)||void 0===u?void 0:u.valid)&&(n.uniforms.u_OcclusionSampler=this.occlusionTexture,n.uniforms.u_OcclusionStrength=1,n.uniforms.u_OcclusionUVSet=0)},n}(f.Material);n.StandardMaterial=g},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.set=function(e,n,t,r){return r[0]=e,r[1]=n,r[2]=t,r},e.add=function(e,n,t){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t},e.transformQuat=function(e,n,t){var r=n[0],o=n[1],i=n[2],a=n[3],s=e[0],u=e[1],l=e[2],f=o*l-i*u,c=i*s-r*l,d=r*u-o*s,_=o*d-i*c,h=i*f-r*d,p=r*c-o*f,g=2*a;return f*=g,c*=g,d*=g,_*=2,h*=2,p*=2,t[0]=s+f+_,t[1]=u+c+h,t[2]=l+d+p,t},e.subtract=function(e,n,t){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t},e.scale=function(e,n,t){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t},e.normalize=function(e,n){var t=e[0],r=e[1],o=e[2],i=t*t+r*r+o*o;return i>0&&(i=1/Math.sqrt(i)),n[0]=e[0]*i,n[1]=e[1]*i,n[2]=e[2]*i,n}}(n.Vec3||(n.Vec3={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.opaque="opaque",e.mask="mask",e.blend="blend"}(n.StandardMaterialAlphaMode||(n.StandardMaterialAlphaMode={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){var n,t,r;e.isHalfFloatFramebufferSupported=function(e){if(2===e.context.webGLVersion)return!0;if(void 0!==n)return n;var t=e.gl,r=t.getExtension("OES_texture_half_float");if(!r)return!1;var o=t.createTexture();t.bindTexture(t.TEXTURE_2D,o),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,8,8,0,t.RGBA,r.HALF_FLOAT_OES,null);var i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i);var a=t.COLOR_ATTACHMENT0;return t.framebufferTexture2D(t.FRAMEBUFFER,a,t.TEXTURE_2D,o,0),n=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE},e.isFloatFramebufferSupported=function(e){if(2===e.context.webGLVersion)return!0;if(void 0!==t)return t;var n=e.gl;if(!n.getExtension("OES_texture_float"))return!1;var r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,8,8,0,n.RGBA,n.FLOAT,null);var o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o);var i=n.COLOR_ATTACHMENT0;return n.framebufferTexture2D(n.FRAMEBUFFER,i,n.TEXTURE_2D,r,0),t=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE},e.supportsFloatLinear=function(e){if(void 0!==r)return r;var n=e.gl;return r=null!==n.getExtension("OES_texture_float_linear")},e.isShaderTextureLodSupported=function(e){return 2===e.context.webGLVersion||null!==e.gl.getExtension("EXT_shader_texture_lod")}}(n.Platform||(n.Platform={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=function(){function e(){this.drawMode=r.DRAW_MODES.TRIANGLES,this.transparent=!1,this.doubleSided=!1}return e.prototype.render=function(e,n,t){(this._shader||(this._shader=this.createShader(e,n),this._shader))&&(this.updateUniforms&&this.updateUniforms(e,this._shader),this._shader.render(e,n,t,this.drawMode))},e}();n.Material=o},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(59),a=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.animations=[],n.meshes=[],n}return o(n,e),n.from=function(e,n){return i.glTFParser.createModel(e,n)},n}(t(1).Container3D);n.Model=a},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(75),s=t(76),u=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return o(n,e),Object.defineProperty(n,"faces",{get:function(){return["posx","negx","posy","negy","posz","negz"]},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"levels",{get:function(){return this.resource.levels},enumerable:!0,configurable:!0}),n.fromSource=function(e){var t=n.faces.map((function(n,t){var r=e.map((function(e){return i.Texture.from(e.replace("{{face}}",n))}));return new a.MipmapResource(r,i.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+t)}));return new n(new s.CubeMipmapResource(t,e.length))},n}(i.BaseTexture);n.CubeMipmapTexture=u},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.low="low",e.medium="medium",e.high="high"}(n.ShadowQuality||(n.ShadowQuality={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=function(){function e(e){this._buffers=[],this._images=[],this._descriptor=e}return Object.defineProperty(e.prototype,"images",{get:function(){return this._images},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"descriptor",{get:function(){return this._descriptor},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"buffers",{get:function(){return this._buffers},enumerable:!0,configurable:!0}),e.load=function(n,t){for(var o=new e(n),i=function(r){var i=n.buffers[r];if(e.isEmbeddedResource(i.uri))o._buffers[r]=e.getEmbeddedBuffer(i.uri);else{if(!t)throw new Error("PIXI3D: A resource loader is required when buffer is not embedded.");t.load(i.uri,(function(e){o._buffers[r]=e.data}))}},a=0;a<n.buffers.length;a++)i(a);if(!n.images)return o;var s=function(i){var a=n.images[i];if(e.isEmbeddedResource(a.uri))o._images[i]=r.Texture.from(a.uri,{wrapMode:r.WRAP_MODES.REPEAT});else{if(!t)throw new Error("PIXI3D: A resource loader is required when image is not embedded.");t.load(a.uri,(function(e){e.texture.baseTexture.wrapMode=r.WRAP_MODES.REPEAT,o._images[i]=e.texture}))}};for(a=0;a<n.images.length;a++)s(a);return o},e.isEmbeddedResource=function(e){return e.startsWith("data:")},e.getEmbeddedBuffer=function(e){return Uint8Array.from(atob(e.split(",")[1]),(function(e){return e.charCodeAt(0)})).buffer},e}();n.glTFAsset=o},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(11),a=t(10),s=new Float32Array(4),u=function(e){function n(n,t,r,o,i,a){void 0===r&&(r=0),void 0===o&&(o=0),void 0===i&&(i=0),void 0===a&&(a=1);var s=e.call(this,n,t,r,o,i)||this;return s._w=a,s}return o(n,e),n.prototype.setEulerAngles=function(e,n,t){i.Quat.fromEuler(e,n,t,s),this.set(s[0],s[1],s[2],s[3])},Object.defineProperty(n.prototype,"w",{get:function(){return this._w},set:function(e){this._w!==e&&(this._w=e,this.cb.call(this.scope))},enumerable:!0,configurable:!0}),n.prototype.clone=function(e,t){return new n(e||this.cb,t||this.scope,this.x,this.y,this.z,this.w)},n.prototype.copyFrom=function(t){return e.prototype.copyFrom.call(this,t),t instanceof n&&(this.w=t.w),this},n.prototype.copyTo=function(e){return e instanceof n&&e.set(this.x,this.y,this.z,this.w),e},n.prototype.equals=function(t){return t instanceof n&&(e.prototype.equals.call(this,t)&&t.w===this.w)},n.prototype.set=function(n,t,r,o){e.prototype.set.call(this,n,t,r);var i=o||(0!==o?n:0);return this._w!==i&&(this._w=i,this.cb.call(this.scope)),this},n.prototype.setFrom=function(e){return this.set(e[0],e[1],e[2],e[3]),this},n}(a.ObservablePoint3D);n.ObservableQuaternion=u},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(23),s=t(10),u=t(21),l=t(4),f=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.position=new s.ObservablePoint3D(n.onChange,n,0,0,0),n.scale=new s.ObservablePoint3D(n.onChange,n,1,1,1),n.rotationQuaternion=new u.ObservableQuaternion(n.onChange,n,0,0,0,1),n.worldTransform=new a.TransformMatrix,n.localTransform=new a.TransformMatrix,n.inverseWorldTransform=new a.TransformMatrix,n.normalTransform=new a.TransformMatrix,n}return o(n,e),n.prototype.updateLocalTransform=function(){this._localID!==this._currentLocalID&&(this.localTransform.setFromRotationPositionScale(this.rotationQuaternion,this.position,this.scale),this._parentID=-1,this._currentLocalID=this._localID)},n.prototype.setFromMatrix=function(e){this.localTransform.copyFrom(e),this.position.set(this.localTransform.position[0],this.localTransform.position[1],this.localTransform.position[2]),this.scale.set(this.localTransform.scaling[0],this.localTransform.scaling[1],this.localTransform.scaling[2]),this.rotationQuaternion.set(this.localTransform.rotation[0],this.localTransform.rotation[1],this.localTransform.rotation[2],this.localTransform.rotation[3])},n.prototype.updateTransform=function(e){this.updateLocalTransform(),e&&this._parentID===e._worldID||(e instanceof n?this.worldTransform.setFromMultiplyWorldLocal(e.worldTransform,this.localTransform):this.worldTransform.copyFrom(this.localTransform),l.Mat4.invert(this.worldTransform.toArray(),this.inverseWorldTransform.toArray()),l.Mat4.transpose(this.inverseWorldTransform.toArray(),this.normalTransform.toArray()),this._worldID++,e&&(this._parentID=e._worldID))},n}(i.Transform);n.Transform3D=f},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(4),s=t(13),u=t(24),l=t(25),f=function(e){function n(n){var t=e.call(this)||this;return t._id=0,t._array=n?new Float32Array(n):new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),t}return o(n,e),n.prototype.toArray=function(e,n){var t=n;return n||(t=this._array),t},Object.defineProperty(n.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"position",{get:function(){var e=this;return this._position||(this._position=new l.MatrixComponent(this,3,(function(n){a.Mat4.getTranslation(e._array,n)}))),this._position.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"scaling",{get:function(){var e=this;return this._scaling||(this._scaling=new l.MatrixComponent(this,3,(function(n){a.Mat4.getScaling(e._array,n)}))),this._scaling.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"rotation",{get:function(){var e=this;return this._rotation||(this._rotation=new l.MatrixComponent(this,4,(function(n){a.Mat4.getRotation(e._array,n)}))),this._rotation.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"up",{get:function(){var e=this;return this._up||(this._up=new l.MatrixComponent(this,3,(function(n){s.Vec3.normalize(s.Vec3.set(e._array[4],e._array[5],e._array[6],n),n)}))),this._up.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"forward",{get:function(){var e=this;return this._forward||(this._forward=new l.MatrixComponent(this,3,(function(n){s.Vec3.normalize(s.Vec3.set(e._array[8],e._array[9],e._array[10],n),n)}))),this._forward.array},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"target",{get:function(){var e=this;return this._target||(this._target=new l.MatrixComponent(this,3,(function(n){s.Vec3.add(e.position,e.forward,n)}))),this._target.array},enumerable:!0,configurable:!0}),n.prototype.copyFrom=function(e){return e instanceof n&&(a.Mat4.copy(e._array,this._array),this._id++),this},n.prototype.setFromRotationPositionScale=function(e,n,t){u.Vec4.set(e.x,e.y,e.z,e.w,this.rotation),s.Vec3.set(t.x,t.y,t.z,this.scaling),s.Vec3.set(n.x,n.y,n.z,this.position),a.Mat4.fromRotationTranslationScale(this.rotation,this.position,this.scaling,this._array),this._id++},n.prototype.setFromMultiplyWorldLocal=function(e,n){a.Mat4.multiply(e._array,n._array,this._array),this._id++},n}(i.Matrix);n.TransformMatrix=f},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.set=function(e,n,t,r,o){return o[0]=e,o[1]=n,o[2]=t,o[3]=r,o},e.transformMat4=function(e,n,t){var r=e[0],o=e[1],i=e[2],a=e[3];return t[0]=n[0]*r+n[4]*o+n[8]*i+n[12]*a,t[1]=n[1]*r+n[5]*o+n[9]*i+n[13]*a,t[2]=n[2]*r+n[6]*o+n[10]*i+n[14]*a,t[3]=n[3]*r+n[7]*o+n[11]*i+n[15]*a,t}}(n.Vec4||(n.Vec4={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,n,t){this._parent=e,this._update=t,this._array=new Float32Array(n)}return Object.defineProperty(e.prototype,"array",{get:function(){return this._id!==this._parent.id&&(this._update(this._array),this._id=this._parent.id),this._array},enumerable:!0,configurable:!0}),e}();n.MatrixComponent=r},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.alpha="alpha",e.emissive="emissive",e.f0="f0",e.metallic="metallic",e.normal="normal",e.occlusion="occlusion",e.roughness="roughness"}(n.StandardMaterialDebugMode||(n.StandardMaterialDebugMode={}))},function(e,n,t){"use strict";t.r(n),n.default="//\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n#define FEATURES\n\n#ifdef USE_TEX_LOD\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n#ifdef USE_HDR\n#extension GL_OES_texture_float : enable\n#extension GL_OES_texture_float_linear : enable\n#endif\n\nprecision highp float;\n\n#include <extensions.webgl1.glsl>\n#include <tonemapping.glsl>\n#include <textures.webgl1.glsl>\n#include <functions.webgl1.glsl>\n#include <shadow.webgl1.glsl>\n\n// KHR_lights_punctual extension.\n// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nstruct Light\n{\n    vec3 direction;\n    float range;\n\n    vec3 color;\n    float intensity;\n\n    vec3 position;\n    float innerConeCos;\n\n    float outerConeCos;\n    int type;\n\n    vec2 padding;\n};\n\nconst int LightType_Directional = 0;\nconst int LightType_Point = 1;\nconst int LightType_Spot = 2;\n\n#ifdef USE_PUNCTUAL\nuniform Light u_Lights[LIGHT_COUNT];\n#endif\n\n#if defined(MATERIAL_SPECULARGLOSSINESS) || defined(MATERIAL_METALLICROUGHNESS)\nuniform float u_MetallicFactor;\nuniform float u_RoughnessFactor;\nuniform vec4 u_BaseColorFactor;\n#endif\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\nuniform vec3 u_SpecularFactor;\nuniform vec4 u_DiffuseFactor;\nuniform float u_GlossinessFactor;\n#endif\n\n#ifdef ALPHAMODE_MASK\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec3 u_Camera;\n\nuniform int u_MipCount;\n\nstruct MaterialInfo\n{\n    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n    vec3 reflectance0;            // full reflectance color (normal incidence angle)\n\n    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n    vec3 diffuseColor;            // color contribution from diffuse lighting\n\n    vec3 reflectance90;           // reflectance color at grazing angle\n    vec3 specularColor;           // color contribution from specular lighting\n};\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)\n{\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n\n    float lod = clamp(materialInfo.perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    // retrieve a scale and bias to F0. See [1], Figure 3\n    vec2 brdf = texture2D(u_brdfLUT, brdfSamplePoint).rg;\n\n    vec4 diffuseSample = textureCube(u_DiffuseEnvSampler, n);\n\n#ifdef USE_TEX_LOD\n    vec4 specularSample = _textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod);\n#else\n    vec4 specularSample = textureCube(u_SpecularEnvSampler, reflection);\n#endif\n\n#ifdef USE_HDR\n    // Already linear.\n    vec3 diffuseLight = diffuseSample.rgb;\n    vec3 specularLight = specularSample.rgb;\n#else\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;\n#endif\n\n    vec3 diffuse = diffuseLight * materialInfo.diffuseColor;\n    vec3 specular = specularLight * (materialInfo.specularColor * brdf.x + brdf.y);\n\n    return diffuse + specular;\n}\n#endif\n\n// Lambert lighting\n// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\nvec3 diffuse(MaterialInfo materialInfo)\n{\n    return materialInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    return materialInfo.reflectance0 + (materialInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat visibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float NdotL = angularInfo.NdotL;\n    float NdotV = angularInfo.NdotV;\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n    float f = (angularInfo.NdotH * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nvec3 getPointShade(vec3 pointToLight, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    AngularInfo angularInfo = getAngularInfo(pointToLight, normal, view);\n\n    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)\n    {\n        // Calculate the shading terms for the microfacet specular shading model\n        vec3 F = specularReflection(materialInfo, angularInfo);\n        float Vis = visibilityOcclusion(materialInfo, angularInfo);\n        float D = microfacetDistribution(materialInfo, angularInfo);\n\n        // Calculation of analytical lighting contribution\n        vec3 diffuseContrib = (1.0 - F) * diffuse(materialInfo);\n        vec3 specContrib = F * Vis * D;\n\n        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n        return angularInfo.NdotL * (diffuseContrib + specContrib);\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(float range, float distance)\n{\n    if (range <= 0.0)\n    {\n        // negative range means unlimited\n        return 1.0;\n    }\n    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)\n{\n    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));\n    if (actualCos > outerConeCos)\n    {\n        if (actualCos < innerConeCos)\n        {\n            return smoothstep(outerConeCos, innerConeCos, actualCos);\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 applyDirectionalLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = -light.direction;\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return light.intensity * light.color * shade;\n}\n\nvec3 applyPointLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float attenuation = getRangeAttenuation(light.range, distance);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);\n    return attenuation * light.intensity * light.color * shade;\n}\n\nvec3 applySpotLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float rangeAttenuation = getRangeAttenuation(light.range, distance);\n    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return rangeAttenuation * spotAttenuation * light.intensity * light.color * shade;\n}\n\nvoid main()\n{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = 0.0;\n    float metallic = 0.0;\n    vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 specularColor= vec3(0.0);\n    vec3 f0 = vec3(0.04);\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    vec4 sgSample = SRGBtoLINEAR(texture2D(u_SpecularGlossinessSampler, getSpecularGlossinessUV()));\n    perceptualRoughness = (1.0 - sgSample.a * u_GlossinessFactor); // glossiness to roughness\n    f0 = sgSample.rgb * u_SpecularFactor; // specular\n#else\n    f0 = u_SpecularFactor;\n    perceptualRoughness = 1.0 - u_GlossinessFactor;\n#endif // ! HAS_SPECULAR_GLOSSINESS_MAP\n\n#ifdef HAS_DIFFUSE_MAP\n    baseColor = SRGBtoLINEAR(texture2D(u_DiffuseSampler, getDiffuseUV())) * u_DiffuseFactor;\n#else\n    baseColor = u_DiffuseFactor;\n#endif // !HAS_DIFFUSE_MAP\n\n    baseColor *= getVertexColor();\n\n    // f0 = specular\n    specularColor = f0;\n    float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);\n    diffuseColor = baseColor.rgb * oneMinusSpecularStrength;\n\n#ifdef DEBUG_METALLIC\n    // do conversion between metallic M-R and S-G metallic\n    metallic = solveMetallic(baseColor.rgb, specularColor, oneMinusSpecularStrength);\n#endif // ! DEBUG_METALLIC\n\n#endif // ! MATERIAL_SPECULARGLOSSINESS\n\n#ifdef MATERIAL_METALLICROUGHNESS\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, getMetallicRoughnessUV());\n    perceptualRoughness = mrSample.g * u_RoughnessFactor;\n    metallic = mrSample.b * u_MetallicFactor;\n#else\n    metallic = u_MetallicFactor;\n    perceptualRoughness = u_RoughnessFactor;\n#endif\n\n    // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASE_COLOR_MAP\n    baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, getBaseColorUV())) * u_BaseColorFactor;\n#else\n    baseColor = u_BaseColorFactor;\n#endif\n\n    baseColor *= getVertexColor();\n\n    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n\n    specularColor = mix(f0, baseColor.rgb, metallic);\n\n#endif // ! MATERIAL_METALLICROUGHNESS\n\n#ifdef ALPHAMODE_MASK\n    if(baseColor.a < u_AlphaCutoff)\n    {\n        discard;\n    }\n    baseColor.a = 1.0;\n#endif\n\n#ifdef ALPHAMODE_OPAQUE\n    baseColor.a = 1.0;\n#endif\n\n#ifdef MATERIAL_UNLIT\n    gl_FragColor = vec4(LINEARtoSRGB(baseColor.rgb) * baseColor.a, baseColor.a);\n    return;\n#endif\n\n    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));\n\n    MaterialInfo materialInfo = MaterialInfo(\n        perceptualRoughness,\n        specularEnvironmentR0,\n        alphaRoughness,\n        diffuseColor,\n        specularEnvironmentR90,\n        specularColor\n    );\n\n    // LIGHTING\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 normal = getNormal();\n    vec3 view = normalize(u_Camera - v_Position);\n\n    float shadow = 1.0;\n    #ifdef USE_SHADOW_MAPPING\n        shadow = getShadowContribution();\n    #endif\n\n#ifdef USE_PUNCTUAL\n    for (int i = 0; i < LIGHT_COUNT; ++i)\n    {\n        Light light = u_Lights[i];\n        if (light.type == LightType_Directional)\n        {\n            color += applyDirectionalLight(light, materialInfo, normal, view, shadow);\n        }\n        else if (light.type == LightType_Point)\n        {\n            color += applyPointLight(light, materialInfo, normal, view);\n        }\n        else if (light.type == LightType_Spot)\n        {\n            color += applySpotLight(light, materialInfo, normal, view, shadow);\n        }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    color += getIBLContribution(materialInfo, normal, view);\n#endif\n\n    float ao = 1.0;\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSION_MAP\n    ao = texture2D(u_OcclusionSampler,  getOcclusionUV()).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n    vec3 emissive = vec3(0);\n#ifdef HAS_EMISSIVE_MAP\n    emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, getEmissiveUV())).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifndef DEBUG_OUTPUT // no debug\n\n   // regular shading\n    gl_FragColor = vec4(toneMap(color) * baseColor.a, baseColor.a);\n\n#else // debug output\n\n    #ifdef DEBUG_METALLIC\n        gl_FragColor.rgb = vec3(metallic);\n    #endif\n\n    #ifdef DEBUG_ROUGHNESS\n        gl_FragColor.rgb = vec3(perceptualRoughness);\n    #endif\n\n    #ifdef DEBUG_NORMAL\n        #ifdef HAS_NORMAL_MAP\n            gl_FragColor.rgb = texture2D(u_NormalSampler, getNormalUV()).rgb;\n        #else\n            gl_FragColor.rgb = vec3(0.5, 0.5, 1.0);\n        #endif\n    #endif\n\n    #ifdef DEBUG_BASECOLOR\n        gl_FragColor.rgb = LINEARtoSRGB(baseColor.rgb);\n    #endif\n\n    #ifdef DEBUG_OCCLUSION\n        gl_FragColor.rgb = vec3(ao);\n    #endif\n\n    #ifdef DEBUG_EMISSIVE\n        gl_FragColor.rgb = LINEARtoSRGB(emissive);\n    #endif\n\n    #ifdef DEBUG_F0\n        gl_FragColor.rgb = vec3(f0);\n    #endif\n\n    #ifdef DEBUG_ALPHA\n        gl_FragColor.rgb = vec3(baseColor.a);\n    #endif\n\n    gl_FragColor.a = 1.0;\n\n#endif // !DEBUG_OUTPUT\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#version 300 es\n\n//\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n#define FEATURES\n\nprecision highp float;\n\n#include <tonemapping.glsl>\n#include <textures.webgl2.glsl>\n#include <functions.webgl2.glsl>\n#include <shadow.webgl2.glsl>\n\n// KHR_lights_punctual extension.\n// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nstruct Light\n{\n    vec3 direction;\n    float range;\n\n    vec3 color;\n    float intensity;\n\n    vec3 position;\n    float innerConeCos;\n\n    float outerConeCos;\n    int type;\n\n    vec2 padding;\n};\n\nconst int LightType_Directional = 0;\nconst int LightType_Point = 1;\nconst int LightType_Spot = 2;\n\n#ifdef USE_PUNCTUAL\nuniform Light u_Lights[LIGHT_COUNT];\n#endif\n\n#if defined(MATERIAL_SPECULARGLOSSINESS) || defined(MATERIAL_METALLICROUGHNESS)\nuniform float u_MetallicFactor;\nuniform float u_RoughnessFactor;\nuniform vec4 u_BaseColorFactor;\n#endif\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\nuniform vec3 u_SpecularFactor;\nuniform vec4 u_DiffuseFactor;\nuniform float u_GlossinessFactor;\n#endif\n\n#ifdef ALPHAMODE_MASK\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec3 u_Camera;\n\nuniform int u_MipCount;\n\nstruct MaterialInfo\n{\n    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n    vec3 reflectance0;            // full reflectance color (normal incidence angle)\n\n    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n    vec3 diffuseColor;            // color contribution from diffuse lighting\n\n    vec3 reflectance90;           // reflectance color at grazing angle\n    vec3 specularColor;           // color contribution from specular lighting\n};\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)\n{\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n\n    float lod = clamp(materialInfo.perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    // retrieve a scale and bias to F0. See [1], Figure 3\n    vec2 brdf = texture(u_brdfLUT, brdfSamplePoint).rg;\n\n    vec4 diffuseSample = texture(u_DiffuseEnvSampler, n);\n\n#ifdef USE_TEX_LOD\n    vec4 specularSample = textureLod(u_SpecularEnvSampler, reflection, lod);\n#else\n    vec4 specularSample = texture(u_SpecularEnvSampler, reflection);\n#endif\n\n#ifdef USE_HDR\n    // Already linear.\n    vec3 diffuseLight = diffuseSample.rgb;\n    vec3 specularLight = specularSample.rgb;\n#else\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;\n#endif\n\n    vec3 diffuse = diffuseLight * materialInfo.diffuseColor;\n    vec3 specular = specularLight * (materialInfo.specularColor * brdf.x + brdf.y);\n\n    return diffuse + specular;\n}\n#endif\n\n// Lambert lighting\n// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\nvec3 diffuse(MaterialInfo materialInfo)\n{\n    return materialInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    return materialInfo.reflectance0 + (materialInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat visibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float NdotL = angularInfo.NdotL;\n    float NdotV = angularInfo.NdotV;\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n    float f = (angularInfo.NdotH * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nvec3 getPointShade(vec3 pointToLight, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    AngularInfo angularInfo = getAngularInfo(pointToLight, normal, view);\n\n    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)\n    {\n        // Calculate the shading terms for the microfacet specular shading model\n        vec3 F = specularReflection(materialInfo, angularInfo);\n        float Vis = visibilityOcclusion(materialInfo, angularInfo);\n        float D = microfacetDistribution(materialInfo, angularInfo);\n\n        // Calculation of analytical lighting contribution\n        vec3 diffuseContrib = (1.0 - F) * diffuse(materialInfo);\n        vec3 specContrib = F * Vis * D;\n\n        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n        return angularInfo.NdotL * (diffuseContrib + specContrib);\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(float range, float distance)\n{\n    if (range <= 0.0)\n    {\n        // negative range means unlimited\n        return 1.0;\n    }\n    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)\n{\n    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));\n    if (actualCos > outerConeCos)\n    {\n        if (actualCos < innerConeCos)\n        {\n            return smoothstep(outerConeCos, innerConeCos, actualCos);\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 applyDirectionalLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = -light.direction;\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return light.intensity * light.color * shade;\n}\n\nvec3 applyPointLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float attenuation = getRangeAttenuation(light.range, distance);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);\n    return attenuation * light.intensity * light.color * shade;\n}\n\nvec3 applySpotLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float rangeAttenuation = getRangeAttenuation(light.range, distance);\n    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return rangeAttenuation * spotAttenuation * light.intensity * light.color * shade;\n}\n\nout vec4 fragColor;\n\nvoid main()\n{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = 0.0;\n    float metallic = 0.0;\n    vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 specularColor= vec3(0.0);\n    vec3 f0 = vec3(0.04);\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    vec4 sgSample = SRGBtoLINEAR(texture(u_SpecularGlossinessSampler, getSpecularGlossinessUV()));\n    perceptualRoughness = (1.0 - sgSample.a * u_GlossinessFactor); // glossiness to roughness\n    f0 = sgSample.rgb * u_SpecularFactor; // specular\n#else\n    f0 = u_SpecularFactor;\n    perceptualRoughness = 1.0 - u_GlossinessFactor;\n#endif // ! HAS_SPECULAR_GLOSSINESS_MAP\n\n#ifdef HAS_DIFFUSE_MAP\n    baseColor = SRGBtoLINEAR(texture2D(u_DiffuseSampler, getDiffuseUV())) * u_DiffuseFactor;\n#else\n    baseColor = u_DiffuseFactor;\n#endif // !HAS_DIFFUSE_MAP\n\n    baseColor *= getVertexColor();\n\n    // f0 = specular\n    specularColor = f0;\n    float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);\n    diffuseColor = baseColor.rgb * oneMinusSpecularStrength;\n\n#ifdef DEBUG_METALLIC\n    // do conversion between metallic M-R and S-G metallic\n    metallic = solveMetallic(baseColor.rgb, specularColor, oneMinusSpecularStrength);\n#endif // ! DEBUG_METALLIC\n\n#endif // ! MATERIAL_SPECULARGLOSSINESS\n\n#ifdef MATERIAL_METALLICROUGHNESS\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(u_MetallicRoughnessSampler, getMetallicRoughnessUV());\n    perceptualRoughness = mrSample.g * u_RoughnessFactor;\n    metallic = mrSample.b * u_MetallicFactor;\n#else\n    metallic = u_MetallicFactor;\n    perceptualRoughness = u_RoughnessFactor;\n#endif\n\n    // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASE_COLOR_MAP\n    baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, getBaseColorUV())) * u_BaseColorFactor;\n#else\n    baseColor = u_BaseColorFactor;\n#endif\n\n    baseColor *= getVertexColor();\n\n    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n\n    specularColor = mix(f0, baseColor.rgb, metallic);\n\n#endif // ! MATERIAL_METALLICROUGHNESS\n\n#ifdef ALPHAMODE_MASK\n    if(baseColor.a < u_AlphaCutoff)\n    {\n        discard;\n    }\n    baseColor.a = 1.0;\n#endif\n\n#ifdef ALPHAMODE_OPAQUE\n    baseColor.a = 1.0;\n#endif\n\n#ifdef MATERIAL_UNLIT\n    fragColor = vec4(LINEARtoSRGB(baseColor.rgb) * baseColor.a, baseColor.a);\n    return;\n#endif\n\n    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));\n\n    MaterialInfo materialInfo = MaterialInfo(\n        perceptualRoughness,\n        specularEnvironmentR0,\n        alphaRoughness,\n        diffuseColor,\n        specularEnvironmentR90,\n        specularColor\n    );\n\n    // LIGHTING\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 normal = getNormal();\n    vec3 view = normalize(u_Camera - v_Position);\n\n    float shadow = 1.0;\n    #ifdef USE_SHADOW_MAPPING\n        shadow = getShadowContribution();\n    #endif\n\n#ifdef USE_PUNCTUAL\n    for (int i = 0; i < LIGHT_COUNT; ++i)\n    {\n        Light light = u_Lights[i];\n        if (light.type == LightType_Directional)\n        {\n            color += applyDirectionalLight(light, materialInfo, normal, view, shadow);\n        }\n        else if (light.type == LightType_Point)\n        {\n            color += applyPointLight(light, materialInfo, normal, view);\n        }\n        else if (light.type == LightType_Spot)\n        {\n            color += applySpotLight(light, materialInfo, normal, view, shadow);\n        }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    color += getIBLContribution(materialInfo, normal, view);\n#endif\n\n    float ao = 1.0;\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSION_MAP\n    ao = texture(u_OcclusionSampler,  getOcclusionUV()).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n    vec3 emissive = vec3(0);\n#ifdef HAS_EMISSIVE_MAP\n    emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, getEmissiveUV())).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifndef DEBUG_OUTPUT // no debug\n\n   // regular shading\n    fragColor = vec4(toneMap(color) * baseColor.a, baseColor.a);\n\n#else // debug output\n\n    #ifdef DEBUG_METALLIC\n        fragColor.rgb = vec3(metallic);\n    #endif\n\n    #ifdef DEBUG_ROUGHNESS\n        fragColor.rgb = vec3(perceptualRoughness);\n    #endif\n\n    #ifdef DEBUG_NORMAL\n        #ifdef HAS_NORMAL_MAP\n            fragColor.rgb = texture(u_NormalSampler, getNormalUV()).rgb;\n        #else\n            fragColor.rgb = vec3(0.5, 0.5, 1.0);\n        #endif\n    #endif\n\n    #ifdef DEBUG_BASECOLOR\n        fragColor.rgb = LINEARtoSRGB(baseColor.rgb);\n    #endif\n\n    #ifdef DEBUG_OCCLUSION\n        fragColor.rgb = vec3(ao);\n    #endif\n\n    #ifdef DEBUG_EMISSIVE\n        gl_FragColor.rgb = LINEARtoSRGB(emissive);\n    #endif\n\n    #ifdef DEBUG_F0\n        fragColor.rgb = vec3(f0);\n    #endif\n\n    #ifdef DEBUG_ALPHA\n        fragColor.rgb = vec3(baseColor.a);\n    #endif\n\n    fragColor.a = 1.0;\n\n#endif // !DEBUG_OUTPUT\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\n#define FEATURES\n\n#include <animation.webgl1.glsl>\n\nattribute vec4 a_Position;\nvarying vec3 v_Position;\n\n#ifdef HAS_NORMALS\nattribute vec4 a_Normal;\n#endif\n\n#ifdef HAS_TANGENTS\nattribute vec4 a_Tangent;\n#endif\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 v_TBN;\n#else\nvarying vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_UV_SET1\nattribute vec2 a_UV1;\n#endif\n\n#ifdef HAS_UV_SET2\nattribute vec2 a_UV2;\n#endif\n\nvarying vec2 v_UVCoord1;\nvarying vec2 v_UVCoord2;\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nattribute vec3 a_Color;\nvarying vec3 v_Color;\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC4\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\n#ifdef USE_SHADOW_MAPPING\nuniform mat4 u_LightViewProjectionMatrix;\nvarying vec4 v_PositionLightSpace;\n#endif\n\nvec4 getPosition()\n{\n    vec4 pos = a_Position;\n\n#ifdef USE_MORPHING\n    pos += getTargetPosition();\n#endif\n\n#ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n#endif\n\n    return pos;\n}\n\n#ifdef HAS_NORMALS\nvec4 getNormal()\n{\n    vec4 normal = a_Normal;\n\n#ifdef USE_MORPHING\n    normal += getTargetNormal();\n#endif\n\n#ifdef USE_SKINNING\n    normal = getSkinningNormalMatrix() * normal;\n#endif\n\n    return normalize(normal);\n}\n#endif\n\n#ifdef HAS_TANGENTS\nvec4 getTangent()\n{\n    vec4 tangent = a_Tangent;\n\n#ifdef USE_MORPHING\n    tangent += getTargetTangent();\n#endif\n\n#ifdef USE_SKINNING\n    tangent = getSkinningMatrix() * tangent;\n#endif\n\n    return normalize(tangent);\n}\n#endif\n\nvoid main()\n{\n    vec4 pos = u_ModelMatrix * getPosition();\n    v_Position = vec3(pos.xyz) / pos.w;\n\n    #ifdef HAS_NORMALS\n    #ifdef HAS_TANGENTS\n    vec4 tangent = getTangent();\n    vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(getNormal().xyz, 0.0)));\n    vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n    vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n    v_TBN = mat3(tangentW, bitangentW, normalW);\n    #else // !HAS_TANGENTS\n    v_Normal = normalize(vec3(u_NormalMatrix * vec4(getNormal().xyz, 0.0)));\n    #endif\n    #endif // !HAS_NORMALS\n\n    v_UVCoord1 = vec2(0.0, 0.0);\n    v_UVCoord2 = vec2(0.0, 0.0);\n\n    #ifdef HAS_UV_SET1\n    v_UVCoord1 = a_UV1;\n    #endif\n\n    #ifdef HAS_UV_SET2\n    v_UVCoord2 = a_UV2;\n    #endif\n\n    #if defined(HAS_VERTEX_COLOR_VEC3) || defined(HAS_VERTEX_COLOR_VEC4)\n    v_Color = a_Color;\n    #endif\n\n    #ifdef USE_SHADOW_MAPPING\n    v_PositionLightSpace = u_LightViewProjectionMatrix * pos;\n    #endif\n\n    gl_Position = u_ViewProjectionMatrix * pos;\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#version 300 es\n\n#define FEATURES\n\n#include <animation.webgl2.glsl>\n\nin vec4 a_Position;\nout vec3 v_Position;\n\n#ifdef HAS_NORMALS\nin vec4 a_Normal;\n#endif\n\n#ifdef HAS_TANGENTS\nin vec4 a_Tangent;\n#endif\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nout mat3 v_TBN;\n#else\nout vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_UV_SET1\nin vec2 a_UV1;\n#endif\n\n#ifdef HAS_UV_SET2\nin vec2 a_UV2;\n#endif\n\nout vec2 v_UVCoord1;\nout vec2 v_UVCoord2;\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nin vec3 a_Color;\nout vec3 v_Color;\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC4\nin vec4 a_Color;\nout vec4 v_Color;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\n#ifdef USE_SHADOW_MAPPING\nuniform mat4 u_LightViewProjectionMatrix;\nout vec4 v_PositionLightSpace;\n#endif\n\nvec4 getPosition()\n{\n    vec4 pos = a_Position;\n\n#ifdef USE_MORPHING\n    pos += getTargetPosition();\n#endif\n\n#ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n#endif\n\n    return pos;\n}\n\n#ifdef HAS_NORMALS\nvec4 getNormal()\n{\n    vec4 normal = a_Normal;\n\n#ifdef USE_MORPHING\n    normal += getTargetNormal();\n#endif\n\n#ifdef USE_SKINNING\n    normal = getSkinningNormalMatrix() * normal;\n#endif\n\n    return normalize(normal);\n}\n#endif\n\n#ifdef HAS_TANGENTS\nvec4 getTangent()\n{\n    vec4 tangent = a_Tangent;\n\n#ifdef USE_MORPHING\n    tangent += getTargetTangent();\n#endif\n\n#ifdef USE_SKINNING\n    tangent = getSkinningMatrix() * tangent;\n#endif\n\n    return normalize(tangent);\n}\n#endif\n\nvoid main()\n{\n    vec4 pos = u_ModelMatrix * getPosition();\n    v_Position = vec3(pos.xyz) / pos.w;\n\n    #ifdef HAS_NORMALS\n    #ifdef HAS_TANGENTS\n    vec4 tangent = getTangent();\n    vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(getNormal().xyz, 0.0)));\n    vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n    vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n    v_TBN = mat3(tangentW, bitangentW, normalW);\n    #else // !HAS_TANGENTS\n    v_Normal = normalize(vec3(u_NormalMatrix * vec4(getNormal().xyz, 0.0)));\n    #endif\n    #endif // !HAS_NORMALS\n\n    v_UVCoord1 = vec2(0.0, 0.0);\n    v_UVCoord2 = vec2(0.0, 0.0);\n\n    #ifdef HAS_UV_SET1\n    v_UVCoord1 = a_UV1;\n    #endif\n\n    #ifdef HAS_UV_SET2\n    v_UVCoord2 = a_UV2;\n    #endif\n\n    #if defined(HAS_VERTEX_COLOR_VEC3) || defined(HAS_VERTEX_COLOR_VEC4)\n    v_Color = a_Color;\n    #endif\n\n    #ifdef USE_SHADOW_MAPPING\n    v_PositionLightSpace = u_LightViewProjectionMatrix * pos;\n    #endif\n\n    gl_Position = u_ViewProjectionMatrix * pos;\n}\n"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){this.alphaCutoff=.5,this.alphaMode="OPAQUE",this.doubleSided=!1,this.roughness=1,this.metallic=1,this.emissive=[0,0,0],this.baseColor=[1,1,1,1],this.unlit=!1};n.glTFMaterial=r},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=function(){function e(n,t){var o=this;this.renderer=n,this.lights=[],this.renderer.on("prerender",(function(){var e,n;try{for(var t=r(o.lights),i=t.next();!i.done;i=t.next()){var a=i.value;a.parent||a.transform.updateTransform()}}catch(n){e={error:n}}finally{try{i&&!i.done&&(n=t.return)&&n.call(t)}finally{if(e)throw e.error}}})),e.main||(e.main=this),this._imageBasedLighting=t}return Object.defineProperty(e.prototype,"imageBasedLighting",{get:function(){return this._imageBasedLighting},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"valid",{get:function(){return!this._imageBasedLighting||this._imageBasedLighting.valid},enumerable:!0,configurable:!0}),e}();n.LightingEnvironment=o,PIXI.Renderer.registerPlugin("lighting",o)},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=function(){function e(e){this.name=e,this.speed=1}return e.prototype.play=function(e){var n=this;void 0===e&&(e=r.Ticker.shared),this._ticker||(this._update=function(){n.update(e.deltaMS/1e3*n.speed)},this._ticker=e.add(this._update))},e.prototype.stop=function(){this._ticker&&this._update&&(this._ticker.remove(this._update),this._ticker=this._update=void 0)},e}();n.Animation=o},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(4),o=function(){function e(e,n){this.parent=e,this.joints=n,this._arrayVertexMatrices=[],this._arrayNormalMatrices=[],this._jointVertexMatrices=new Float32Array(16*n.length),this._jointNormalMatrices=new Float32Array(16*n.length);for(var t=0;t<n.length;t++)this._arrayVertexMatrices.push(new Float32Array(this._jointVertexMatrices.buffer,64*t,16)),this._arrayNormalMatrices.push(new Float32Array(this._jointNormalMatrices.buffer,64*t,16))}return e.prototype.calculateJointMatrices=function(){for(var e=0;e<this.joints.length;e++)r.Mat4.multiply(this.joints[e].node.worldTransform.toArray(),this.joints[e].inverseBindMatrix,this._arrayVertexMatrices[e]),r.Mat4.multiply(this.parent.transform.inverseWorldTransform.toArray(),this._arrayVertexMatrices[e],this._arrayVertexMatrices[e]),r.Mat4.invert(this._arrayVertexMatrices[e],this._arrayNormalMatrices[e]),r.Mat4.transpose(this._arrayNormalMatrices[e],this._arrayNormalMatrices[e]);return{jointVertexMatrices:this._jointVertexMatrices,jointNormalMatrices:this._jointNormalMatrices}},e}();n.Skin=o},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(e,n){this.node=e,this.inverseBindMatrix=n};n.Joint=r},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),i=function(){function e(e,n){var t=this;this.renderer=e,this.name=n,this._colorTextureAutoResize=!0,this._transparent=[Object.assign(new o.State,{culling:!0,clockwiseFrontFace:!0,depthTest:!0}),Object.assign(new o.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0})],this._default=Object.assign(new o.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0}),this._doubleSided=Object.assign(new o.State,{culling:!1,clockwiseFrontFace:!0,depthTest:!0}),e.on("prerender",(function(){t._colorTexture&&t._colorTextureAutoResize&&t._colorTexture.resize(e.width,e.height)}))}return Object.defineProperty(e.prototype,"colorTexture",{get:function(){return this._colorTexture},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"depthTexture",{get:function(){if(this._colorTexture)return this._colorTexture.baseTexture.framebuffer.depthTexture},enumerable:!0,configurable:!0}),e.prototype.enableRenderToTexture=function(e,n){this._colorTexture=o.RenderTexture.create({width:e,height:n}),e&&n&&(this._colorTextureAutoResize=!1),this._colorTexture.baseTexture.framebuffer.addDepthTexture()},e.prototype.clear=function(){this._colorTexture&&(this.renderer.renderTexture.bind(this._colorTexture),this.renderer.renderTexture.clear(),this.renderer.renderTexture.bind(void 0))},e.prototype.render=function(e){var n,t;this._colorTexture&&this.renderer.renderTexture.bind(this._colorTexture);try{for(var o=r(e),i=o.next();!i.done;i=o.next()){var a=i.value;if(!a.material)return;a.material.doubleSided&&!a.material.transparent?a.material.render(a,this.renderer,this._doubleSided):a.material.doubleSided?(a.material.render(a,this.renderer,this._transparent[0]),a.material.render(a,this.renderer,this._transparent[1])):a.material.render(a,this.renderer,this._default)}}catch(e){n={error:e}}finally{try{i&&!i.done&&(t=o.return)&&t.call(o)}finally{if(n)throw n.error}}this._colorTexture&&this.renderer.renderTexture.bind(void 0)},e}();n.MaterialRenderPass=i},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(38);n.glTFLoader=r.glTFLoader;var o=t(20);n.glTFAsset=o.glTFAsset;var i=t(10);n.ObservablePoint3D=i.ObservablePoint3D;var a=t(21);n.ObservableQuaternion=a.ObservableQuaternion;var s=t(22);n.Transform3D=s.Transform3D;var u=t(1);n.Container3D=u.Container3D;var l=t(2);n.Camera=l.Camera;var f=t(39);n.CameraOrbitControl=f.CameraOrbitControl;var c=t(5);n.Mesh3D=c.Mesh3D;var d=t(6);n.MeshGeometry3D=d.MeshGeometry3D;var _=t(3);n.MeshShader=_.MeshShader;var h=t(17);n.Model=h.Model;var p=t(33);n.Animation=p.Animation;var g=t(7);n.LightType=g.LightType;var m=t(70);n.Light=m.Light;var v=t(32);n.LightingEnvironment=v.LightingEnvironment;var S=t(71);n.ImageBasedLighting=S.ImageBasedLighting;var y=t(73);n.StandardRenderer=y.StandardRenderer;var A=t(36);n.MaterialRenderPass=A.MaterialRenderPass;var T=t(16);n.Material=T.Material;var b=t(74);n.CubeMipmapLoader=b.CubeMipmapLoader;var M=t(18);n.CubeMipmapTexture=M.CubeMipmapTexture;var E=t(77);n.ShaderSourceLoader=E.ShaderSourceLoader;var O=t(78);n.Skybox=O.Skybox;var w=t(12);n.StandardMaterial=w.StandardMaterial;var x=t(14);n.StandardMaterialAlphaMode=x.StandardMaterialAlphaMode;var P=t(26);n.StandardMaterialDebugMode=P.StandardMaterialDebugMode;var C=t(82);n.PickingHitArea=C.PickingHitArea;var R=t(84);n.PickingManager=R.PickingManager;var I=t(34);n.Skin=I.Skin;var N=t(35);n.Joint=N.Joint;var L=t(88);n.ShadowRenderPass=L.ShadowRenderPass;var U=t(94);n.ShadowCastingLight=U.ShadowCastingLight;var G=t(19);n.ShadowQuality=G.ShadowQuality},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(20);n.glTFLoader={use:function(e,n){if("gltf"!==e.extension)return n();Object.assign(e,{gltf:o.glTFAsset.load(e.data,new i(this,e))}),n()},add:function(){r.LoaderResource.setExtensionXhrType("bin",r.LoaderResource.XHR_RESPONSE_TYPE.BUFFER),r.LoaderResource.setExtensionXhrType("gltf",r.LoaderResource.XHR_RESPONSE_TYPE.JSON)}},r.Loader.registerPlugin(n.glTFLoader);var i=function(){function e(e,n){this._loader=e,this._resource=n}return e.prototype.load=function(e,n){this._loader.add({parentResource:this._resource,url:this._resource.url.substring(0,this._resource.url.lastIndexOf("/")+1)+e,onComplete:n})},e}()},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(2),o=t(11),i=t(13),a=function(){function e(e,n){var t=this;void 0===n&&(n=r.Camera.main),this.camera=n,this._distance=5,this._angles=new PIXI.ObservablePoint((function(){t._angles.x=Math.min(Math.max(-85,t._angles.x),85)}),void 0,0,180),this.target={x:0,y:0,z:0},this.allowControl=!0,this.camera.renderer.on("prerender",(function(){t.updateCamera()})),e.addEventListener("mousemove",(function(e){t.allowControl&&1===e.buttons&&(t._angles.x+=.5*e.movementY,t._angles.y-=.5*e.movementX)})),e.addEventListener("mousewheel",(function(e){t.allowControl&&(t.distance+=.01*e.deltaY,e.preventDefault())}))}return Object.defineProperty(e.prototype,"angles",{get:function(){return this._angles},enumerable:!0,configurable:!0}),e.prototype.updateCamera=function(){var e=o.Quat.fromEuler(this._angles.x,this._angles.y,0,new Float32Array(4)),n=i.Vec3.transformQuat(i.Vec3.set(0,0,1,new Float32Array(3)),e,new Float32Array(3)),t=i.Vec3.subtract(i.Vec3.set(this.target.x,this.target.y,this.target.z,new Float32Array(3)),i.Vec3.scale(n,this.distance,new Float32Array(3)),new Float32Array(3));this.camera.position.set(t[0],t[1],t[2]),this.camera.rotationQuaternion.set(e[0],e[1],e[2],e[3])},Object.defineProperty(e.prototype,"distance",{get:function(){return this._distance},set:function(e){this._distance=Math.min(Math.max(e,.01),Number.MAX_SAFE_INTEGER)},enumerable:!0,configurable:!0}),e}();n.CameraOrbitControl=a},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(6);!function(e){e.create=function(){return Object.assign(new r.MeshGeometry3D,{positions:{buffer:new Float32Array([-1,0,1,1,0,-1,-1,0,-1,1,0,1])},indices:{buffer:new Uint8Array([0,1,2,0,3,1])},normals:{buffer:new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0])},uvs:[{buffer:new Float32Array([0,1,1,0,0,0,1,1])}]})}}(n.PlaneGeometry||(n.PlaneGeometry={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(6);!function(e){e.create=function(){return Object.assign(new r.MeshGeometry3D,{positions:{buffer:new Float32Array([-1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1])},indices:{buffer:new Uint8Array([0,1,2,0,3,1,4,5,6,4,7,5,8,9,10,8,11,9,12,13,14,12,15,13,16,17,18,16,19,17,20,21,22,20,23,21])},normals:{buffer:new Float32Array([-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0])},uvs:[{buffer:new Float32Array([.625,1,.375,.75,.375,1,.625,.75,.625,.75,.375,.5,.375,.75,.625,.5,.625,.5,.375,.25,.375,.5,.625,.25,.625,.25,.375,0,.375,.25,.625,0,.375,.25,.125,.5,.375,.5,.125,.25,.875,.25,.625,.5,.875,.5,.625,.25])}],tangents:{buffer:new Float32Array([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1])}})}}(n.CubeGeometry||(n.CubeGeometry={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(14),o=t(26),i=t(15);!function(e){e.build=function(e,n,t,a,s){var u=[];if(t.normals&&u.push("HAS_NORMALS 1"),t.uvs&&u.push("HAS_UV_SET1 1"),t.tangents&&u.push("HAS_TANGENTS 1"),t.targets){for(var l=0;l<t.targets.length;l++)t.targets[l].positions&&u.push("HAS_TARGET_POSITION"+l),t.targets[l].normals&&u.push("HAS_TARGET_NORMAL"+l),t.targets[l].tangents&&u.push("HAS_TARGET_TANGENT"+l);n.morphWeights&&(u.push("WEIGHT_COUNT "+n.morphWeights.length),u.push("USE_MORPHING 1"))}if(t.joints&&u.push("HAS_JOINT_SET1 1"),t.weights&&u.push("HAS_WEIGHT_SET1 1"),n.skin&&(u.push("USE_SKINNING 1"),u.push("JOINT_COUNT "+n.skin.joints.length)),a.unlit&&u.push("MATERIAL_UNLIT 1"),u.push("MATERIAL_METALLICROUGHNESS 1"),s.lights.length>0&&(u.push("LIGHT_COUNT "+s.lights.length),u.push("USE_PUNCTUAL 1")),s.imageBasedLighting){if(!s.imageBasedLighting.valid)return;i.Platform.isShaderTextureLodSupported(e)&&u.push("USE_TEX_LOD 1"),u.push("USE_IBL 1")}if(a.shadowCastingLight&&u.push("USE_SHADOW_MAPPING 1"),a.baseColorTexture){if(!a.baseColorTexture.valid)return;u.push("HAS_BASE_COLOR_MAP 1")}if(a.emissiveTexture){if(!a.emissiveTexture.valid)return;u.push("HAS_EMISSIVE_MAP 1")}if(a.normalTexture){if(!a.normalTexture.valid)return;u.push("HAS_NORMAL_MAP 1")}if(a.metallicRoughnessTexture){if(!a.metallicRoughnessTexture.valid)return;u.push("HAS_METALLIC_ROUGHNESS_MAP 1")}if(a.occlusionTexture){if(!a.occlusionTexture.valid)return;u.push("HAS_OCCLUSION_MAP 1")}switch(a.alphaMode){case r.StandardMaterialAlphaMode.opaque:u.push("ALPHAMODE_OPAQUE 1");break;case r.StandardMaterialAlphaMode.mask:u.push("ALPHAMODE_MASK 1")}switch(a.debugMode&&u.push("DEBUG_OUTPUT 1"),a.debugMode){case o.StandardMaterialDebugMode.alpha:u.push("DEBUG_ALPHA 1");break;case o.StandardMaterialDebugMode.emissive:u.push("DEBUG_EMISSIVE 1");break;case o.StandardMaterialDebugMode.f0:u.push("DEBUG_F0 1");break;case o.StandardMaterialDebugMode.metallic:u.push("DEBUG_METALLIC 1");break;case o.StandardMaterialDebugMode.normal:u.push("DEBUG_NORMAL 1");break;case o.StandardMaterialDebugMode.occlusion:u.push("DEBUG_OCCLUSION 1");break;case o.StandardMaterialDebugMode.roughness:u.push("DEBUG_ROUGHNESS 1")}return u}}(n.StandardMaterialFeatureSet||(n.StandardMaterialFeatureSet={}))},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(3),s=t(44),u=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return o(n,e),n.build=function(e,r){var o="webgl1";2===e.context.webGLVersion&&(o="webgl2");var a=t(56)("./primitive."+o+".vert").default,u=t(57)("./metallic-roughness."+o+".frag").default;return new n(i.Program.from(s.StandardShaderSource.build(a,r),s.StandardShaderSource.build(u,r)))},Object.defineProperty(n.prototype,"name",{get:function(){return"standard-shader"},enumerable:!0,configurable:!0}),n.prototype.addGeometryAttributes=function(n){if(e.prototype.addGeometryAttributes.call(this,n),n.targets)for(var t=0;t<n.targets.length;t++){var r=n.targets[t].positions;r&&n.addAttribute("a_Target_Position"+t,new i.Buffer(r.buffer),3,!1,r.componentType,r.stride);var o=n.targets[t].normals;o&&n.addAttribute("a_Target_Normal"+t,new i.Buffer(o.buffer),3,!1,o.componentType,o.stride);var a=n.targets[t].tangents;a&&n.addAttribute("a_Target_Tangent"+t,new i.Buffer(a.buffer),3,!1,a.componentType,a.stride)}n.joints&&n.addAttribute("a_Joint1",new i.Buffer(n.joints.buffer),4,!1,n.joints.componentType,n.joints.stride),n.weights&&n.addAttribute("a_Weight1",new i.Buffer(n.weights.buffer),4,!1,n.weights.componentType,n.weights.stride)},n}(a.MeshShader);n.StandardShader=u},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){e.build=function(e,n){for(var r;null!==(r=/#include <(.+)>/gm.exec(e));)e=e.replace(r[0],t(45)("./"+r[1]).default);return e.replace(/#define FEATURES/,n.map((function(e){return"#define "+e})).join("\n"))}}(n.StandardShaderSource||(n.StandardShaderSource={}))},function(e,n,t){var r={"./animation.webgl1.glsl":46,"./animation.webgl2.glsl":47,"./extensions.webgl1.glsl":48,"./functions.webgl1.glsl":49,"./functions.webgl2.glsl":50,"./metallic-roughness.webgl1.frag":27,"./metallic-roughness.webgl2.frag":28,"./primitive.webgl1.vert":29,"./primitive.webgl2.vert":30,"./shadow.webgl1.glsl":51,"./shadow.webgl2.glsl":52,"./textures.webgl1.glsl":53,"./textures.webgl2.glsl":54,"./tonemapping.glsl":55};function o(e){var n=i(e);return t(n)}function i(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=i,e.exports=o,o.id=45},function(e,n,t){"use strict";t.r(n),n.default="#ifdef HAS_TARGET_POSITION0\nattribute vec3 a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\nattribute vec3 a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\nattribute vec3 a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\nattribute vec3 a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\nattribute vec3 a_Target_Position4;\n#endif\n\n#ifdef HAS_TARGET_POSITION5\nattribute vec3 a_Target_Position5;\n#endif\n\n#ifdef HAS_TARGET_POSITION6\nattribute vec3 a_Target_Position6;\n#endif\n\n#ifdef HAS_TARGET_POSITION7\nattribute vec3 a_Target_Position7;\n#endif\n\n#ifdef HAS_TARGET_NORMAL0\nattribute vec3 a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\nattribute vec3 a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\nattribute vec3 a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\nattribute vec3 a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT0\nattribute vec3 a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\nattribute vec3 a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\nattribute vec3 a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\nattribute vec3 a_Target_Tangent3;\n#endif\n\n#ifdef USE_MORPHING\nuniform float u_morphWeights[WEIGHT_COUNT];\n#endif\n\n#ifdef HAS_JOINT_SET1\nattribute vec4 a_Joint1;\n#endif\n\n#ifdef HAS_JOINT_SET2\nattribute vec4 a_Joint2;\n#endif\n\n#ifdef HAS_WEIGHT_SET1\nattribute vec4 a_Weight1;\n#endif\n\n#ifdef HAS_WEIGHT_SET2\nattribute vec4 a_Weight2;\n#endif\n\n#ifdef USE_SKINNING\nuniform mat4 u_jointMatrix[JOINT_COUNT];\nuniform mat4 u_jointNormalMatrix[JOINT_COUNT];\n#endif\n\n#ifdef USE_SKINNING\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * u_jointMatrix[int(a_Joint1.x)] +\n        a_Weight1.y * u_jointMatrix[int(a_Joint1.y)] +\n        a_Weight1.z * u_jointMatrix[int(a_Joint1.z)] +\n        a_Weight1.w * u_jointMatrix[int(a_Joint1.w)];\n    #endif\n\n    #if defined(HAS_WEIGHT_SET2) && defined(HAS_JOINT_SET2)\n    skin +=\n        a_Weight2.x * u_jointMatrix[int(a_Joint2.x)] +\n        a_Weight2.y * u_jointMatrix[int(a_Joint2.y)] +\n        a_Weight2.z * u_jointMatrix[int(a_Joint2.z)] +\n        a_Weight2.w * u_jointMatrix[int(a_Joint2.w)];\n    #endif\n\n    return skin;\n}\n\nmat4 getSkinningNormalMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * u_jointNormalMatrix[int(a_Joint1.x)] +\n        a_Weight1.y * u_jointNormalMatrix[int(a_Joint1.y)] +\n        a_Weight1.z * u_jointNormalMatrix[int(a_Joint1.z)] +\n        a_Weight1.w * u_jointNormalMatrix[int(a_Joint1.w)];\n    #endif\n\n    #if defined(HAS_WEIGHT_SET2) && defined(HAS_JOINT_SET2)\n    skin +=\n        a_Weight2.x * u_jointNormalMatrix[int(a_Joint2.x)] +\n        a_Weight2.y * u_jointNormalMatrix[int(a_Joint2.y)] +\n        a_Weight2.z * u_jointNormalMatrix[int(a_Joint2.z)] +\n        a_Weight2.w * u_jointNormalMatrix[int(a_Joint2.w)];\n    #endif\n\n    return skin;\n}\n#endif // !USE_SKINNING\n\n#ifdef USE_MORPHING\nvec4 getTargetPosition()\n{\n    vec4 pos = vec4(0);\n\n#ifdef HAS_TARGET_POSITION0\n    pos.xyz += u_morphWeights[0] * a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\n    pos.xyz += u_morphWeights[1] * a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\n    pos.xyz += u_morphWeights[2] * a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\n    pos.xyz += u_morphWeights[3] * a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\n    pos.xyz += u_morphWeights[4] * a_Target_Position4;\n#endif\n\n    return pos;\n}\n\nvec4 getTargetNormal()\n{\n    vec4 normal = vec4(0);\n\n#ifdef HAS_TARGET_NORMAL0\n    normal.xyz += u_morphWeights[0] * a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\n    normal.xyz += u_morphWeights[1] * a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\n    normal.xyz += u_morphWeights[2] * a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\n    normal.xyz += u_morphWeights[3] * a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_NORMAL4\n    normal.xyz += u_morphWeights[4] * a_Target_Normal4;\n#endif\n\n    return normal;\n}\n\nvec4 getTargetTangent()\n{\n    vec4 tangent = vec4(0);\n\n#ifdef HAS_TARGET_TANGENT0\n    tangent.xyz += u_morphWeights[0] * a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\n    tangent.xyz += u_morphWeights[1] * a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\n    tangent.xyz += u_morphWeights[2] * a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\n    tangent.xyz += u_morphWeights[3] * a_Target_Tangent3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT4\n    tangent.xyz += u_morphWeights[4] * a_Target_Tangent4;\n#endif\n\n    return tangent;\n}\n\n#endif // !USE_MORPHING\n"},function(e,n,t){"use strict";t.r(n),n.default="#ifdef HAS_TARGET_POSITION0\nin vec3 a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\nin vec3 a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\nin vec3 a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\nin vec3 a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\nin vec3 a_Target_Position4;\n#endif\n\n#ifdef HAS_TARGET_POSITION5\nin vec3 a_Target_Position5;\n#endif\n\n#ifdef HAS_TARGET_POSITION6\nin vec3 a_Target_Position6;\n#endif\n\n#ifdef HAS_TARGET_POSITION7\nin vec3 a_Target_Position7;\n#endif\n\n#ifdef HAS_TARGET_NORMAL0\nin vec3 a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\nin vec3 a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\nin vec3 a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\nin vec3 a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT0\nin vec3 a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\nin vec3 a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\nin vec3 a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\nin vec3 a_Target_Tangent3;\n#endif\n\n#ifdef USE_MORPHING\nuniform float u_morphWeights[WEIGHT_COUNT];\n#endif\n\n#ifdef HAS_JOINT_SET1\nin vec4 a_Joint1;\n#endif\n\n#ifdef HAS_JOINT_SET2\nin vec4 a_Joint2;\n#endif\n\n#ifdef HAS_WEIGHT_SET1\nin vec4 a_Weight1;\n#endif\n\n#ifdef HAS_WEIGHT_SET2\nin vec4 a_Weight2;\n#endif\n\n#ifdef USE_SKINNING\nuniform mat4 u_jointMatrix[JOINT_COUNT];\nuniform mat4 u_jointNormalMatrix[JOINT_COUNT];\n#endif\n\n#ifdef USE_SKINNING\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * u_jointMatrix[int(a_Joint1.x)] +\n        a_Weight1.y * u_jointMatrix[int(a_Joint1.y)] +\n        a_Weight1.z * u_jointMatrix[int(a_Joint1.z)] +\n        a_Weight1.w * u_jointMatrix[int(a_Joint1.w)];\n    #endif\n\n    #if defined(HAS_WEIGHT_SET2) && defined(HAS_JOINT_SET2)\n    skin +=\n        a_Weight2.x * u_jointMatrix[int(a_Joint2.x)] +\n        a_Weight2.y * u_jointMatrix[int(a_Joint2.y)] +\n        a_Weight2.z * u_jointMatrix[int(a_Joint2.z)] +\n        a_Weight2.w * u_jointMatrix[int(a_Joint2.w)];\n    #endif\n\n    return skin;\n}\n\nmat4 getSkinningNormalMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * u_jointNormalMatrix[int(a_Joint1.x)] +\n        a_Weight1.y * u_jointNormalMatrix[int(a_Joint1.y)] +\n        a_Weight1.z * u_jointNormalMatrix[int(a_Joint1.z)] +\n        a_Weight1.w * u_jointNormalMatrix[int(a_Joint1.w)];\n    #endif\n\n    #if defined(HAS_WEIGHT_SET2) && defined(HAS_JOINT_SET2)\n    skin +=\n        a_Weight2.x * u_jointNormalMatrix[int(a_Joint2.x)] +\n        a_Weight2.y * u_jointNormalMatrix[int(a_Joint2.y)] +\n        a_Weight2.z * u_jointNormalMatrix[int(a_Joint2.z)] +\n        a_Weight2.w * u_jointNormalMatrix[int(a_Joint2.w)];\n    #endif\n\n    return skin;\n}\n#endif // !USE_SKINNING\n\n#ifdef USE_MORPHING\nvec4 getTargetPosition()\n{\n    vec4 pos = vec4(0);\n\n#ifdef HAS_TARGET_POSITION0\n    pos.xyz += u_morphWeights[0] * a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\n    pos.xyz += u_morphWeights[1] * a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\n    pos.xyz += u_morphWeights[2] * a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\n    pos.xyz += u_morphWeights[3] * a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\n    pos.xyz += u_morphWeights[4] * a_Target_Position4;\n#endif\n\n    return pos;\n}\n\nvec4 getTargetNormal()\n{\n    vec4 normal = vec4(0);\n\n#ifdef HAS_TARGET_NORMAL0\n    normal.xyz += u_morphWeights[0] * a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\n    normal.xyz += u_morphWeights[1] * a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\n    normal.xyz += u_morphWeights[2] * a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\n    normal.xyz += u_morphWeights[3] * a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_NORMAL4\n    normal.xyz += u_morphWeights[4] * a_Target_Normal4;\n#endif\n\n    return normal;\n}\n\nvec4 getTargetTangent()\n{\n    vec4 tangent = vec4(0);\n\n#ifdef HAS_TARGET_TANGENT0\n    tangent.xyz += u_morphWeights[0] * a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\n    tangent.xyz += u_morphWeights[1] * a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\n    tangent.xyz += u_morphWeights[2] * a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\n    tangent.xyz += u_morphWeights[3] * a_Target_Tangent3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT4\n    tangent.xyz += u_morphWeights[4] * a_Target_Tangent4;\n#endif\n\n    return tangent;\n}\n\n#endif // !USE_MORPHING\n"},function(e,n,t){"use strict";t.r(n),n.default="vec3 _dFdx(vec3 coord)\n{\n#ifdef GL_OES_standard_derivatives\n    return dFdx(coord);\n#endif\n    return vec3(0.0);\n}\n\nvec3 _dFdy(vec3 coord)\n{\n#ifdef GL_OES_standard_derivatives\n    return dFdy(coord);\n#endif\n    return vec3(0.0);\n}\n\n#ifdef USE_TEX_LOD\nvec4 _textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod)\n{\n#ifdef GL_EXT_shader_texture_lod\n    return textureCubeLodEXT(sampler, coord, lod);\n#endif\n    return vec4(0.0);\n}\n#endif"},function(e,n,t){"use strict";t.r(n),n.default="// textures.glsl needs to be included\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinReflectance = 0.04;\n\nvarying vec3 v_Position;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 v_TBN;\n#else\nvarying vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nvarying vec3 v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\nvarying vec4 v_Color;\n#endif\n\nstruct AngularInfo\n{\n    float NdotL;                  // cos angle between normal and light direction\n    float NdotV;                  // cos angle between normal and view direction\n    float NdotH;                  // cos angle between normal and half vector\n    float LdotH;                  // cos angle between light direction and half vector\n\n    float VdotH;                  // cos angle between view direction and half vector\n\n    vec3 padding;\n};\n\nvec4 getVertexColor()\n{\n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef HAS_VERTEX_COLOR_VEC3\n    color.rgb = v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\n    color = v_Color;\n#endif\n\n   return color;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    vec2 UV = getNormalUV();\n\n    // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n    vec3 pos_dx = _dFdx(v_Position);\n    vec3 pos_dy = _dFdy(v_Position);\n    vec3 tex_dx = _dFdx(vec3(UV, 0.0));\n    vec3 tex_dy = _dFdy(vec3(UV, 0.0));\n    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n    vec3 ng = normalize(v_Normal);\n#else\n    vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n    t = normalize(t - ng * dot(ng, t));\n    vec3 b = normalize(cross(ng, t));\n    mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n    mat3 tbn = v_TBN;\n#endif\n\n#ifdef HAS_NORMAL_MAP\n    vec3 n = texture2D(u_NormalSampler, UV).rgb;\n    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n    // The tbn matrix is linearly interpolated, so we need to re-normalize\n    vec3 n = normalize(tbn[2].xyz);\n#endif\n\n    return n;\n}\n\nfloat getPerceivedBrightness(vec3 vector)\n{\n    return sqrt(0.299 * vector.r * vector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34\nfloat solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecularStrength) {\n    float specularBrightness = getPerceivedBrightness(specular);\n\n    if (specularBrightness < c_MinReflectance) {\n        return 0.0;\n    }\n\n    float diffuseBrightness = getPerceivedBrightness(diffuse);\n\n    float a = c_MinReflectance;\n    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;\n    float c = c_MinReflectance - specularBrightness;\n    float D = b * b - 4.0 * a * c;\n\n    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);\n}\n\nAngularInfo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)\n{\n    // Standard one-letter names\n    vec3 n = normalize(normal);           // Outward direction of surface point\n    vec3 v = normalize(view);             // Direction from surface point to view\n    vec3 l = normalize(pointToLight);     // Direction from surface point to light\n    vec3 h = normalize(l + v);            // Direction of the vector between l and v\n\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    return AngularInfo(\n        NdotL,\n        NdotV,\n        NdotH,\n        LdotH,\n        VdotH,\n        vec3(0, 0, 0)\n    );\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="// textures.glsl needs to be included\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinReflectance = 0.04;\n\nin vec3 v_Position;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 v_TBN;\n#else\nin vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nin vec3 v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\nin vec4 v_Color;\n#endif\n\nstruct AngularInfo\n{\n    float NdotL;                  // cos angle between normal and light direction\n    float NdotV;                  // cos angle between normal and view direction\n    float NdotH;                  // cos angle between normal and half vector\n    float LdotH;                  // cos angle between light direction and half vector\n\n    float VdotH;                  // cos angle between view direction and half vector\n\n    vec3 padding;\n};\n\nvec4 getVertexColor()\n{\n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef HAS_VERTEX_COLOR_VEC3\n    color.rgb = v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\n    color = v_Color;\n#endif\n\n   return color;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    vec2 UV = getNormalUV();\n\n    // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n    vec3 pos_dx = dFdx(v_Position);\n    vec3 pos_dy = dFdy(v_Position);\n    vec3 tex_dx = dFdx(vec3(UV, 0.0));\n    vec3 tex_dy = dFdy(vec3(UV, 0.0));\n    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n    vec3 ng = normalize(v_Normal);\n#else\n    vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n    t = normalize(t - ng * dot(ng, t));\n    vec3 b = normalize(cross(ng, t));\n    mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n    mat3 tbn = v_TBN;\n#endif\n\n#ifdef HAS_NORMAL_MAP\n    vec3 n = texture(u_NormalSampler, UV).rgb;\n    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n    // The tbn matrix is linearly interpolated, so we need to re-normalize\n    vec3 n = normalize(tbn[2].xyz);\n#endif\n\n    return n;\n}\n\nfloat getPerceivedBrightness(vec3 vector)\n{\n    return sqrt(0.299 * vector.r * vector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34\nfloat solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecularStrength) {\n    float specularBrightness = getPerceivedBrightness(specular);\n\n    if (specularBrightness < c_MinReflectance) {\n        return 0.0;\n    }\n\n    float diffuseBrightness = getPerceivedBrightness(diffuse);\n\n    float a = c_MinReflectance;\n    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;\n    float c = c_MinReflectance - specularBrightness;\n    float D = b * b - 4.0 * a * c;\n\n    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);\n}\n\nAngularInfo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)\n{\n    // Standard one-letter names\n    vec3 n = normalize(normal);           // Outward direction of surface point\n    vec3 v = normalize(view);             // Direction from surface point to view\n    vec3 l = normalize(pointToLight);     // Direction from surface point to light\n    vec3 h = normalize(l + v);            // Direction of the vector between l and v\n\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    return AngularInfo(\n        NdotL,\n        NdotV,\n        NdotH,\n        LdotH,\n        VdotH,\n        vec3(0, 0, 0)\n    );\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="#ifdef USE_SHADOW_MAPPING\nvarying vec4 v_PositionLightSpace;\n#endif\n\nfloat linstep(float low, float high, float v)\n{\n    return clamp((v-low) / (high-low), 0.0, 1.0);\n}\n\n#ifdef USE_SHADOW_MAPPING\nfloat getShadowContribution()\n{\n    vec3 coords = v_PositionLightSpace.xyz / v_PositionLightSpace.w * 0.5 + 0.5;\n    if (coords.z < 0.01 || coords.z > 0.99 || coords.x < 0.01 || coords.x > 0.99 || coords.y < 0.01 || coords.y > 0.99) {\n        return 1.0;\n    }\n    vec2 moments = vec2(1.0) - texture2D(u_ShadowSampler, coords.xy).xy;\n    float p = step(coords.z, moments.x);\n    float variance = max(moments.y - moments.x * moments.x, 0.00002);\n    float d = coords.z - moments.x;\n    float pMax = linstep(0.2, 1.0, variance / (variance + d*d));\n    return min(max(p, pMax), 1.0);\n}\n#endif"},function(e,n,t){"use strict";t.r(n),n.default="#ifdef USE_SHADOW_MAPPING\nin vec4 v_PositionLightSpace;\n#endif\n\nfloat linstep(float low, float high, float v)\n{\n    return clamp((v-low) / (high-low), 0.0, 1.0);\n}\n\n#ifdef USE_SHADOW_MAPPING\nfloat getShadowContribution()\n{\n    vec3 coords = v_PositionLightSpace.xyz / v_PositionLightSpace.w * 0.5 + 0.5;\n    if (coords.z < 0.01 || coords.z > 0.99 || coords.x < 0.01 || coords.x > 0.99 || coords.y < 0.01 || coords.y > 0.99) {\n        return 1.0;\n    }\n    vec2 moments = vec2(1.0) - texture(u_ShadowSampler, coords.xy).xy;\n    float p = step(coords.z, moments.x);\n    float variance = max(moments.y - moments.x * moments.x, 0.00002);\n    float d = coords.z - moments.x;\n    float pMax = linstep(0.2, 1.0, variance / (variance + d*d));\n    return min(max(p, pMax), 1.0);\n}\n#endif"},function(e,n,t){"use strict";t.r(n),n.default="varying vec2 v_UVCoord1;\nvarying vec2 v_UVCoord2;\n\n// General Material\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\nuniform int u_NormalUVSet;\nuniform mat3 u_NormalUVTransform;\n#endif\n\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D u_EmissiveSampler;\nuniform int u_EmissiveUVSet;\nuniform vec3 u_EmissiveFactor;\nuniform mat3 u_EmissiveUVTransform;\n#endif\n\n#ifdef HAS_OCCLUSION_MAP\nuniform sampler2D u_OcclusionSampler;\nuniform int u_OcclusionUVSet;\nuniform float u_OcclusionStrength;\nuniform mat3 u_OcclusionUVTransform;\n#endif\n\n// Metallic Roughness Material\n#ifdef HAS_BASE_COLOR_MAP\nuniform sampler2D u_BaseColorSampler;\nuniform int u_BaseColorUVSet;\nuniform mat3 u_BaseColorUVTransform;\n#endif\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\nuniform sampler2D u_MetallicRoughnessSampler;\nuniform int u_MetallicRoughnessUVSet;\nuniform mat3 u_MetallicRoughnessUVTransform;\n#endif\n\n// Specular Glossiness Material\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D u_DiffuseSampler;\nuniform int u_DiffuseUVSet;\nuniform mat3 u_DiffuseUVTransform;\n#endif\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\nuniform sampler2D u_SpecularGlossinessSampler;\nuniform int u_SpecularGlossinessUVSet;\nuniform mat3 u_SpecularGlossinessUVTransform;\n#endif\n\n// IBL\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\n#endif\n\n#ifdef USE_SHADOW_MAPPING\nuniform sampler2D u_ShadowSampler;\n#endif\n\nvec2 getNormalUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_NORMAL_MAP\n    uv.xy = u_NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_NORMAL_UV_TRANSFORM\n    uv *= u_NormalUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getEmissiveUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_EMISSIVE_MAP\n    uv.xy = u_EmissiveUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_EMISSIVE_UV_TRANSFORM\n    uv *= u_EmissiveUVTransform;\n    #endif\n#endif\n\n    return uv.xy;\n}\n\nvec2 getOcclusionUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_OCCLUSION_MAP\n    uv.xy = u_OcclusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_OCCLSION_UV_TRANSFORM\n    uv *= u_OcclusionUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getBaseColorUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_BASE_COLOR_MAP\n    uv.xy = u_BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_BASECOLOR_UV_TRANSFORM\n    uv *= u_BaseColorUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getMetallicRoughnessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    uv.xy = u_MetallicRoughnessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM\n    uv *= u_MetallicRoughnessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getSpecularGlossinessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    uv.xy = u_SpecularGlossinessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\n    uv *= u_SpecularGlossinessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getDiffuseUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_DIFFUSE_MAP\n    uv.xy = u_DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_DIFFUSE_UV_TRANSFORM\n    uv *= u_DiffuseUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="in vec2 v_UVCoord1;\nin vec2 v_UVCoord2;\n\n// General Material\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\nuniform int u_NormalUVSet;\nuniform mat3 u_NormalUVTransform;\n#endif\n\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D u_EmissiveSampler;\nuniform int u_EmissiveUVSet;\nuniform vec3 u_EmissiveFactor;\nuniform mat3 u_EmissiveUVTransform;\n#endif\n\n#ifdef HAS_OCCLUSION_MAP\nuniform sampler2D u_OcclusionSampler;\nuniform int u_OcclusionUVSet;\nuniform float u_OcclusionStrength;\nuniform mat3 u_OcclusionUVTransform;\n#endif\n\n// Metallic Roughness Material\n#ifdef HAS_BASE_COLOR_MAP\nuniform sampler2D u_BaseColorSampler;\nuniform int u_BaseColorUVSet;\nuniform mat3 u_BaseColorUVTransform;\n#endif\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\nuniform sampler2D u_MetallicRoughnessSampler;\nuniform int u_MetallicRoughnessUVSet;\nuniform mat3 u_MetallicRoughnessUVTransform;\n#endif\n\n// Specular Glossiness Material\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D u_DiffuseSampler;\nuniform int u_DiffuseUVSet;\nuniform mat3 u_DiffuseUVTransform;\n#endif\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\nuniform sampler2D u_SpecularGlossinessSampler;\nuniform int u_SpecularGlossinessUVSet;\nuniform mat3 u_SpecularGlossinessUVTransform;\n#endif\n\n// IBL\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\n#endif\n\n#ifdef USE_SHADOW_MAPPING\nuniform sampler2D u_ShadowSampler;\n#endif\n\nvec2 getNormalUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_NORMAL_MAP\n    uv.xy = u_NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_NORMAL_UV_TRANSFORM\n    uv *= u_NormalUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getEmissiveUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_EMISSIVE_MAP\n    uv.xy = u_EmissiveUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_EMISSIVE_UV_TRANSFORM\n    uv *= u_EmissiveUVTransform;\n    #endif\n#endif\n\n    return uv.xy;\n}\n\nvec2 getOcclusionUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_OCCLUSION_MAP\n    uv.xy = u_OcclusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_OCCLSION_UV_TRANSFORM\n    uv *= u_OcclusionUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getBaseColorUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_BASE_COLOR_MAP\n    uv.xy = u_BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_BASECOLOR_UV_TRANSFORM\n    uv *= u_BaseColorUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getMetallicRoughnessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    uv.xy = u_MetallicRoughnessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM\n    uv *= u_MetallicRoughnessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getSpecularGlossinessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    uv.xy = u_SpecularGlossinessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\n    uv *= u_SpecularGlossinessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getDiffuseUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_DIFFUSE_MAP\n    uv.xy = u_DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_DIFFUSE_UV_TRANSFORM\n    uv *= u_DiffuseUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n"},function(e,n,t){"use strict";t.r(n),n.default="uniform float u_Exposure;\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\n// linear to sRGB approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec3 LINEARtoSRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\n// sRGB to linear approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\n// Uncharted 2 tone map\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapUncharted2Impl(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\n\nvec3 toneMapUncharted(vec3 color)\n{\n    const float W = 11.2;\n    color = toneMapUncharted2Impl(color * 2.0);\n    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\n    return LINEARtoSRGB(color * whiteScale);\n}\n\n// Hejl Richard tone map\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapHejlRichard(vec3 color)\n{\n    color = max(vec3(0.0), color - vec3(0.004));\n    return (color*(6.2*color+.5))/(color*(6.2*color+1.7)+0.06);\n}\n\n// ACES tone map\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return LINEARtoSRGB(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0));\n}\n\nvec3 toneMap(vec3 color)\n{\n    color *= u_Exposure;\n\n#ifdef TONEMAP_UNCHARTED\n    return toneMapUncharted(color);\n#endif\n\n#ifdef TONEMAP_HEJLRICHARD\n    return toneMapHejlRichard(color);\n#endif\n\n#ifdef TONEMAP_ACES\n    return toneMapACES(color);\n#endif\n\n    return LINEARtoSRGB(color);\n}\n"},function(e,n,t){var r={"./primitive.webgl1.vert":29,"./primitive.webgl2.vert":30};function o(e){var n=i(e);return t(n)}function i(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=i,e.exports=o,o.id=56},function(e,n,t){var r={"./metallic-roughness.webgl1.frag":27,"./metallic-roughness.webgl2.frag":28};function o(e){var n=i(e);return t(n)}function i(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=i,e.exports=o,o.id=57},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(6);!function(e){e.create=function(){return Object.assign(new r.MeshGeometry3D,{positions:{buffer:new Float32Array([-1,1,0,1,-1,0,-1,-1,0,1,1,0])},indices:{buffer:new Uint8Array([0,2,1,0,1,3])},normals:{buffer:new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1])},uvs:[{buffer:new Float32Array([0,0,1,1,0,1,1,0])}]})}}(n.QuadGeometry||(n.QuadGeometry={}))},function(e,n,t){"use strict";var r,o=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(8),s=t(68),u=t(69),l=t(31),f=t(5),c=t(1),d=t(12),_=t(6),h=t(17),p=t(23),g=t(34),m=t(35),v=function(){function e(e,n){this._asset=e,this._materialFactory=n||d.StandardMaterial,this._descriptor=this._asset.descriptor}return e.createModel=function(n,t){return new e(n,t).parseModel()},e.createMesh=function(n,t,r){return void 0===r&&(r=0),new e(n,t).parseMesh(r)},e.prototype.parseBuffer=function(e){if(void 0!==e){"number"==typeof e&&(e=this._asset.descriptor.accessors[e]);var n=this._descriptor.bufferViews[e.bufferView||0],t=e.byteOffset||0;void 0!==n.byteOffset&&(t+=n.byteOffset);var r=e.count*S[e.type];void 0!==n.byteStride&&(r*=n.byteStride/y[e.componentType]/S[e.type]);var o=this._asset.buffers[n.buffer];return u.glTFBufferView.from(e.componentType,o,t,r,n.byteStride)}},e.prototype.parseAnimation=function(e,n){var t,r;"number"==typeof e&&(e=this._asset.descriptor.animations[e]);var i=new s.glTFAnimation(e.name);try{for(var u=o(e.channels),l=u.next();!l.done;l=u.next()){var f=l.value,c=e.samplers[f.sampler],d=this.parseBuffer(c.input);if(void 0!==d){var _=this.parseBuffer(c.output);if(void 0!==_){var h=a.glTFChannel.from(d.buffer,_.buffer,c.interpolation||"LINEAR",f.target.path,n[f.target.node]);h&&i.channels.push(h)}}}}catch(e){t={error:e}}finally{try{l&&!l.done&&(r=u.return)&&r.call(u)}finally{if(t)throw t.error}}return i},e.prototype.parseMaterial=function(e){"number"==typeof e&&(e=this._asset.descriptor.materials[e]);var n=new l.glTFMaterial;if(!e)return this._materialFactory.create(n);n.occlusionTexture=this.parseTexture(e.occlusionTexture),n.normalTexture=this.parseTexture(e.normalTexture),n.emissiveTexture=this.parseTexture(e.emissiveTexture),void 0!==e.doubleSided&&(n.doubleSided=e.doubleSided),e.emissive&&(n.emissive=e.emissive),e.alphaMode&&(n.alphaMode=e.alphaMode),void 0!==e.alphaCutoff&&(n.alphaCutoff=e.alphaCutoff);var t=e.pbrMetallicRoughness;return n.metallicRoughnessTexture=this.parseTexture(null==t?void 0:t.metallicRoughnessTexture),(null==t?void 0:t.baseColorFactor)&&(n.baseColor=t.baseColorFactor),n.baseColorTexture=this.parseTexture(null==t?void 0:t.baseColorTexture),n.baseColorTexture&&(n.baseColorTexture.baseTexture.alphaMode=i.ALPHA_MODES.PREMULTIPLIED_ALPHA),void 0!==(null==t?void 0:t.metallicFactor)&&(n.metallic=t.metallicFactor),void 0!==(null==t?void 0:t.roughnessFactor)&&(n.roughness=t.roughnessFactor),e.extensions&&(n.unlit=null!=e.extensions.KHR_materials_unlit),this._materialFactory.create(n)},e.prototype.parseTexture=function(e){if(void 0!==e)return"number"==typeof e&&(e={index:e}),this._asset.images[this._descriptor.textures[e.index].source]},e.prototype.parseMesh=function(e){var n=this;"number"==typeof e&&(e=this._asset.descriptor.meshes[e]);var t=e.weights||[];return e.primitives.map((function(r){return Object.assign(n.parsePrimitive(r),{name:e.name,morphWeights:t})}))},e.prototype.parseSkin=function(e,n,t){"number"==typeof e&&(e=this._asset.descriptor.skins[e]);var r=this.parseBuffer(e.inverseBindMatrices),o=[];if(r)for(var i=0;i<e.joints.length;i++)o.push(new m.Joint(t[e.joints[i]],r.buffer.slice(16*i,16*i+16)));return new g.Skin(n,o)},e.prototype.parsePrimitive=function(e){for(var n,t=e.attributes,r=e.targets,o=Object.assign(new _.MeshGeometry3D,{indices:this.parseBuffer(e.indices),positions:this.parseBuffer(t.POSITION),normals:this.parseBuffer(t.NORMAL),tangents:this.parseBuffer(t.TANGENT),joints:this.parseBuffer(t.JOINTS_0),weights:this.parseBuffer(t.WEIGHTS_0)}),i=0;;i++){var a=this.parseBuffer(t["TEXCOORD_"+i]);if(void 0===a)break;o.uvs=o.uvs||[],o.uvs.push(a)}if(r)for(i=0;i<r.length;i++)o.targets=o.targets||[],o.targets.push({positions:this.parseBuffer(r[i].POSITION),normals:this.parseBuffer(r[i].NORMAL),tangents:this.parseBuffer(r[i].TANGENT)});return n=void 0!==e.material?this.parseMaterial(this._asset.descriptor.materials[e.material]):this.parseMaterial(),new f.Mesh3D(o,n)},e.prototype.parseNode=function(e){"number"==typeof e&&(e=this._asset.descriptor.nodes[e]);var n=Object.assign(new c.Container3D,{name:e.name});return e.translation&&n.position.set(e.translation[0],e.translation[1],e.translation[2]),e.rotation&&n.rotationQuaternion.set(e.rotation[0],e.rotation[1],e.rotation[2],e.rotation[3]),e.scale&&n.scale.set(e.scale[0],e.scale[1],e.scale[2]),e.matrix&&n.transform.setFromMatrix(new p.TransformMatrix(e.matrix)),n},e.prototype.parseModel=function(){var e,n,t,r,i=this,a=this._descriptor.nodes.map((function(e){return i.parseNode(e)})),s=this._descriptor.scenes[this._asset.descriptor.scene||0],u=new h.Model,l=function(e,n){var t,r,s,f,c,d=i._asset.descriptor.nodes[n].mesh;if(void 0!==i._asset.descriptor.nodes[n].skin&&(c=i.parseSkin(i._asset.descriptor.nodes[n].skin,a[n],a)),void 0!==d)try{for(var _=o(i.parseMesh(d)),h=_.next();!h.done;h=_.next()){var p=h.value;u.meshes.push(a[n].addChild(p)),u.meshes[u.meshes.length-1].skin=c}}catch(e){t={error:e}}finally{try{h&&!h.done&&(r=_.return)&&r.call(_)}finally{if(t)throw t.error}}if(e.addChild(a[n]),i._asset.descriptor.nodes[n].children)try{for(var g=o(i._asset.descriptor.nodes[n].children),m=g.next();!m.done;m=g.next()){var v=m.value;l(a[n],v)}}catch(e){s={error:e}}finally{try{m&&!m.done&&(f=g.return)&&f.call(g)}finally{if(s)throw s.error}}};try{for(var f=o(s.nodes),c=f.next();!c.done;c=f.next()){var d=c.value;l(u,d)}}catch(n){e={error:n}}finally{try{c&&!c.done&&(n=f.return)&&n.call(f)}finally{if(e)throw e.error}}if(this._asset.descriptor.animations)try{for(var _=o(this._asset.descriptor.animations),p=_.next();!p.done;p=_.next()){var g=p.value;u.animations.push(this.parseAnimation(g,a))}}catch(e){t={error:e}}finally{try{p&&!p.done&&(r=_.return)&&r.call(_)}finally{if(t)throw t.error}}return u},e}();n.glTFParser=v;var S={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},y=((r={})[5120]=1,r[5121]=1,r[5122]=2,r[5123]=2,r[5125]=4,r[5126]=4,r)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t){var r=e.call(this)||this;return r._output=n,r._stride=t,r._data=new Float32Array(t),r}return o(n,e),n.prototype.interpolate=function(e,n){for(var t=(e+0)*this._stride,r=(e+1)*this._stride,o=0;o<this._stride;o++)this._data[o]=(1-n)*this._output[t+o]+n*this._output[r+o];return this._data},n}(t(9).glTFInterpolation);n.glTFLinear=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this)||this;return o._input=n,o._output=t,o._stride=r,o._data=new Float32Array(r),o}return o(n,e),n.prototype.interpolate=function(e,t){for(var r=this._input[e+1]-this._input[e],o=(e+0)*this._stride*3,i=(e+1)*this._stride*3,a=0;a<this._stride;a++)this._data[a]=n.calculate(t,this._output[o+a+1*this._stride],this._output[i+a+1*this._stride],r*this._output[i+a],r*this._output[o+a+2*this._stride]);return this._data},n.calculate=function(e,n,t,r,o){return(2*Math.pow(e,3)-3*Math.pow(e,2)+1)*n+(Math.pow(e,3)-2*Math.pow(e,2)+e)*r+(-2*Math.pow(e,3)+3*Math.pow(e,2))*t+(Math.pow(e,3)-Math.pow(e,2))*o},n}(t(9).glTFInterpolation);n.glTFCubicSpline=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t){var r=e.call(this)||this;return r._output=n,r._stride=t,r._data=new Float32Array(t),r}return o(n,e),n.prototype.interpolate=function(e){for(var n=0;n<this._stride;n++)this._data[n]=this._output[e*this._stride+n];return this._data},n}(t(9).glTFInterpolation);n.glTFStep=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(11),a=function(e){function n(n){var t=e.call(this)||this;return t._output=n,t._data=new Float32Array(4),t}return o(n,e),n.prototype.interpolate=function(e,n){var t=4*(e+0),r=4*(e+1),o=i.Quat.set(this._output[t],this._output[t+1],this._output[t+2],this._output[t+3],new Float32Array(4)),a=i.Quat.set(this._output[r],this._output[r+1],this._output[r+2],this._output[r+3],new Float32Array(4));return i.Quat.normalize(i.Quat.slerp(o,a,n,this._data),this._data)},n}(t(9).glTFInterpolation);n.glTFSphericalLinear=a},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this,t,r)||this;return o._transform=n,o}return o(n,e),n.prototype.updateTarget=function(e){this._transform.scale.set(e[0],e[1],e[2])},n}(t(8).glTFChannel);n.glTFScale=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this,t,r)||this;return o._weights=n,o}return o(n,e),n.prototype.updateTarget=function(e){for(var n=0;n<e.length;n++)this._weights[n]=e[n]},n}(t(8).glTFChannel);n.glTFWeights=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this,t,r)||this;return o._transform=n,o}return o(n,e),n.prototype.updateTarget=function(e){this._transform.rotationQuaternion.set(e[0],e[1],e[2],e[3])},n}(t(8).glTFChannel);n.glTFRotation=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t,r){var o=e.call(this,t,r)||this;return o._transform=n,o}return o(n,e),n.prototype.updateTarget=function(e){this._transform.position.set(e[0],e[1],e[2])},n}(t(8).glTFChannel);n.glTFTranslation=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),i=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var a=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.channels=[],n}return o(n,e),n.prototype.update=function(e){var n,t;try{for(var r=i(this.channels),o=r.next();!o.done;o=r.next()){o.value.update(e)}}catch(e){n={error:e}}finally{try{o&&!o.done&&(t=r.return)&&t.call(r)}finally{if(n)throw n.error}}},n}(t(33).Animation);n.glTFAnimation=a},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,n,t){void 0===t&&(t=0),this.buffer=e,this.componentType=n,this.stride=t}return e.from=function(n,t,r,o,i){switch(n){case 5125:return new e(new Uint32Array(t,r,o),n,i);case 5126:return new e(new Float32Array(t,r,o),n,i);case 5120:return new e(new Int8Array(t,r,o),n,i);case 5121:return new e(new Uint8Array(t,r,o),n,i);case 5122:return new e(new Int16Array(t,r,o),n,i);case 5123:return new e(new Uint16Array(t,r,o),n,i);default:throw new Error('PIXI3D: Unknown component type "'+n+'".')}},e}();n.glTFBufferView=r},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(1),a=t(7),s=function(e){function n(){var n=null!==e&&e.apply(this,arguments)||this;return n.type=a.LightType.point,n.color=[1,1,1],n.range=10,n.intensity=10,n.innerConeAngle=0,n.outerConeAngle=45,n}return o(n,e),n}(i.Container3D);n.Light=s},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=function(){function e(e,n,o){this._diffuse=e,this._brdf=o||r.Texture.from(t(72).default),this._specular=n}return Object.defineProperty(e.prototype,"diffuse",{get:function(){return this._diffuse},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"brdf",{get:function(){return this._brdf},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"specular",{get:function(){return this._specular},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"valid",{get:function(){return this._diffuse.valid&&this._specular.valid&&this._brdf.valid},enumerable:!0,configurable:!0}),e}();n.ImageBasedLighting=o},function(e,n,t){"use strict";t.r(n),n.default="data:image/png;base64,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"},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),i=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),s=t(36),u=function(e){function n(n){var t=e.call(this,n)||this;return t.renderer=n,t._meshes=[],t.renderPasses=[new s.MaterialRenderPass(n,"standard")],n.on("prerender",(function(){var e,n;try{for(var r=i(t.renderPasses),o=r.next();!o.done;o=r.next()){var a=o.value;a.clear&&a.clear()}}catch(n){e={error:n}}finally{try{o&&!o.done&&(n=r.return)&&n.call(r)}finally{if(e)throw e.error}}})),t}return o(n,e),n.prototype.render=function(e){this._meshes.push(e)},n.prototype.flush=function(){var e,n;this.sort();var t=function(e){e.render(r._meshes.filter((function(n){return n.renderPasses.indexOf(e.name)>=0})))},r=this;try{for(var o=i(this.renderPasses),a=o.next();!a.done;a=o.next()){t(a.value)}}catch(n){e={error:n}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(e)throw e.error}}this._meshes=[]},n.prototype.sort=function(){this._meshes.sort((function(e,n){return e.material&&n.material?e.material.transparent===n.material.transparent?0:e.material.transparent?1:-1:0}))},n}(a.ObjectRenderer);n.StandardRenderer=u,a.Renderer.registerPlugin("mesh3d",u)},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(18);n.CubeMipmapLoader={use:function(e,n){if("cubemap"!==e.extension)return n();var t=this,r=e.data.map((function(n){return e.url.substring(0,e.url.lastIndexOf("/")+1)+n})),i=o.CubeMipmapTexture.faces.map((function(e){return r.map((function(n){return n.replace("{{face}}",e)}))})).reduce((function(e,n){return e.concat(n)}),[]);t.add(i.filter((function(e){return!t.resources[e]})).map((function(n){return{parentResource:e,url:n}})));var a=0,s=t.onLoad.add((function(n,t){i.includes(t.url)&&++a===i.length&&(e.texture=o.CubeMipmapTexture.fromSource(r),s.detach())}));n()},add:function(){r.LoaderResource.setExtensionXhrType("cubemap",r.LoaderResource.XHR_RESPONSE_TYPE.JSON)}},r.Loader.registerPlugin(n.CubeMipmapLoader)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t){var r=e.call(this,n)||this;return r.target=t,r}return o(n,e),n.prototype.upload=function(e,n){for(var t=0;t<this.items.length;t++){var r=this.items[t].resource.source;e.gl.texImage2D(this.target,t,n.format,n.format,n.type,r)}return!0},n}(t(0).resources.ArrayResource);n.MipmapResource=i},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){function n(n,t){void 0===t&&(t=1);var r=e.call(this,n)||this;return r.levels=t,r}return o(n,e),n.prototype.style=function(e){var n=e.gl;return n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),this.levels>1?n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR):n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR),!0},n}(PIXI.resources.CubeResource);n.CubeMipmapResource=i},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),i=["glsl","vert","frag"];n.ShaderSourceLoader={use:function(e,n){if(!i.includes(e.extension))return n();n()},add:function(){var e,n;try{for(var t=r(i),a=t.next();!a.done;a=t.next()){var s=a.value;o.LoaderResource.setExtensionXhrType(s,o.LoaderResource.XHR_RESPONSE_TYPE.TEXT)}}catch(n){e={error:n}}finally{try{a&&!a.done&&(n=t.return)&&n.call(t)}finally{if(e)throw e.error}}}},o.Loader.registerPlugin(n.ShaderSourceLoader)},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(79),a=t(5),s=t(1),u=t(18),l=function(e){function n(n){var t=e.call(this)||this;return t._mesh=t.addChild(a.Mesh3D.createCube(new i.SkyboxMaterial(n))),t}return o(n,e),Object.defineProperty(n.prototype,"camera",{get:function(){return this._mesh.material.camera},set:function(e){this._mesh.material.camera=e},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"texture",{get:function(){return this._mesh.material.texture},set:function(e){this._mesh.material.texture=e},enumerable:!0,configurable:!0}),n.from=function(e){return new n(u.CubeMipmapTexture.fromSource([e]))},n}(s.Container3D);n.Skybox=l},function(e,n,t){"use strict";var r,o=this&&this.__extends||(r=function(e,n){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});Object.defineProperty(n,"__esModule",{value:!0});var i=t(0),a=t(2),s=t(16),u=t(3),l=function(e){function n(n){var t=e.call(this)||this;return t._texture=n,t._state=Object.assign(new i.State,{culling:!0,clockwiseFrontFace:!0,depthTest:!0}),t}return o(n,e),Object.defineProperty(n.prototype,"texture",{get:function(){return this._texture},set:function(e){e!==this._texture&&(this._texture.valid||(this._shader=void 0),this._texture=e)},enumerable:!0,configurable:!0}),n.prototype.updateUniforms=function(e,n){var t=this.camera||a.Camera.main;n.uniforms.u_ModelMatrix=e.worldTransform.toArray(),n.uniforms.u_View=t.view,n.uniforms.u_Projection=t.projection,n.uniforms.u_EnvironmentSampler=this.texture},n.prototype.render=function(n,t){t.gl.depthMask(!1),e.prototype.render.call(this,n,t,this._state),t.gl.depthMask(!0)},n.prototype.createShader=function(){var e=t(80).default,n=t(81).default;if(this.texture.valid)return new u.MeshShader(i.Program.from(e,n))},n}(s.Material);n.SkyboxMaterial=l},function(e,n,t){"use strict";t.r(n),n.default="attribute vec3 a_Position;\n\nvarying vec3 v_Position;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\nvoid main() {\n  v_Position = a_Position.xyz;\n\n  // Converting the view to 3x3 matrix and then back to 4x4 matrix \n  // removes the translation. We do this because we want the skybox to \n  // be centered around the camera.\n  gl_Position = u_Projection * mat4(mat3(u_View)) * u_ModelMatrix * vec4(a_Position, 1.0);\n}"},function(e,n,t){"use strict";t.r(n),n.default="varying vec3 v_Position;\n\nuniform samplerCube u_EnvironmentSampler;\n\nvoid main() {\n  gl_FragColor = vec4(textureCube(u_EnvironmentSampler, v_Position).rgb, 1.0);\n}"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(83),o=function(){function e(e,n,t){this.object=n,this.camera=t,this.id=r.PickingId.next(),this._manager=e.plugins.picking}return e.prototype.contains=function(e,n){return this._manager.containsHitArea(e,n,this)},e}();n.PickingHitArea=o},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),function(e){var n=0;e.next=function(){return n++,new Uint8Array([n>>16&255,n>>8&255,255&n])}}(n.PickingId||(n.PickingId={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(85),i=function(){function e(e){var n=this;this.renderer=e,this._hitAreas=[],this._map=new o.PickingMap(this.renderer,128*Math.floor(this.renderer.width/this.renderer.height),128),e.on("postrender",(function(){if(n.renderer.plugins.interaction.hitTest(new r.Point(0,0)),0!==n._hitAreas.length){var e=Math.floor(n._map.height*(n.renderer.width/n.renderer.height));n._map.width!==e&&n._map.resize(e,n._map.height),n._map.update(n._hitAreas),n._hitAreas=[]}}))}return e.prototype.containsHitArea=function(e,n,t){return this._hitAreas.indexOf(t)<0&&this._hitAreas.push(t),this._map.containsId(e,n,t.id)},e}();n.PickingManager=i,r.Renderer.registerPlugin("picking",i)},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),i=t(2),a=t(5),s=t(3),u=function(){function e(e,n,r){this._renderer=e,this._update=0,this._pixels=new Uint8Array(n*r*4),this._output=o.RenderTexture.create({width:n,height:r}),this._shader=new s.MeshShader(o.Program.from(t(86).default,t(87).default)),this._output.framebuffer.addDepthTexture()}return e.prototype.resize=function(e,n){this._pixels=new Uint8Array(e*n*4),this._output.resize(e,n)},e.prototype.containsId=function(e,n,t){e=Math.floor(e/this._renderer.width*this._output.width),n=Math.floor((this._renderer.height-n)/this._renderer.height*this._output.height);for(var r=0;r<3;r++)if(t[r]!==this._pixels[4*(n*this._output.width+e)+r])return!1;return!0},Object.defineProperty(e.prototype,"width",{get:function(){return this._output.width},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this._output.height},enumerable:!0,configurable:!0}),e.prototype.update=function(e){var n,t,o,s;if(this._renderer.renderTexture.bind(this._output),this._update++%2==0){this._renderer.renderTexture.clear();try{for(var u=r(e),l=u.next();!l.done;l=u.next()){var f=l.value,c=f.object instanceof a.Mesh3D?[f.object]:f.object.meshes,d=f.camera||i.Camera.main;try{for(var _=(o=void 0,r(c)),h=_.next();!h.done;h=_.next()){var p=h.value;this._shader.uniforms.u_World=p.transform.worldTransform.toArray(),this._shader.uniforms.u_Id=f.id,this._shader.uniforms.u_ViewProjection=d.viewProjection,this._shader.render(p,this._renderer)}}catch(e){o={error:e}}finally{try{h&&!h.done&&(s=_.return)&&s.call(_)}finally{if(o)throw o.error}}}}catch(e){n={error:e}}finally{try{l&&!l.done&&(t=u.return)&&t.call(u)}finally{if(n)throw n.error}}}else{var g=this._renderer.gl;g.readPixels(0,0,this._output.width*this._renderer.resolution,this._output.height*this._renderer.resolution,g.RGBA,g.UNSIGNED_BYTE,this._pixels)}this._renderer.renderTexture.bind(void 0)},e}();n.PickingMap=u},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\nattribute vec3 a_Position;\n\nuniform mat4 u_World;\nuniform mat4 u_ViewProjection;\n\nvoid main() {\n  gl_Position = u_ViewProjection * u_World * vec4(a_Position, 1.0);\n}"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\nprecision highp float;\n\nuniform vec3 u_Id;\n\nvoid main() {\n  gl_FragColor = vec4(u_Id / 255.0, 1.0);\n}"},function(e,n,t){"use strict";var r=this&&this.__values||function(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),i=t(3),a=t(89),s=t(17),u=t(12),l=function(){function e(e,n){void 0===n&&(n="shadow"),this.renderer=e,this.name=n,this._state=Object.assign(new o.State,{depthTest:!0,clockwiseFrontFace:!1,culling:!0,blendMode:o.BLEND_MODES.NONE}),this.lights=[],this._filter=new a.ShadowFilter(e),this._shader=new i.MeshShader(o.Program.from(t(92).default,t(93).default))}return e.addAsRenderPass=function(n,t){void 0===t&&(t="shadow");var r=new e(n,t);return n.plugins.mesh3d.renderPasses.splice(0,0,r),r},e.prototype.enableShadows=function(e,n){var t,o,i=e instanceof s.Model?e.meshes:[e];try{for(var a=r(i),l=a.next();!l.done;l=a.next()){var f=l.value;n&&f.material instanceof u.StandardMaterial&&(f.material.shadowCastingLight=n),f.renderPasses.push(this.name)}}catch(e){t={error:e}}finally{try{l&&!l.done&&(o=a.return)&&o.call(a)}finally{if(t)throw t.error}}},e.prototype.clear=function(){var e,n;try{for(var t=r(this.lights),o=t.next();!o.done;o=t.next()){o.value.clear()}}catch(n){e={error:n}}finally{try{o&&!o.done&&(n=t.return)&&n.call(t)}finally{if(e)throw e.error}}},e.prototype.render=function(e){var n,t,o,i;try{for(var a=r(this.lights),s=a.next();!s.done;s=a.next()){var u=s.value;this.renderer.renderTexture.bind(u.shadowTexture),u.updateLightViewProjection();try{for(var l=(o=void 0,r(e)),f=l.next();!f.done;f=l.next()){var c=f.value;this._shader.uniforms.u_World=c.worldTransform.toArray(),this._shader.uniforms.u_ViewProjection=u.lightViewProjection,this._shader.render(c,this.renderer,this._state)}}catch(e){o={error:e}}finally{try{f&&!f.done&&(i=l.return)&&i.call(l)}finally{if(o)throw o.error}}this.renderer.renderTexture.bind(void 0),u.softness>0&&this._filter.applyGaussianBlur(u)}}catch(e){n={error:e}}finally{try{s&&!s.done&&(t=a.return)&&t.call(a)}finally{if(n)throw n.error}}},e}();n.ShadowRenderPass=l},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(3),i=t(5),a=function(){function e(e){this.renderer=e,this._mesh=i.Mesh3D.createQuad(),this._gaussianBlurShader=new o.MeshShader(r.Program.from(t(90).default,t(91).default))}return e.prototype.applyGaussianBlur=function(e){this.applyBlurScale(e.shadowTexture,e.filterTexture,new Float32Array([0,e.softness/e.shadowTexture.height])),this.applyBlurScale(e.filterTexture,e.shadowTexture,new Float32Array([e.softness/e.shadowTexture.width,0]))},e.prototype.applyBlurScale=function(e,n,t){this.renderer.renderTexture.bind(n),this.renderer.renderTexture.clear(),this._gaussianBlurShader.uniforms.u_FilterSampler=e,this._gaussianBlurShader.uniforms.u_BlurScale=t,this._gaussianBlurShader.render(this._mesh,this.renderer),this.renderer.renderTexture.bind(void 0)},e}();n.ShadowFilter=a},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\nattribute vec3 a_Position;\nattribute vec2 a_UV1;\n\nvarying vec2 v_UV1;\n\nvoid main() {\n  v_UV1 = a_UV1;\n  gl_Position = vec4(a_Position, 1.0);\n}"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\nprecision highp float;\n\nvarying vec2 v_UV1;\n\nuniform vec2 u_BlurScale;\nuniform sampler2D u_FilterSampler;\n\nvoid main() {\n  vec4 color = vec4(0.0);\n\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-3.0) * u_BlurScale.xy)) * (1.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-2.0) * u_BlurScale.xy)) * (6.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-1.0) * u_BlurScale.xy)) * (15.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+0.0) * u_BlurScale.xy)) * (20.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+1.0) * u_BlurScale.xy)) * (15.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+2.0) * u_BlurScale.xy)) * (6.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+3.0) * u_BlurScale.xy)) * (1.0/64.0);\n\n  gl_FragColor = color;\n}"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\nattribute vec3 a_Position;\n\nuniform mat4 u_World;\nuniform mat4 u_ViewProjection;\n\nvoid main() {\n  gl_Position = u_ViewProjection * u_World * vec4(a_Position, 1.0);\n}"},function(e,n,t){"use strict";t.r(n),n.default="#version 100\n\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n\nvoid main() {\n  float depth = gl_FragCoord.z;\n  float dx = 0.0;\n  float dy = 0.0;\n\n  #ifdef GL_OES_standard_derivatives\n    dx = dFdx(depth);\n    dy = dFdy(depth);\n  #endif\n\n  float moment2 = depth * depth + 0.25 * (dx * dx + dy * dy);\n  gl_FragColor = vec4(1.0 - depth, 1.0 - moment2, 0.0, 0.0);\n}"},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(7),o=t(15),i=t(95),a=t(19),s=t(96),u=function(){function e(e,n,t,o,s,u){if(void 0===s&&(s=0),void 0===u&&(u=a.ShadowQuality.medium),this.renderer=e,this.light=n,this.shadowArea=o,this.softness=s,this._lightViewProjection=new Float32Array(16),this.followCamera=!0,n.type===r.LightType.point)throw new Error("PIXI3D: Only directional and spot lights are supported as shadow casters.");this._shadowTexture=i.ShadowTexture.create(e,t,u),this._shadowTexture.baseTexture.framebuffer.addDepthTexture(),this._filterTexture=i.ShadowTexture.create(e,t,u)}return Object.defineProperty(e.prototype,"lightViewProjection",{get:function(){return this._lightViewProjection},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"shadowTexture",{get:function(){return this._shadowTexture},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"filterTexture",{get:function(){return this._filterTexture},enumerable:!0,configurable:!0}),e.prototype.clear=function(){this.renderer.renderTexture.bind(this._shadowTexture),this.renderer.renderTexture.clear([0,0,0,0],this.renderer.gl.COLOR_BUFFER_BIT|this.renderer.gl.DEPTH_BUFFER_BIT),this.renderer.renderTexture.bind(void 0)},e.prototype.updateLightViewProjection=function(){this.light.type===r.LightType.directional?s.ShadowMath.calculateDirectionalLightViewProjection(this):this.light.type===r.LightType.spot&&s.ShadowMath.calculateSpotLightViewProjection(this)},e.isMediumQualitySupported=function(e){return o.Platform.isHalfFloatFramebufferSupported(e)},e.isHighQualitySupported=function(e){return o.Platform.isFloatFramebufferSupported(e)},e}();n.ShadowCastingLight=u},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),o=t(19),i=t(15);!function(e){function n(e){return i.Platform.supportsFloatLinear(e)?r.SCALE_MODES.LINEAR:r.SCALE_MODES.NEAREST}e.create=function(e,t,a){var s=function(e,n){if(n===o.ShadowQuality.high){if(i.Platform.isFloatFramebufferSupported(e))return r.TYPES.FLOAT;if(i.Platform.isHalfFloatFramebufferSupported(e))return r.TYPES.HALF_FLOAT}if(n===o.ShadowQuality.medium&&i.Platform.isHalfFloatFramebufferSupported(e))return r.TYPES.HALF_FLOAT;return r.TYPES.UNSIGNED_BYTE}(e,a);return r.RenderTexture.create({width:t,height:t,type:s,scaleMode:n(e)})}}(n.ShadowTexture||(n.ShadowTexture={}))},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(4),o=t(7),i=t(13),a=t(11),s=t(2);!function(e){var n=new Float32Array(16),t=new Float32Array(16),u=(new Float32Array([0,1,0]),new Float32Array(4)),l=new Float32Array(3),f=new Float32Array(3),c=new Float32Array(3),d=new Float32Array(3);e.calculateDirectionalLightViewProjection=function(e){if(e.light.type===o.LightType.directional){var _=e.shadowArea/2,h=2*_/e.shadowArea,p=r.Mat4.ortho(-_,_,-_,_,-_,_,n),g=e.light,m=e.camera||s.Camera.main;m&&e.followCamera?(i.Vec3.scale(m.worldTransform.forward,_,d),i.Vec3.add(m.worldTransform.position,d,c),i.Vec3.transformQuat(c,a.Quat.conjugate(e.light.worldTransform.rotation,u),l),l[0]=h*Math.floor(l[0]/h),l[1]=h*Math.floor(l[1]/h),i.Vec3.transformQuat(l,g.worldTransform.rotation,l),i.Vec3.add(l,g.worldTransform.forward,f),r.Mat4.lookAt(l,f,g.worldTransform.up,t),r.Mat4.multiply(p,t,e.lightViewProjection)):(i.Vec3.add(g.worldTransform.position,e.light.worldTransform.forward,c),r.Mat4.lookAt(g.worldTransform.position,c,g.worldTransform.up,t),r.Mat4.multiply(p,t,e.lightViewProjection))}},e.calculateSpotLightViewProjection=function(e){if(e.light.type===o.LightType.spot){var a=e.light;r.Mat4.perspective(a.outerConeAngle*PIXI.DEG_TO_RAD*2,1,2,a.range,n),i.Vec3.add(a.worldTransform.position,a.worldTransform.forward,c),r.Mat4.lookAt(a.worldTransform.position,c,a.worldTransform.up,t),r.Mat4.multiply(n,t,e.lightViewProjection)}}}(n.ShadowMath||(n.ShadowMath={}))}])}));